
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_vqt.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_demos_tutorial_vqt.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_vqt.py:


Variational Quantum Thermalizer
===================================

.. meta::
    :property="og:description": Using the Variational Quantum Thermalizer to prepare the thermal state of a Heisenberg model Hamiltonian.
    :property="og:image": https://pennylane.ai/qml/_images/thumbnail_vqt.png

.. related::

    tutorial_vqe Variational quantum eigensolver

*Author: Jack Ceroni — Posted: 7 July 2020. Last updated: 28 January 2021.*

This demonstration discusses theory and experiments relating to a recently proposed quantum algorithm called the
`Variational Quantum Thermalizer <https://arxiv.org/abs/1910.02071>`__ (VQT): a generalization of the well-know
:doc:`Variational Quantum Eigensolver </demos/tutorial_vqe>` (VQE) to systems with non-zero temperatures.

.. GENERATED FROM PYTHON SOURCE LINES 22-25

The Idea
--------


.. GENERATED FROM PYTHON SOURCE LINES 28-96

The goal of the VQT is to prepare
the `thermal state <https://en.wikipedia.org/wiki/KMS_state>`__
of a given Hamiltonian :math:`\hat{H}` at temperature :math:`T`,
which is defined as

.. math:: \rho_\text{thermal} \ = \ \frac{e^{- \hat{H} \beta}}{\text{Tr}(e^{- \hat{H} \beta})} \ = \ \frac{e^{- \hat{H} \beta}}{Z_{\beta}},

where :math:`\beta \ = \ 1/T`. The thermal state is a `mixed state
<https://en.wikipedia.org/wiki/Quantum_state#Mixed_states>`__,
which means that can be described by an ensemble of pure states.
Since we are attempting to learn a mixed state, we must
deviate from the standard variational method of passing a pure state
through an ansatz circuit, and minimizing the energy expectation.

The VQT begins with an initial `density matrix
<https://en.wikipedia.org/wiki/Density_matrix>`__, :math:`\rho_{\theta}`,
described by a probability distribution parametrized by some collection
of parameters :math:`\theta`, and an ensemble of pure states,
:math:`\{|\psi_i\rangle\}`. Let :math:`p_i(\theta_i)` be the
probability corresponding to the :math:`i`-th pure state. We sample from
this probability distribution to get some pure state
:math:`|\psi_k\rangle`, which we pass through a parametrized circuit,
:math:`U(\phi)`. From the results of this circuit, we then calculate
:math:`\langle \psi_k | U^{\dagger}(\phi) \hat{H}\, U(\phi) |\psi_k\rangle`.
Repeating this process multiple times and taking the average of these
expectation values gives us the the expectation value of :math:`\hat{H}`
with respect to :math:`U \rho_{\theta} U^{\dagger}`.

.. figure:: ../demonstrations/vqt/ev.png
    :width: 100%
    :align: center

    Inputted parameters create an initial density matrix and a parametrized
    ansatz, which are used to calculate the expectation value of the Hamiltonian
    with respect to a new mixed state.

Arguably, the most important part of a variational circuit is its cost
function, which we attempt to minimize with a classical optimizer.
In VQE, we generally try to
minimize :math:`\langle \psi(\theta) | \hat{H} | \psi(\theta) \rangle`
which, upon minimization, gives us a parametrized circuit that prepares
a good approximation to the ground state of :math:`\hat{H}`. In the VQT,
the goal is to arrive at a parametrized probability distribution, and a
parametrized ansatz, that generate a good approximation to the thermal
state. This generally involves more than calculating the energy
expectation value. Luckily, we know that the thermal state of
:math:`\hat{H}` minimizes the following free-energy cost function

.. math:: \mathcal{L}(\theta, \ \phi) \ = \ \beta \ \text{Tr}( \hat{H} \ \hat{U}(\phi) \rho_{\theta} \hat{U}(\phi)^{\dagger} ) \ - \ S_\theta,

where :math:`S_{\theta}` is the `von Neumann entropy
<https://en.wikipedia.org/wiki/Von_Neumann_entropy>`__ of
:math:`U \rho_{\theta} U^{\dagger}`, which is the same as the von
Neumann entropy of :math:`\rho_{\theta}` due to invariance of entropy
under unitary transformations. This cost function is minimized when
:math:`\hat{U}(\phi) \rho_{\theta} \hat{U}(\phi)^{\dagger} \ = \ \rho_{\text{thermal}}`,
so similarly to VQE, we minimize it with a classical optimizer to obtain
the target parameters, and thus the target state.

.. figure:: ../demonstrations/vqt/vqt.png
    :width: 80%
    :align: center

    A high-level representation of how the VQT works.

All together, the outlined processes give us a general protocol to
generate thermal states.


.. GENERATED FROM PYTHON SOURCE LINES 99-102

Simulating the VQT for a 4-Qubit Heisenberg Model
--------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 105-108

In this demonstration, we simulate the 4-qubit Heisenberg model. We can
begin by importing the necessary dependencies.


.. GENERATED FROM PYTHON SOURCE LINES 108-121

.. code-block:: default



    import pennylane as qml
    from matplotlib import pyplot as plt
    import numpy as np
    from numpy import array
    import scipy
    from scipy.optimize import minimize
    import networkx as nx
    import seaborn
    import itertools

    np.random.seed(42)







.. GENERATED FROM PYTHON SOURCE LINES 122-132

The Heisenberg Hamiltonian is defined as

.. math:: \hat{H} \ = \ \displaystyle\sum_{(i, j) \in E} X_i X_j \ + \ Z_i Z_j \ + \ Y_i Y_j,

where :math:`X_i`, :math:`Y_i` and :math:`Z_i` are the Pauli gates
acting on the :math:`i`-th qubit. In addition, :math:`E` is the set of
edges in the graph :math:`G \ = \ (V, \ E)` describing the interactions
between the qubits. In this demonstration, we define the interaction graph to
be the cycle graph:


.. GENERATED FROM PYTHON SOURCE LINES 132-138

.. code-block:: default



    interaction_graph = nx.cycle_graph(4)
    nx.draw(interaction_graph)





.. image-sg:: /demos/images/sphx_glr_tutorial_vqt_001.png
   :alt: tutorial vqt
   :srcset: /demos/images/sphx_glr_tutorial_vqt_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 139-142

With this, we can calculate the matrix representation of the Heisenberg
Hamiltonian in the computational basis:


.. GENERATED FROM PYTHON SOURCE LINES 142-172

.. code-block:: default



    def create_hamiltonian_matrix(n, graph):

        matrix = np.zeros((2 ** n, 2 ** n))

        for i in graph.edges:
            x = y = z = 1
            for j in range(0, n):
                if j == i[0] or j == i[1]:
                    x = np.kron(x, qml.matrix(qml.PauliX)(0))
                    y = np.kron(y, qml.matrix(qml.PauliY)(0))
                    z = np.kron(z, qml.matrix(qml.PauliZ)(0))
                else:
                    x = np.kron(x, np.identity(2))
                    y = np.kron(y, np.identity(2))
                    z = np.kron(z, np.identity(2))

            matrix = np.add(matrix, np.add(x, np.add(y, z)))

        return matrix


    ham_matrix = create_hamiltonian_matrix(4, interaction_graph)

    # Prints a visual representation of the Hamiltonian matrix
    seaborn.heatmap(ham_matrix.real)
    plt.show()





.. image-sg:: /demos/images/sphx_glr_tutorial_vqt_002.png
   :alt: tutorial vqt
   :srcset: /demos/images/sphx_glr_tutorial_vqt_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 173-176

With this done, we construct the VQT. We begin by defining some
fixed variables that are used throughout the simulation:


.. GENERATED FROM PYTHON SOURCE LINES 176-182

.. code-block:: default



    beta = 2  # beta = 1/T
    nr_qubits = 4









.. GENERATED FROM PYTHON SOURCE LINES 183-200

The first step of the VQT is to create the initial density matrix,
:math:`\rho_\theta`. In this demonstration, we let :math:`\rho_\theta` be
*factorized*, meaning that it can be written as an uncorrelated tensor
product of :math:`4` one-qubit density matrices that are diagonal in
the computational basis. The motivation is that in this factorized model,
the number of :math:`\theta_i` parameters needed to describe
:math:`\rho_\theta` scales linearly rather than exponentially with
the number of qubits. For each one-qubit system described by
:math:`\rho_\theta^i`, we have

.. math:: \rho_{\theta}^{i} \ = \ p_i(\theta_i) |0\rangle \langle 0| \ + \ (1 \ - \ p_i(\theta_i))|1\rangle \langle1|.

From here, all we have to do is define :math:`p_i(\theta_i)`, which we
choose to be the sigmoid

.. math:: p_{i}(\theta_{i}) \ = \ \frac{e^{\theta_i}}{e^{\theta_i} \ + \ 1}.


.. GENERATED FROM PYTHON SOURCE LINES 200-206

.. code-block:: default



    def sigmoid(x):
        return np.exp(x) / (np.exp(x) + 1)









.. GENERATED FROM PYTHON SOURCE LINES 207-214

This is a natural choice for probability function, as it has a range of
:math:`[0, \ 1]`, meaning that we don’t need to restrict the domain of
:math:`\theta_i` to some subset of the real numbers. With the probability
function defined, we can write a method that gives us the diagonal
elements of each one-qubit density matrix, for some parameters
:math:`\theta`:


.. GENERATED FROM PYTHON SOURCE LINES 214-220

.. code-block:: default



    def prob_dist(params):
        return np.vstack([sigmoid(params), 1 - sigmoid(params)]).T









.. GENERATED FROM PYTHON SOURCE LINES 221-224

Creating the Ansatz Circuit
^^^^^^^^^^^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 227-235

With this done, we can move on to defining the ansatz circuit,
:math:`U(\phi)`, composed of rotational and coupling layers. The
rotation layer is simply ``RX``, ``RY``, and ``RZ``
gates applied to each qubit. We make use of the
``AngleEmbedding``
function, which allows us to easily pass parameters into rotational
layers.


.. GENERATED FROM PYTHON SOURCE LINES 235-244

.. code-block:: default



    def single_rotation(phi_params, qubits):

        rotations = ["Z", "Y", "X"]
        for i in range(0, len(rotations)):
            qml.AngleEmbedding(phi_params[i], wires=qubits, rotation=rotations[i])









.. GENERATED FROM PYTHON SOURCE LINES 245-251

To construct the general ansatz, we combine the method we have just
defined with a collection of parametrized coupling gates placed between
qubits that share an edge in the interaction graph. In addition, we
define the depth of the ansatz, and the device on which the simulations
are run:


.. GENERATED FROM PYTHON SOURCE LINES 251-280

.. code-block:: default



    depth = 4
    dev = qml.device("lightning.qubit", wires=nr_qubits)


    def quantum_circuit(rotation_params, coupling_params, sample=None):

        # Prepares the initial basis state corresponding to the sample
        qml.BasisStatePreparation(sample, wires=range(nr_qubits))

        # Prepares the variational ansatz for the circuit
        for i in range(0, depth):
            single_rotation(rotation_params[i], range(nr_qubits))
            qml.broadcast(
                unitary=qml.CRX,
                pattern="ring",
                wires=range(nr_qubits),
                parameters=coupling_params[i]
            )

        # Calculates the expectation value of the Hamiltonian with respect to the prepared states
        return qml.expval(qml.Hermitian(ham_matrix, wires=range(nr_qubits)))


    # Constructs the QNode
    qnode = qml.QNode(quantum_circuit, dev, interface="autograd")









.. GENERATED FROM PYTHON SOURCE LINES 281-284

We can get an idea of what this circuit looks like by printing out a
test circuit:


.. GENERATED FROM PYTHON SOURCE LINES 284-291

.. code-block:: default



    rotation_params = [[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] for i in range(0, depth)]
    coupling_params = [[1, 1, 1, 1] for i in range(0, depth)]
    print(qml.draw(qnode, expansion_strategy="device", show_matrices=True)(rotation_params, coupling_params, sample=[1, 0, 1, 0]))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0: ──X─────────RZ(1.00)──RY(1.00)──RX(1.00)─╭●────────────────────────────╭RX(1.00)──RZ(1.00)
    1: ──RZ(1.00)──RY(1.00)──RX(1.00)───────────╰RX(1.00)─╭●──────────────────│──────────RZ(1.00)
    2: ──X─────────RZ(1.00)──RY(1.00)──RX(1.00)───────────╰RX(1.00)─╭●────────│──────────RZ(1.00)
    3: ──RZ(1.00)──RY(1.00)──RX(1.00)───────────────────────────────╰RX(1.00)─╰●─────────RZ(1.00)

    ───RY(1.00)──RX(1.00)─╭●────────────────────────────╭RX(1.00)──RZ(1.00)──RY(1.00)──RX(1.00)
    ───RY(1.00)──RX(1.00)─╰RX(1.00)─╭●──────────────────│──────────RZ(1.00)──RY(1.00)──RX(1.00)
    ───RY(1.00)──RX(1.00)───────────╰RX(1.00)─╭●────────│──────────RZ(1.00)──RY(1.00)──RX(1.00)
    ───RY(1.00)──RX(1.00)─────────────────────╰RX(1.00)─╰●─────────RZ(1.00)──RY(1.00)──RX(1.00)

    ──╭●────────────────────────────╭RX(1.00)──RZ(1.00)──RY(1.00)──RX(1.00)─╭●─────────────────
    ──╰RX(1.00)─╭●──────────────────│──────────RZ(1.00)──RY(1.00)──RX(1.00)─╰RX(1.00)─╭●───────
    ────────────╰RX(1.00)─╭●────────│──────────RZ(1.00)──RY(1.00)──RX(1.00)───────────╰RX(1.00)
    ──────────────────────╰RX(1.00)─╰●─────────RZ(1.00)──RY(1.00)──RX(1.00)────────────────────

    ────────────╭RX(1.00)─┤ ╭<𝓗(M0)>
    ────────────│─────────┤ ├<𝓗(M0)>
    ──╭●────────│─────────┤ ├<𝓗(M0)>
    ──╰RX(1.00)─╰●────────┤ ╰<𝓗(M0)>
    M0 = 
    [[ 4.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  2.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j -4.+0.j  2.+0.j  0.+0.j  0.+0.j
       2.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j]
     [ 0.+0.j  2.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j
       2.+0.j -4.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  2.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  2.+0.j  0.+0.j  0.+0.j]
     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j
       0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  4.+0.j]]




.. GENERATED FROM PYTHON SOURCE LINES 292-300

Recall that the final cost function depends not only on the expectation
value of the Hamiltonian, but also the von Neumann entropy of the state,
which is determined by the collection of :math:`p_i(\theta_i)`\ s. Since
the entropy of a collection of multiple uncorrelated subsystems is the
same as the sum of the individual values of entropy for each subsystem,
we can sum the entropy values of each one-qubit system in the factorized
space to get the total:


.. GENERATED FROM PYTHON SOURCE LINES 300-313

.. code-block:: default



    def calculate_entropy(distribution):

        total_entropy = 0
        for d in distribution:
            total_entropy += -1 * d[0] * np.log(d[0]) + -1 * d[1] * np.log(d[1])

        # Returns an array of the entropy values of the different initial density matrices

        return total_entropy









.. GENERATED FROM PYTHON SOURCE LINES 314-317

The Cost Function
^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 320-342

Finally, we combine the ansatz and the entropy function to get the cost
function. In this demonstration, we deviate slightly from how VQT would be
performed in practice. Instead of sampling from the probability
distribution describing the initial mixed state, we use the ansatz to
calculate
:math:`\langle x_i | U^{\dagger}(\phi) \hat{H} \,U(\phi) |x_i\rangle` for
each basis state :math:`|x_i\rangle`. We then multiply each of these
expectation values by their corresponding :math:`(\rho_\theta)_{ii}`,
which is exactly the probability of sampling :math:`|x_i\rangle` from
the distribution. Summing each of these terms together gives us the
expected value of the Hamiltonian with respect to the transformed
density matrix.

In the case of this small, simple model, exact
calculations such as this reduce the number of circuit executions, and thus the total
execution time.

You may have noticed previously that the “structure” of the
parameters list passed into the ansatz is quite complicated. We write a
general function that takes a one-dimensional list, and converts it into
the nested list structure that can be inputed into the ansatz:


.. GENERATED FROM PYTHON SOURCE LINES 342-364

.. code-block:: default



    def convert_list(params):

        # Separates the list of parameters
        dist_params = params[0:nr_qubits]
        ansatz_params_1 = params[nr_qubits : ((depth + 1) * nr_qubits)]
        ansatz_params_2 = params[((depth + 1) * nr_qubits) :]

        coupling = np.split(ansatz_params_1, depth)

        # Partitions the parameters into multiple lists
        split = np.split(ansatz_params_2, depth)
        rotation = []
        for s in split:
            rotation.append(np.split(s, 3))

        ansatz_params = [rotation, coupling]

        return [dist_params, ansatz_params]









.. GENERATED FROM PYTHON SOURCE LINES 365-368

We then pass this function, along with the ansatz and the entropy
function into the final cost function:


.. GENERATED FROM PYTHON SOURCE LINES 368-402

.. code-block:: default



    def exact_cost(params):

        global iterations

        # Transforms the parameter list
        parameters = convert_list(params)
        dist_params = parameters[0]
        ansatz_params = parameters[1]

        # Creates the probability distribution
        distribution = prob_dist(dist_params)

        # Generates a list of all computational basis states of our qubit system
        combos = itertools.product([0, 1], repeat=nr_qubits)
        s = [list(c) for c in combos]

        # Passes each basis state through the variational circuit and multiplies
        # the calculated energy EV with the associated probability from the distribution
        cost = 0
        for i in s:
            result = qnode(ansatz_params[0], ansatz_params[1], sample=i)
            for j in range(0, len(i)):
                result = result * distribution[j][i[j]]
            cost += result

        # Calculates the entropy and the final cost function
        entropy = calculate_entropy(distribution)
        final_cost = beta * cost - entropy

        return final_cost









.. GENERATED FROM PYTHON SOURCE LINES 403-405

We then create the function that is passed into the optimizer:


.. GENERATED FROM PYTHON SOURCE LINES 405-420

.. code-block:: default



    def cost_execution(params):

        global iterations

        cost = exact_cost(params)

        if iterations % 50 == 0:
            print("Cost at Step {}: {}".format(iterations, cost))

        iterations += 1
        return cost









.. GENERATED FROM PYTHON SOURCE LINES 421-428

The last step is to define the optimizer, and execute the optimization
method. We use the "Constrained Optimization by Linear Approximation"
(`COBYLA <https://en.wikipedia.org/wiki/COBYLA>`__) optimization method,
which is a gradient-free optimizer. We observe that for this algorithm, COBYLA
has a lower runtime than its gradient-based counterparts, so we utilize it
in this demonstration:


.. GENERATED FROM PYTHON SOURCE LINES 428-438

.. code-block:: default



    iterations = 0

    number = nr_qubits * (1 + depth * 4)
    params = [np.random.randint(-300, 300) / 100 for i in range(0, number)]
    out = minimize(cost_execution, x0=params, method="COBYLA", options={"maxiter": 1600})
    out_params = out["x"]






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Cost at Step 0: -0.6605354666522003
    Cost at Step 50: -2.869994162243926
    Cost at Step 100: -4.642067184244078
    Cost at Step 150: -5.127022428216526
    Cost at Step 200: -6.561237930042775
    Cost at Step 250: -7.151193369991695
    Cost at Step 300: -7.986931118449973
    Cost at Step 350: -9.103304855337832
    Cost at Step 400: -9.803011327908646
    Cost at Step 450: -10.031971736555349
    Cost at Step 500: -10.507166220723674
    Cost at Step 550: -10.971866340904622
    Cost at Step 600: -11.56313733301446
    Cost at Step 650: -12.447857236171258
    Cost at Step 700: -12.676842904839047
    Cost at Step 750: -13.125218929761665
    Cost at Step 800: -13.596346745790562
    Cost at Step 850: -13.64309394785805
    Cost at Step 900: -13.890681021690392
    Cost at Step 950: -14.03616486135087
    Cost at Step 1000: -14.228206918135943
    Cost at Step 1050: -14.346390065399973
    Cost at Step 1100: -14.449975944222603
    Cost at Step 1150: -14.449676264232155
    Cost at Step 1200: -14.540690039964886
    Cost at Step 1250: -14.693572908585232
    Cost at Step 1300: -14.762598370348176
    Cost at Step 1350: -14.85398668033985
    Cost at Step 1400: -14.876388183598326
    Cost at Step 1450: -14.963072546119866
    Cost at Step 1500: -15.025045790319348
    Cost at Step 1550: -15.071001589394694




.. GENERATED FROM PYTHON SOURCE LINES 439-444

We can now check to see how well our optimization method performed by
writing a function that reconstructs the transformed density
matrix of some initial state, with respect to lists of
:math:`\theta` and :math:`\phi` parameters:


.. GENERATED FROM PYTHON SOURCE LINES 444-478

.. code-block:: default



    def prepare_state(params, device):

        # Initializes the density matrix

        final_density_matrix = np.zeros((2 ** nr_qubits, 2 ** nr_qubits))

        # Prepares the optimal parameters, creates the distribution and the bitstrings
        parameters = convert_list(params)
        dist_params = parameters[0]
        unitary_params = parameters[1]

        distribution = prob_dist(dist_params)

        combos = itertools.product([0, 1], repeat=nr_qubits)
        s = [list(c) for c in combos]

        # Runs the circuit in the case of the optimal parameters, for each bitstring,
        # and adds the result to the final density matrix

        for i in s:
            qnode(unitary_params[0], unitary_params[1], sample=i)
            state = device.state
            for j in range(0, len(i)):
                state = np.sqrt(distribution[j][i[j]]) * state
            final_density_matrix = np.add(final_density_matrix, np.outer(state, np.conj(state)))

        return final_density_matrix

    # Prepares the density matrix
    prep_density_matrix = prepare_state(out_params, dev)









.. GENERATED FROM PYTHON SOURCE LINES 479-482

We then display the prepared state by plotting a heatmap of the
entry-wise absolute value of the density matrix:


.. GENERATED FROM PYTHON SOURCE LINES 482-487

.. code-block:: default


    seaborn.heatmap(abs(prep_density_matrix))
    plt.show()





.. image-sg:: /demos/images/sphx_glr_tutorial_vqt_003.png
   :alt: tutorial vqt
   :srcset: /demos/images/sphx_glr_tutorial_vqt_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 488-491

Numerical Calculations
^^^^^^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 494-498

To verify that we have in fact prepared a good approximation of the
thermal state, let’s calculate it numerically by taking the matrix
exponential of the Heisenberg Hamiltonian, as was outlined earlier.


.. GENERATED FROM PYTHON SOURCE LINES 498-521

.. code-block:: default



    def create_target(qubit, beta, ham, graph):

        # Calculates the matrix form of the density matrix, by taking
        # the exponential of the Hamiltonian

        h = ham(qubit, graph)
        y = -1 * float(beta) * h
        new_matrix = scipy.linalg.expm(np.array(y))
        norm = np.trace(new_matrix)
        final_target = (1 / norm) * new_matrix

        return final_target


    target_density_matrix = create_target(
        nr_qubits, beta,
        create_hamiltonian_matrix,
        interaction_graph
        )









.. GENERATED FROM PYTHON SOURCE LINES 522-524

Finally, we can plot a heatmap of the target density matrix:


.. GENERATED FROM PYTHON SOURCE LINES 524-530

.. code-block:: default



    seaborn.heatmap(abs(target_density_matrix))
    plt.show()





.. image-sg:: /demos/images/sphx_glr_tutorial_vqt_004.png
   :alt: tutorial vqt
   :srcset: /demos/images/sphx_glr_tutorial_vqt_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 531-541

The two images look very similar, which suggests that we have
constructed a good approximation of the thermal state! Alternatively, if
you prefer a more quantitative measure of similarity, we can calculate
the trace distance between the two density matrices, which is defined
as

.. math:: T(\rho, \ \sigma) \ = \ \frac{1}{2} \text{Tr} \sqrt{(\rho \ - \ \sigma)^{\dagger} (\rho \ - \ \sigma)},

and is a metric on the space of density matrices:


.. GENERATED FROM PYTHON SOURCE LINES 541-551

.. code-block:: default



    def trace_distance(one, two):

        return 0.5 * np.trace(np.absolute(np.add(one, -1 * two)))


    print("Trace Distance: " + str(trace_distance(target_density_matrix, prep_density_matrix)))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Trace Distance: 0.062261824685629415




.. GENERATED FROM PYTHON SOURCE LINES 552-556

The closer to zero, the more similar the two states are. Thus, we
have found a close approximation of the thermal state
of :math:`H` with the VQT!


.. GENERATED FROM PYTHON SOURCE LINES 559-571

References
----------

1. Verdon, G., Marks, J., Nanda, S., Leichenauer, S., & Hidary, J.
   (2019). Quantum Hamiltonian-Based Models and the Variational Quantum
   Thermalizer Algorithm. arXiv preprint
   `arXiv:1910.02071 <https://arxiv.org/abs/1910.02071>`__.


About the author
----------------
.. include:: ../_static/authors/jack_ceroni.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 3 minutes  52.670 seconds)


.. _sphx_glr_download_demos_tutorial_vqt.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tutorial_vqt.py <tutorial_vqt.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tutorial_vqt.ipynb <tutorial_vqt.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
