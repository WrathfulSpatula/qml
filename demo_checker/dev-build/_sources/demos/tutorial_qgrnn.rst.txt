
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_qgrnn.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_qgrnn.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_qgrnn.py:


The Quantum Graph Recurrent Neural Network
===========================================

.. meta::
    :property="og:description": Using a quantum graph recurrent neural network to learn quantum dynamics.
    :property="og:image": https://pennylane.ai/qml/_images/qgrnn_thumbnail.png

*Author: Jack Ceroni — Posted: 27 July 2020. Last updated: 25 March 2021.*

.. GENERATED FROM PYTHON SOURCE LINES 14-20

This demonstration investigates quantum graph
recurrent neural networks (QGRNN), which are the quantum analogue of a
classical graph recurrent neural network, and a subclass of the more
general quantum graph
neural network ansatz. Both the QGNN and QGRNN were introduced in
`this paper (2019) <https://arxiv.org/abs/1909.12264>`__.

.. GENERATED FROM PYTHON SOURCE LINES 22-25

The Idea
--------


.. GENERATED FROM PYTHON SOURCE LINES 28-51

A graph is defined as a set of *nodes* along with a set of
**edges**, which represent connections between nodes.
Information can be encoded into graphs by assigning numbers
to nodes and edges, which we call **weights**.
It is usually convenient to think of a graph visually:

.. image:: ../demonstrations/qgrnn/graph.png
    :width: 70%
    :align: center

In recent years, the concept of a
`graph neural network <https://arxiv.org/abs/1812.08434>`__ (GNN) has been
receiving a lot of attention from the machine learning community.
A GNN seeks
to learn a representation (a mapping of data into a
low-dimensional vector space) of a given graph with feature vectors assigned
to nodes and edges. Each of the vectors in the learned
representation preserves not only the features, but also the overall
topology of the graph, i.e., which nodes are connected by edges. The
quantum graph neural network attempts to do something similar, but for
features that are quantum-mechanical; for instance, a
collection of quantum states.


.. GENERATED FROM PYTHON SOURCE LINES 54-78

Consider the class of qubit Hamiltonians that are *quadratic*, meaning that
the terms of the Hamiltonian represent either interactions between two
qubits, or the energy of individual qubits.
This class of Hamiltonians is naturally described by graphs, with
second-order terms between qubits corresponding to weighted edges between
nodes, and first-order terms corresponding to node weights.

A well known example of a quadratic Hamiltonian is the transverse-field
Ising model, which is defined as

.. math::

    \hat{H}_{\text{Ising}}(\boldsymbol\theta) \ = \ \displaystyle\sum_{(i, j) \in E}
    \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \
    \displaystyle\sum_{i} X_{i},

where :math:`\boldsymbol\theta \ = \ \{\theta^{(1)}, \ \theta^{(2)}\}`.
In this Hamiltonian, the set :math:`E` that determines which pairs of qubits
have :math:`ZZ` interactions can be represented by the set of edges for some graph. With
the qubits as nodes, this graph is called the *interaction graph*.
The :math:`\theta^{(1)}` parameters correspond to the edge weights and
the :math:`\theta^{(2)}`
parameters correspond to weights on the nodes.


.. GENERATED FROM PYTHON SOURCE LINES 81-121

This result implies that we can think about *quantum circuits* with
graph-theoretic properties. Recall that the time-evolution operator
with respect to some Hamiltonian :math:`H` is defined as:

.. math:: U \ = \ e^{-it H}.

Thus, we have a clean way of taking quadratic Hamiltonians and turning
them into unitaries (quantum circuits) that preserve the same correspondance to a graph.
In the case of the Ising Hamiltonian, we have:

.. math::

    U_{\text{Ising}} \ = \ e^{-it \hat{H}_{\text{Ising}} (\boldsymbol\theta)} \ = \ \exp \Big[ -it
    \Big( \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \
    \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i} \Big) \Big]

In general, this kind of unitary is very difficult to implement on a quantum computer.
However, we can approximate it using the `Trotter-Suzuki decomposition
<https://en.wikipedia.org/wiki/Time-evolving_block_decimation#The_Suzuki-Trotter_expansion>`__:

.. math::

    \exp \Big[ -it \Big( \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \
    \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i} \Big) \Big]
    \ \approx \ \displaystyle\prod_{k \ = \ 1}^{t / \Delta} \Bigg[ \displaystyle\prod_{j \ = \
    1}^{Q} e^{-i \Delta \hat{H}_{\text{Ising}}^{j}(\boldsymbol\theta)} \Bigg]

where :math:`\hat{H}_{\text{Ising}}^{j}(\boldsymbol\theta)` is the :math:`j`-th term of the
Ising Hamiltonian and :math:`\Delta` is some small number.

This circuit is a specific instance of the **Quantum Graph
Recurrent Neural Network**, which in general is defined as a variational ansatz of
the form

.. math::

    U_{H}(\boldsymbol\mu, \ \boldsymbol\gamma) \ = \ \displaystyle\prod_{i \ = \ 1}^{P} \Bigg[
    \displaystyle\prod_{j \ = \ 1}^{Q} e^{-i \gamma_j H^{j}(\boldsymbol\mu)} \Bigg],

for some parametrized quadratic Hamiltonian, :math:`H(\boldsymbol\mu)`.

.. GENERATED FROM PYTHON SOURCE LINES 123-126

Using the QGRNN
^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 128-172

Since the QGRNN ansatz is equivalent to the
approximate time evolution of some quadratic Hamiltonian, we can use it
to learn the dynamics of a quantum system.

Continuing with the Ising model example, let's imagine we have some system
governed by :math:`\hat{H}_{\text{Ising}}(\boldsymbol\alpha)` for an unknown set of
target parameters,
:math:`\boldsymbol\alpha` and an unknown interaction graph :math:`G`. Let's also
suppose we have access to copies of some
low-energy, non-ground state of the target Hamiltonian, :math:`|\psi_0\rangle`. In addition,
we have access to a collection of time-evolved states,
:math:`\{ |\psi(t_1)\rangle, \ |\psi(t_2)\rangle, \ ..., \ |\psi(t_N)\rangle \}`, defined by:

.. math:: |\psi(t_k)\rangle \ = \ e^{-i t_k \hat{H}_{\text{Ising}}(\boldsymbol\alpha)} |\psi_0\rangle.

We call the low-energy states and the collection of time-evolved states *quantum data*.
From here, we randomly pick a number of time-evolved states
from our collection. For any state that we choose, which is
evolved to some time :math:`t_k`, we compare it
to

.. math::

    U_{\hat{H}_{\text{Ising}}}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle \ \approx \ e^{-i t_k
    \hat{H}_{\text{Ising}}(\boldsymbol\mu)} |\psi_0\rangle.

This is done by feeding one of the copies of :math:`|\psi_0\rangle` into a quantum circuit
with the QGRNN ansatz, with some guessed set of parameters :math:`\boldsymbol\mu`
and a guessed interaction graph, :math:`G'`.
We then use a classical optimizer to maximize the average
"similarity" between the time-evolved states and the states prepared
with the QGRNN.

As the QGRNN states becomes more similar to
each time-evolved state for each sampled time, it follows that
:math:`\boldsymbol\mu \ \rightarrow \ \boldsymbol\alpha`
and we are able to learn the unknown parameters of the Hamiltonian.

.. figure:: ../demonstrations/qgrnn/qgrnn3.png
    :width: 90%
    :align: center

    A visual representation of one execution of the QGRNN for one piece of quantum data.


.. GENERATED FROM PYTHON SOURCE LINES 175-178

Learning an Ising Model with the QGRNN
---------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 181-184

We now attempt to use the QGRNN to learn the parameters corresponding
to an arbitrary transverse-field Ising model Hamiltonian.


.. GENERATED FROM PYTHON SOURCE LINES 187-190

Getting Started
^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 193-195

We begin by importing the necessary dependencies:


.. GENERATED FROM PYTHON SOURCE LINES 206-209

We also define some fixed values that are used throughout
the simulation.


.. GENERATED FROM PYTHON SOURCE LINES 216-224

In this
simulation, we don't have quantum data readily available to pass into
the QGRNN, so we have to generate it ourselves. To do this, we must
have knowledge of the target interaction graph and the target Hamiltonian.

Let us use the following cyclic graph as the target interaction graph
of the Ising Hamiltonian:


.. GENERATED FROM PYTHON SOURCE LINES 234-253

We can then initialize the “unknown” target parameters that describe the
target Hamiltonian, :math:`\boldsymbol\alpha \ = \ \{\alpha^{(1)}, \ \alpha^{(2)}\}`.
Recall from the introduction that we have defined our parametrized
Ising Hamiltonian to be of the form:

.. math::

    \hat{H}_{\text{Ising}}(\boldsymbol\theta) \ = \ \displaystyle\sum_{(i, j) \in E}
    \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \
    \displaystyle\sum_{i} X_{i},

where :math:`E` is the set of edges in the interaction graph, and
:math:`X_i` and :math:`Z_i` are the Pauli-X and Pauli-Z on the
:math:`i`-th qubit.

For this tutorial, we choose the target parameters by sampling from
a uniform probability distribution ranging from :math:`-2` to :math:`2`, with
two-decimal precision.


.. GENERATED FROM PYTHON SOURCE LINES 259-269

In theory, these parameters can
be any value we want, provided they are reasonably small enough that the QGRNN can reach them
in a tractable number of optimization steps.
In ``matrix_params``, the first list represents the :math:`ZZ` interaction parameters and
the second list represents the single-qubit :math:`Z` parameters.

Finally,
we use this information to generate the matrix form of the
Ising model Hamiltonian in the computational basis:


.. GENERATED FROM PYTHON SOURCE LINES 269-308

.. code-block:: default
































    # Prints a visual representation of the Hamiltonian matrix














.. GENERATED FROM PYTHON SOURCE LINES 309-312

Preparing Quantum Data
^^^^^^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 315-320

The collection of quantum data needed to run the QGRNN has two components:
(i) copies of a low-energy state, and (ii) a collection of time-evolved states, each of which are
simply the low-energy state evolved to different times.
The following is a low-energy state of the target Hamiltonian:


.. GENERATED FROM PYTHON SOURCE LINES 342-356

This state can be obtained by using a decoupled version of the
:doc:`Variational Quantum Eigensolver </demos/tutorial_vqe>` algorithm (VQE).
Essentially, we choose a
VQE ansatz such that the circuit cannot learn the exact ground state,
but it can get fairly close. Another way to arrive at the same result is
to perform VQE with a reasonable ansatz, but to terminate the algorithm
before it converges to the ground state. If we used the exact ground state
:math:`|\psi_0\rangle`, the time-dependence would be trivial and the
data would not provide enough information about the Hamiltonian parameters.

We can verify that this is a low-energy
state by numerically finding the lowest eigenvalue of the Hamiltonian
and comparing it to the energy expectation of this low-energy state:


.. GENERATED FROM PYTHON SOURCE LINES 368-376

We have in fact found a low-energy, non-ground state,
as the energy expectation is slightly greater than the energy of the true ground
state. This, however, is only half of the information we need. We also require
a collection of time-evolved, low-energy states.
Evolving the low-energy state forward in time is fairly straightforward: all we
have to do is multiply the initial state by a time-evolution unitary. This operation
can be defined as a custom gate in PennyLane:


.. GENERATED FROM PYTHON SOURCE LINES 385-388

We don't actually generate time-evolved quantum data quite yet,
but we now have all the pieces required for its preparation.


.. GENERATED FROM PYTHON SOURCE LINES 391-394

Learning the Hamiltonian
^^^^^^^^^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 397-405

With the quantum data defined, we are able to construct the QGRNN and
learn the target Hamiltonian.
Each of the exponentiated
Hamiltonians in the QGRNN ansatz,
:math:`\hat{H}^{j}_{\text{Ising}}(\boldsymbol\mu)`, are the
:math:`ZZ`, :math:`Z`, and :math:`X` terms from the Ising
Hamiltonian. This gives:


.. GENERATED FROM PYTHON SOURCE LINES 423-434

As was mentioned in the first section, the QGRNN has two
registers. In one register, some piece of quantum data
:math:`|\psi(t)\rangle` is prepared and in the other we have
:math:`U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle`. We need a
way to measure the similarity between these states.
This can be done by using the fidelity, which is
simply the modulus squared of the inner product between the states,
:math:`| \langle \psi(t) | U_{H}(\Delta, \ \boldsymbol\mu) |\psi_0\rangle |^2`.
To calculate this value, we use a `SWAP
test <https://en.wikipedia.org/wiki/Swap_test>`__ between the registers:


.. GENERATED FROM PYTHON SOURCE LINES 445-463

After performing this procedure, the value returned from a measurement of the circuit is
:math:`\langle Z \rangle`, with respect to the ``control`` qubit.
The probability of measuring the :math:`|0\rangle` state
in this control qubit is related to both the fidelity
between registers and :math:`\langle Z \rangle`. Thus, with a bit of algebra,
we find that :math:`\langle Z \rangle` is equal to the fidelity.

Before creating the full QGRNN and the cost function, we
define a few more fixed values. Among these is a "guessed"
interaction graph, which we set to be a
`complete graph <https://en.wikipedia.org/wiki/Complete_graph>`__. This choice is
motivated by the fact that any target interaction graph will be a subgraph
of this initial guess. Part of the idea behind the QGRNN is that
we don’t know the interaction graph, and it has to be learned. In this case, the graph
is learned *automatically* as the target parameters are optimized. The
:math:`\boldsymbol\mu` parameters that correspond to edges that don't exist in
the target graph will simply approach :math:`0`.


.. GENERATED FROM PYTHON SOURCE LINES 463-480

.. code-block:: default


    # Defines some fixed values







    # Defines the interaction graph for the new qubit system














.. GENERATED FROM PYTHON SOURCE LINES 481-483

With this done, we implement the QGRNN circuit for some given time value:


.. GENERATED FROM PYTHON SOURCE LINES 507-528

We have the full QGRNN circuit, but we still need to define a cost function.
We know that
:math:`| \langle \psi(t) | U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle |^2`
approaches :math:`1` as the states become more similar and approaches
:math:`0` as the states become orthogonal. Thus, we choose
to minimize the quantity
:math:`-| \langle \psi(t) | U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle |^2`.
Since we are interested in calculating this value for many different
pieces of quantum data, the final cost function is the average
negative fidelity* between registers:

.. math::

    \mathcal{L}(\boldsymbol\mu, \ \Delta) \ = \ - \frac{1}{N} \displaystyle\sum_{i \ = \ 1}^{N} |
    \langle \psi(t_i) | \ U_{H}(\boldsymbol\mu, \ \Delta) \ |\psi_0\rangle |^2,

where we use :math:`N` pieces of quantum data.

Before creating the cost function, we must define a few more fixed
variables:


.. GENERATED FROM PYTHON SOURCE LINES 534-536

We then define the negative fidelity cost function:


.. GENERATED FROM PYTHON SOURCE LINES 553-555

Next we set up for optimization.


.. GENERATED FROM PYTHON SOURCE LINES 555-572

.. code-block:: default


    # Defines the new device


    # Defines the new QNode



















.. GENERATED FROM PYTHON SOURCE LINES 573-574

All that remains is executing the optimization loop.

.. GENERATED FROM PYTHON SOURCE LINES 586-590

With the learned parameters, we construct a visual representation
of the Hamiltonian to which they correspond and compare it to the
target Hamiltonian, and the initial guessed Hamiltonian:


.. GENERATED FROM PYTHON SOURCE LINES 617-628

These images look very similar, indicating that the QGRNN has done a good job
learning the target Hamiltonian.

We can also look
at the exact values of the target and learned parameters.
Recall how the target
interaction graph has :math:`4` edges while the complete graph has :math:`6`.
Thus, as the QGRNN converges to the optimal solution, the weights corresponding to
edges :math:`(1, 3)` and :math:`(2, 0)` in the complete graph should go to :math:`0`, as
this indicates that they have no effect, and effectively do not exist in the learned
Hamiltonian.

.. GENERATED FROM PYTHON SOURCE LINES 628-640

.. code-block:: default


    # We first pick out the weights of edges (1, 3) and (2, 0)
    # and then remove them from the list of target parameters
















.. GENERATED FROM PYTHON SOURCE LINES 641-643

Then, we print all of the weights:


.. GENERATED FROM PYTHON SOURCE LINES 658-666

The weights of edges :math:`(1, 3)` and :math:`(2, 0)`
are very close to :math:`0`, indicating we have learned the cycle graph
from the complete graph. In addition, the remaining learned weights
are fairly close to those of the target Hamiltonian.
Thus, the QGRNN is functioning properly, and has learned the target
Ising Hamiltonian to a high
degree of accuracy!


.. GENERATED FROM PYTHON SOURCE LINES 668-679

References
----------

1. Verdon, G., McCourt, T., Luzhnica, E., Singh, V., Leichenauer, S., &
   Hidary, J. (2019). Quantum Graph Neural Networks. arXiv preprint
   `arXiv:1909.12264 <https://arxiv.org/abs/1909.12264>`__.


About the author
----------------
.. include:: ../_static/authors/jack_ceroni.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.001 seconds)


.. _sphx_glr_download_demos_tutorial_qgrnn.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_qgrnn.py <tutorial_qgrnn.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_qgrnn.ipynb <tutorial_qgrnn.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
