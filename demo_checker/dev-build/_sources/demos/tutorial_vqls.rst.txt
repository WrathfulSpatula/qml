
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_vqls.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_vqls.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_vqls.py:


.. _vqls:

Variational Quantum Linear Solver
====================================

.. meta::
    :property="og:description": Implementing the variational
        quantum linear solver to solve a system of linear equation with a quantum device.
    :property="og:image": https://pennylane.ai/qml/_images/vqls_zoom.png

.. related::

    tutorial_coherent_vqls Coherent Variational Quantum Linear Solver

*Author: Andrea Mari â€” Posted: 04 November 2019. Last updated: 20 January 2021.*

In this tutorial we implement a quantum algorithm known as the *variational quantum linear
solver* (VQLS), originally introduced in
`Bravo-Prieto et al. (2019) <https://arxiv.org/abs/1909.05820>`_.

.. figure:: ../demonstrations/vqls/vqls_circuit.png
    :align: center
    :width: 100%
    :target: javascript:void(0)

Introduction
------------

We first define the problem and the general structure of a VQLS.
As a second step, we consider a particular case and we solve it explicitly with PennyLane.

The problem
^^^^^^^^^^^

We are given a :math:`2^n \times 2^n` matrix :math:`A` which can be expressed as a linear
combination of :math:`L` unitary matrices :math:`A_0, A_1, \dots A_{L-1}`, i.e.,

.. math::

    A = \sum_{l=0}^{L-1} c_l A_l,

where :math:`c_l` are arbitrary complex numbers. Importantly, we assume that each of the
unitary components :math:`A_l` can be efficiently implemented with a quantum circuit
acting on :math:`n` qubits.

We are also given a normalized complex vector in the physical form of a quantum
state :math:`|b\rangle`, which can be generated by a unitary operation :math:`U`
applied to the ground state of :math:`n` qubits. , i.e.,

.. math::

    |b\rangle = U |0\rangle,

where again we assume that :math:`U` can be efficiently implemented with a quantum circuit.

The problem that we aim to solve is that of preparing a quantum state :math:`|x\rangle`, such that
:math:`A |x\rangle` is proportional to :math:`|b\rangle` or, equivalently, such that

.. math::

    |\Psi\rangle :=  \frac{A |x\rangle}{\sqrt{\langle x |A^\dagger A |x\rangle}} \approx |b\rangle.


Variational quantum linear solver
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The approach used in a VQLS is to approximate the solution :math:`|x\rangle` with a variational quantum
circuit, i.e., a unitary circuit :math:`V` depending on a finite number of classical real parameters
:math:`w = (w_0, w_1, \dots)`:

.. math::

    |x \rangle = V(w) |0\rangle.

The parameters should be optimized in order to maximize the overlap between the quantum states
:math:`|\Psi\rangle` and :math:`|b\rangle`. This suggests to define the following cost function:

.. math::

    C_G = 1- |\langle b | \Psi \rangle|^2,

such that its minimization with respect to the variational parameters should lead towards the problem solution.

Now we discuss two alternative methods which could be used to experimentally solve the minimization problem.

First method
>>>>>>>>>>>>>

Let us write :math:`C_G` more explicitly:

.. math::

    C_G = 1- \frac{ \sum_{l, l'}  c_l c_{l'}^* \langle 0|  V^\dagger A_{l'}^\dagger U \color{blue}{|0\rangle \langle 0|} U^\dagger A_l  V |0\rangle}
    {\sum_{l,l'} c_l c_{l'}^* \langle 0| V^\dagger A_{l'}^\dagger A_l V |0\rangle} .

All expectation values of the previous expression could be estimated with a
`Hadamard test <https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)>`_,
which is a standard quantum computation technique. This method however might be experimentally challenging since it requires us to apply
all the unitaries (:math:`U^\dagger, A_l` and :math:`V`) in a controlled way,
i.e., conditioned on the state of an ancillary qubit. A possible workaround for estimating the same expectation values in a simpler
way has been proposed in Ref. [1], but will not be considered here.

Second method
>>>>>>>>>>>>>

The second method, which is the one used in this tutorial, is to minimize a "local" version of the cost function which is easier to
measure and, at the same time, leads to the same optimal solution.
This local cost function, originally proposed in Ref. [1], can be obtained by replacing the blue-colored projector
:math:`\color{blue}{|0\rangle\langle 0|}` in the previous expression with the following positive operator:

.. math::

     \color{blue}{P} =  \frac{1}{2} + \frac{1}{2n}\sum_{j=0}^{n-1} Z_j,

where :math:`Z_j` is the Pauli :math:`Z` operator locally applied to the :math:`j\rm{th}` qubit. This gives a new cost function:

.. math::

    C_L = 1- \frac{ \sum_{l, l'}  c_l c_{l'}^* \langle 0|  V^\dagger A_{l'}^\dagger U \color{blue}{P} U^\dagger A_l  V |0\rangle}
    {\sum_{l,l'} c_l c_{l'}^* \langle 0| V^\dagger A_{l'}^\dagger A_l V |0\rangle},

which, as shown in Ref. [1], satisfies

.. math::

   C_G \rightarrow 0   \Leftrightarrow C_L \rightarrow 0,

and so we can solve our problem by minimizing :math:`C_L` instead of :math:`C_G`.

Substituting the definition of :math:`P` into the expression for :math:`C_L` we get:

.. math::

    C_L
    &=& \frac{1}{2} - \frac{1}{2n} \frac{ \sum_{j=0}^{n-1} \sum_{l, l'}  c_l c_{l'}^* \langle 0|  V^\dagger A_{l'}^\dagger U Z_j U^\dagger A_l  V |0\rangle}
    {\sum_{l,l'} c_l c_{l'}^* \langle 0| V^\dagger A_{l'}^\dagger A_l V |0\rangle} \\
    &&\\
    &=& \frac{1}{2} - \frac{1}{2n} \frac{ \sum_{j=0}^{n-1} \sum_{l, l'}  c_l c_{l'}^* \mu_{l,l',j}}
    {\sum_{l,l'} c_l c_{l'}^* \mu_{l,l',-1}},

which can be computed whenever we are able to measure the following coefficients

.. math::
    \mu_{l, l', j} = \langle 0|  V^\dagger A_{l'}^\dagger U Z_j U^\dagger A_l  V |0\rangle,

where we used the convention that if :math:`j=-1`,  :math:`Z_{-1}` is replaced with the identity.

Also in this case the complex coefficients :math:`\mu_{l, l', j}` can be experimentally measured with a Hadamard test.
The corresponding quantum circuit is shown in the image at the top of this tutorial.
Compared with the previous method, the main advantage of this approach is that only the unitary operations
:math:`A_l, A_l^\dagger` and :math:`Z_j` need to be controlled by an external ancillary qubit,
while :math:`V, V^\dagger, U` and :math:`U^\dagger` can be directly applied to the system.
This is particularly convenient whenever :math:`V` has a complex structure, e.g., if it is composed of
many variational layers.

A simple example
^^^^^^^^^^^^^^^^

In this tutorial we consider the following simple example based on a system of 3 qubits (plus an ancilla),
which is very similar to the one experimentally tested in Ref. [1]:

.. math::
        \begin{align}
        A  &=  c_0 A_0 + c_1 A_1 + c_2 A_2 = \mathbb{I} + 0.2 X_0 Z_1 + 0.2 X_0, \\
        \\
        |b\rangle &= U |0 \rangle = H_0  H_1  H_2 |0\rangle,
        \end{align}

where :math:`Z_j, X_j, H_j` represent the Pauli :math:`Z`, Pauli :math:`X` and Hadamard gates applied to the qubit with index :math:`j`.

This problem is computationally quite easy since a single layer of local rotations is enough to generate the
solution state, i.e., we can use the following simple ansatz:

.. math::
        |x\rangle = V(w) |0\rangle = \Big [  R_y(w_0) \otimes  R_y(w_1) \otimes  R_y(w_2) \Big ]  H_0  H_1  H_2 |0\rangle.


In the code presented below we solve this particular problem by minimizing the local cost function :math:`C_L`.
Eventually we will compare the quantum solution with the classical one.

General setup
------------------------
This Python code requires *PennyLane* and the plotting library *matplotlib*.

.. GENERATED FROM PYTHON SOURCE LINES 186-194

.. code-block:: default


    # Pennylane



    # Plotting









.. GENERATED FROM PYTHON SOURCE LINES 195-197

Setting of the main hyper-parameters of the model
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 209-211

Circuits of the quantum linear problem
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 213-217

We now define the unitary operations associated to the simple example
presented in the introduction.
Since we want to implement a Hadamard test, we need the unitary operations
:math:`A_j` to be controlled by the state of an ancillary qubit.

.. GENERATED FROM PYTHON SOURCE LINES 217-240

.. code-block:: default


    # Coefficients of the linear combination A = c_0 A_0 + c_1 A_1 ...




























.. GENERATED FROM PYTHON SOURCE LINES 241-255

Variational quantum circuit
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

What follows is the variational quantum circuit that should generate the solution
state :math:`|x\rangle= V(w)|0\rangle`.

The first layer of the circuit is a product of Hadamard gates preparing a
balanced superposition of all basis states.

After that, we apply a very simple variational ansatz
which is just a single layer of qubit rotations
:math:`R_y(w_0) \otimes  R_y(w_1) \otimes  R_y(w_2)`.
For solving more complex problems, we suggest to use more expressive circuits as,
e.g., the PennyLane :func:`~.StronglyEntanglingLayers` template.

.. GENERATED FROM PYTHON SOURCE LINES 269-280

Hadamard test
--------------

We first initialize a PennyLane device with the ``default.qubit`` backend.

As a second step, we define a PennyLane ``QNode`` representing a model of the actual quantum computation.

The circuit is based on the
`Hadamard test <https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)>`_
and will be used to estimate the coefficients :math:`\mu_{l,l',j}` defined in the introduction.
A graphical representation of this circuit is shown at the top of this tutorial.

.. GENERATED FROM PYTHON SOURCE LINES 323-326

To get the real and imaginary parts of :math:`\mu_{l,l',j}`, one needs to run the previous
quantum circuit with and without a phase-shift of the ancillary qubit. This is automatically
done by the following function.

.. GENERATED FROM PYTHON SOURCE LINES 338-342

Local cost function
------------------------------------

Let us first define a function for estimating :math:`\langle x| A^\dagger A|x\rangle`.

.. GENERATED FROM PYTHON SOURCE LINES 356-359

We can finally define the cost function of our minimization problem.
We use the analytical expression of :math:`C_L` in terms of the
coefficients :math:`\mu_{l,l',j}` given in the introduction.

.. GENERATED FROM PYTHON SOURCE LINES 377-381

Variational optimization
-----------------------------

We first initialize the variational weights with random parameters (with a fixed seed).

.. GENERATED FROM PYTHON SOURCE LINES 386-387

To minimize the cost function we use the gradient-descent optimizer.

.. GENERATED FROM PYTHON SOURCE LINES 391-392

We are ready to perform the optimization loop.

.. GENERATED FROM PYTHON SOURCE LINES 401-405

We plot the cost function with respect to the optimization steps.
We remark that this is not an abstract mathematical quantity
since it also represents a bound for the error between the generated state
and the exact solution of the problem.

.. GENERATED FROM PYTHON SOURCE LINES 413-419

Comparison of quantum and classical results
-------------------------------------------

Since the specific problem considered in this tutorial has a small size, we can also
solve it in a classical way and then compare the results with our quantum solution.


.. GENERATED FROM PYTHON SOURCE LINES 421-425

Classical algorithm
^^^^^^^^^^^^^^^^^^^
To solve the problem in a classical way, we use the explicit matrix representation in
terms of numerical NumPy arrays.

.. GENERATED FROM PYTHON SOURCE LINES 438-439

We can print the explicit values of :math:`A` and :math:`b`:

.. GENERATED FROM PYTHON SOURCE LINES 445-446

The solution can be computed via a matrix inversion:

.. GENERATED FROM PYTHON SOURCE LINES 451-453

Finally, in order to compare x with the quantum state :math:`|x\rangle`, we normalize
and square its elements.

.. GENERATED FROM PYTHON SOURCE LINES 456-458

Preparation of the quantum solution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 461-467

Given the variational weights ``w`` that we have previously optimized,
we can generate the quantum state :math:`|x\rangle`. By measuring :math:`|x\rangle`
in the computational basis we can estimate the probability of each basis state.

For this task, we initialize a new PennyLane device and define the associated
*qnode* circuit.

.. GENERATED FROM PYTHON SOURCE LINES 483-485

To estimate the probability distribution over the basis states we first take ``n_shots``
samples and then compute the relative frequency of each outcome.

.. GENERATED FROM PYTHON SOURCE LINES 485-494

.. code-block:: default




    # convert the raw samples (bit strings) into integers and count them












.. GENERATED FROM PYTHON SOURCE LINES 495-499

Comparison
^^^^^^^^^^

Let us print the classical result.

.. GENERATED FROM PYTHON SOURCE LINES 502-503

The previous probabilities should match the following quantum state probabilities.

.. GENERATED FROM PYTHON SOURCE LINES 506-507

Let us graphically visualize both distributions.

.. GENERATED FROM PYTHON SOURCE LINES 523-533

References
----------

1. Carlos Bravo-Prieto, Ryan LaRose, Marco Cerezo, Yigit Subasi, Lukasz Cincio, Patrick J. Coles.
   "Variational Quantum Linear Solver: A Hybrid Algorithm for Linear Systems."
   `arXiv:1909.05820 <https://arxiv.org/abs/1909.05820>`__, 2019.


About the author
----------------
.. include:: ../_static/authors/andrea_mari.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.001 seconds)


.. _sphx_glr_download_demos_tutorial_vqls.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_vqls.py <tutorial_vqls.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_vqls.ipynb <tutorial_vqls.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
