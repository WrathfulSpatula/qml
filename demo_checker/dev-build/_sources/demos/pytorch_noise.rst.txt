
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/pytorch_noise.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_demos_pytorch_noise.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_pytorch_noise.py:


.. _pytorch_noise:

PyTorch and noisy devices
=========================

.. meta::
    :property="og:description": Extend PyTorch with real quantum computing power,
        by using it to optimize a noisy quantum hardware device.
    :property="og:image": https://pennylane.ai/qml/_images/bloch.gif

.. related::

   tutorial_noisy_circuit_optimization Optimizing noisy circuits with Cirq

*Author: Josh Izaac â€” Posted: 11 October 2019. Last updated: 9 November 2022.*

Let's revisit the original :ref:`qubit rotation <qubit_rotation>` tutorial, but instead of
using the default NumPy/autograd QNode interface, we'll use the :doc:`introduction/interfaces/torch`.
We'll also replace the ``default.qubit`` device with a noisy ``rigetti.qvm``
device, to see how the optimization responds to noisy qubits. At the end of the
demonstration, we will also show a way of how Rigetti's QPU can be used via
Amazon Braket.

To follow along with this tutorial on your own computer, you will require the
following dependencies:

* The `Rigetti SDK <https://qcs.rigetti.com/sdk-downloads>`_, which contains the quantum virtual
  machine (QVM) and quilc quantum compiler. Once installed, the QVM and quilc can be
  started by running the commands ``quilc -S`` and ``qvm -S`` in separate terminal windows.

* `PennyLane-Rigetti plugin <https://docs.pennylane.ai/projects/rigetti/en/latest/>`_, in order
  to access the QVM as a PennyLane device. This can be installed via pip:

  .. code-block:: bash

      pip install pennylane-rigetti

* `PennyLane-Braket plugin <https://amazon-braket-pennylane-plugin-python.readthedocs.io/en/latest/>`_, in order
  to access the Rigetti QPU as a PennyLane device. This can be installed via
  pip:

  .. code-block:: bash

      pip install amazon-braket-pennylane-plugin

* `PyTorch <https://pytorch.org/get-started/locally/>`_, in order to access the PyTorch
  QNode interface. Follow the link for instructions on the best way to install PyTorch
  for your system.

Setting up the device
---------------------

Once the dependencies above are installed, let's begin importing the required packages
and setting up our quantum device.

To start with, we import PennyLane, and, as we are using the PyTorch interface,
PyTorch as well:

.. GENERATED FROM PYTHON SOURCE LINES 66-71

Note that we do not need to import the wrapped version of NumPy provided by PennyLane,
as we are not using the default QNode NumPy interface. If NumPy is needed, it is fine to
import vanilla NumPy for use with PyTorch and TensorFlow.

Next, we will create our device:

.. GENERATED FROM PYTHON SOURCE LINES 75-78

Here, we create a noisy two-qubit system, simulated via the QVM. If we wish, we could
also build the model on a physical device, such as the ``Aspen-M-2`` QPU which
can be accessed through Amazon Braket (more details on that will follow).

.. GENERATED FROM PYTHON SOURCE LINES 81-88

Constructing the QNode
----------------------

Now that we have initialized the device, we can construct our quantum node. Like the
other tutorials, we use the :mod:`~.pennylane.qnode` decorator to convert
our quantum function (encoded by the circuit above) into a quantum node
running on the QVM.

.. GENERATED FROM PYTHON SOURCE LINES 98-103

To make the QNode 'PyTorch aware', we need to specify that the QNode interfaces
with PyTorch. This is done by passing the ``interface='torch'`` keyword argument.

As a result, this QNode will be set up to accept and return PyTorch tensors, and will
also automatically calculate any analytic gradients when PyTorch performs backpropagation.

.. GENERATED FROM PYTHON SOURCE LINES 106-116

Optimization
------------

We can now create our optimization cost function. To introduce some additional
complexity into the system, rather than simply training the variational circuit
to 'flip a qubit' from state :math:`\left|0\right\rangle` to state :math:`\left|1\right\rangle`, let's also
modify the target state every 100 steps. For example, for the first 100 steps,
the target state will be :math:`\left|1\right\rangle`; this will then change to :math:`\left|0\right\rangle`
for steps 100 and 200, before changing back to state :math:`\left|1\right\rangle` for steps 200
to 300, and so on.

.. GENERATED FROM PYTHON SOURCE LINES 124-127

Now that the cost function is defined, we can begin the PyTorch optimization.
We create two variables, representing the two free parameters of the variational
circuit, and initialize an Adam optimizer:

.. GENERATED FROM PYTHON SOURCE LINES 133-138

As we are using the PyTorch interface, we must use PyTorch optimizers,
*not* the built-in optimizers provided by PennyLane. The built-in optimizers
only apply to the default NumPy/autograd interface.

Optimizing the system for 400 steps:

.. GENERATED FROM PYTHON SOURCE LINES 146-148

We can now check the final values of the parameters, as well as the final
circuit output and cost function:

.. GENERATED FROM PYTHON SOURCE LINES 155-165

.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

   tensor(-0.7055, requires_grad=True)
   tensor(6.1330, requires_grad=True)
   tensor(0.9551, dtype=torch.float64, grad_fn=<SqueezeBackward0>)
   tensor(3.7162, dtype=torch.float64, grad_fn=<PowBackward0>)

.. GENERATED FROM PYTHON SOURCE LINES 168-179

As the cost function is step-dependent, this does not provide enough detail to
determine if the optimization was successful; instead, let's plot the output
state of the circuit over time on a Bloch sphere:

.. figure:: ../demonstrations/pytorch_noise/bloch.gif
    :align: center
    :target: javascript:void(0);

Here, the red x is the target state of the variational circuit, and the arrow is
the variational circuit output state. As the target state changes, the circuit
learns to produce the new target state!

.. GENERATED FROM PYTHON SOURCE LINES 182-193

Hybrid GPU-QPU optimization
---------------------------

As PyTorch natively supports GPU-accelerated classical processing, and Amazon
Braket provides quantum hardware access in the form of QPUs, we can run the above code 
as a hybrid GPU-QPU optimization with very little modification.

Note that to run the following script, you will need access to Rigetti's QPU.
To connect to a QPU, we can use Amazon Braket. For a dedicated demonstration
on using Amazon Braket, see our tutorial on
`Computing gradients in parallel with Amazon Braket <https://pennylane.ai/qml/demos/braket-parallel-gradients.html>`_.

.. GENERATED FROM PYTHON SOURCE LINES 193-237

.. code-block:: default



















    # Note: swap dev to qpu here to use the QPU
    # Warning: check the pricing of Aspen-M-2 on Braket to make
    # sure you are aware of the costs associated with running the
    # optimization below.























.. GENERATED FROM PYTHON SOURCE LINES 238-248

When using a classical interface that supports GPUs, the QNode will automatically
copy any tensor arguments to the CPU, before applying them on the specified quantum
device. Once done, it will return a tensor containing the QNode result, and
automatically copy it back to the GPU for any further classical processing.

.. note:: For more details on the PyTorch interface, see :doc:`introduction/interfaces/torch`.


About the author
----------------
.. include:: ../_static/authors/josh_izaac.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.000 seconds)


.. _sphx_glr_download_demos_pytorch_noise.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: pytorch_noise.py <pytorch_noise.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: pytorch_noise.ipynb <pytorch_noise.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
