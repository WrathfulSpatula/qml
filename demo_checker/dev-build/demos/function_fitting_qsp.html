
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Learn how to create polynomial approximations to functions using Quantum Signal Processing (QSP)." property="og:description" />
<meta content="https://pennylane.ai/qml/demonstrations/function_fitting_qsp/cover.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Function Fitting using Quantum Signal Processing &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/function_fitting_qsp.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Learn how to create polynomial approximations to functions using Quantum Signal Processing (QSP)." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Function Fitting using Quantum Signal Processing &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/function_fitting_qsp.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Generalization in QML from few training data" href="tutorial_learning_few_data.html" />
    <link rel="prev" title="Machine learning for quantum many-body problems" href="tutorial_ml_classical_shadows.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_learning_few_data.html" title="Generalization in QML from few training data"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_ml_classical_shadows.html" title="Machine learning for quantum many-body problems"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_qml.html" accesskey="U">Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Function Fitting using Quantum Signal Processing</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#sphx-glr-download-demos-function-fitting-qsp-py"><span class="std std-ref">Go to the end</span></a>
to download the full example code</p>
</div>
<span class="target" id="sphx-glr-demos-function-fitting-qsp-py"></span><div class="sphx-glr-example-title section" id="function-fitting-using-quantum-signal-processing">
<h1>Function Fitting using Quantum Signal Processing<a class="headerlink" href="#function-fitting-using-quantum-signal-processing" title="Permalink to this headline">¶</a></h1>
<p><em>Author: Jay Soni — Posted: 24 May 2022. Last updated: 17 April 2023.</em></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This demo is inspired by the paper <a class="reference external" href="https://arxiv.org/abs/2105.02859">‘A Grand Unification of Quantum
Algorithms’</a>. This
paper is centered around the Quantum Singular Value Transform (QSVT)
protocol and how it provides a single framework to generalize some of
the most famous quantum algorithms like Shor’s factoring algorithm, Grover search,
and more.</p>
<p>The QSVT is a method to apply polynomial transformations to the singular
values of <em>any matrix</em>. This is powerful
because from polynomial transformations we can generate arbitrary function
transformations using Taylor approximations. The QSVT protocol is an
extension of the more constrained Quantum Signal Processing (QSP)
protocol which presents a method for polynomial transformation of matrix
entries in a single-qubit unitary operator. The QSVT protocol is sophisticated,
but the idea at its core
is quite simple. By studying QSP, we get a relatively simpler path to explore
this idea at the foundation of QSVT.</p>
<p>In this demo, we explore the QSP protocol and how it can be used
for curve fitting. We show how you can fit polynomials, as illustrated in
the animation below.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/trained_poly.gif"><img alt="../_images/trained_poly.gif" src="../_images/trained_poly.gif" style="width: 50%;" /></a>
</div>
<p>This is a powerful tool that will ultimately allow us
to approximate any function on the interval <span class="math notranslate nohighlight">\([-1, 1]\)</span> that
satisfies certain constraints. Before we can dive into function fitting,
let’s develop some intuition. Consider the following single-qubit operator
parameterized by <span class="math notranslate nohighlight">\(a \in [-1, 1]\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{W}(a) = \begin{bmatrix} a &amp; i\sqrt{1 - a^{2}} \\ i\sqrt{1 - a^{2}} &amp; a \end{bmatrix}.\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\hat{W}(a)\)</span> is called the <em>signal rotation operator</em> (SRO). Using
this operator, we can construct another operator which we call
<em>signal processing operator</em> (SPO),</p>
<div class="math notranslate nohighlight">
\[\hat{U}_{sp} = \hat{R}_{z}(\phi_{0}) \prod_{k=1}^{d} \hat{W}(a) \hat{R}_{z}(\phi_{k}).\]</div>
<p>The SPO is parameterized by a vector
<span class="math notranslate nohighlight">\(\vec{\phi} \in \mathbb{R}^{d+1}\)</span>, where <span class="math notranslate nohighlight">\(d\)</span> is a free
parameter which represents the number of repeated applications of
<span class="math notranslate nohighlight">\(\hat{W}(a)\)</span>.</p>
<p>The SPO <span class="math notranslate nohighlight">\(\hat{U}_{sp}\)</span> alternates between applying the SRO <span class="math notranslate nohighlight">\(\hat{W}(a)\)</span>
and parameterized rotations around the z-axis. Let’s see what happens when we try to compute the
expectation value <span class="math notranslate nohighlight">\(\langle 0|\hat{U}_{sp}|0\rangle\)</span> for the particular
case where <span class="math notranslate nohighlight">\(d = 2\)</span> and <span class="math notranslate nohighlight">\(\vec{\phi} = (0, 0, 0)\)</span> :</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
\langle 0 |\hat{U}_{sp}|0\rangle &amp;= \langle 0 | \ \hat{R}_{z}(0) \prod_{k=1}^{2} \hat{W}(a) \hat{R}_{z}(0) \ |0\rangle \\
\langle 0 |\hat{U}_{sp}|0\rangle &amp;= \langle 0 | \hat{W}(a)^{2} |0\rangle \\
\end{align*}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\langle 0 |\hat{U}_{sp}|0\rangle = \langle 0 | \begin{bmatrix} a &amp; i\sqrt{1 - a^{2}} \\ i\sqrt{1 - a^{2}} &amp; a \end{bmatrix} \ \circ \ \begin{bmatrix} a &amp; i\sqrt{1 - a^{2}} \\ i\sqrt{1 - a^{2}} &amp; a \end{bmatrix} |0\rangle\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\langle 0|\hat{U}_{sp}|0\rangle = \langle 0| \begin{bmatrix} 2a^{2} - 1 &amp; 2ai\sqrt{1 - a^{2}} \\ 2ai\sqrt{1 - a^{2}} &amp; 2a^{2} - 1 \end{bmatrix} |0\rangle\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\langle 0|\hat{U}_{sp}|0\rangle = 2a^{2} - 1\]</div>
<p>Notice that this quantity is a polynomial in <span class="math notranslate nohighlight">\(a\)</span>. Equivalently,
suppose we wanted to create a map <span class="math notranslate nohighlight">\(S: a \to 2a^2 - 1\)</span>.
This expectation value would give us the means to perform such a mapping.
This may seem oddly specific at first, but it turns out that
this process can be generalized for generating a mapping
<span class="math notranslate nohighlight">\(S: a \to \text{poly}(a)\)</span>. The following theorem shows us how:</p>
<div class="section" id="theorem-quantum-signal-processing">
<h3>Theorem: Quantum Signal Processing<a class="headerlink" href="#theorem-quantum-signal-processing" title="Permalink to this headline">¶</a></h3>
<p>Given a vector <span class="math notranslate nohighlight">\(\vec{\phi} \in \mathbb{R}^{d+1}\)</span>, there exist
complex polynomials <span class="math notranslate nohighlight">\(P(a)\)</span> and <span class="math notranslate nohighlight">\(Q(a)\)</span> such that the SPO,
<span class="math notranslate nohighlight">\(\hat{U}_{sp}\)</span>, can be expressed in matrix form as:</p>
<div class="math notranslate nohighlight">
\[\hat{U}_{sp} = \hat{R}_{z}(\phi_{0}) \prod_{k=1}^{d} \hat{W}(a) \hat{R}_{z}(\phi_{k}),\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{U}_{sp} = \begin{bmatrix} P(a) &amp; iQ(a)\sqrt{1 - a^{2}} \\ iQ^{*}(a)\sqrt{1 - a^{2}} &amp; P^{*}(a) \end{bmatrix},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(a \in [-1, 1]\)</span> and the polynomials <span class="math notranslate nohighlight">\(P(a)\)</span>,
<span class="math notranslate nohighlight">\(Q(a)\)</span> satisfy the following constraints:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(deg(P) \leq d \ \)</span> and <span class="math notranslate nohighlight">\(deg(Q) \leq d - 1\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(P\)</span> has parity <span class="math notranslate nohighlight">\(d\)</span> mod 2 and <span class="math notranslate nohighlight">\(Q\)</span> has parity,
<span class="math notranslate nohighlight">\(d - 1\)</span> mod 2</p></li>
<li><p><span class="math notranslate nohighlight">\(|P|^{2} + (1 - a^{2})|Q|^{2} = 1\)</span>.</p></li>
</ul>
<p>The third condition is actually quite restrictive because if we substitute <span class="math notranslate nohighlight">\(a = \pm 1\)</span>,
we get the result <span class="math notranslate nohighlight">\(|P^{2}(\pm 1)| = 1\)</span>. Thus it restricts the polynomial to be
pinned to <span class="math notranslate nohighlight">\(\pm 1\)</span> at the end points of the domain, <span class="math notranslate nohighlight">\(a = \pm 1\)</span>. This condition
can be relaxed to <span class="math notranslate nohighlight">\(|P^{2}(a)| \leq 1\)</span> by expressing the signal processing operator
in the Hadamard basis, i.e., <span class="math notranslate nohighlight">\(\langle + |\hat{U}_{sp}(\vec{\phi};a)|+\rangle\)</span>). This is equivalent to
redefining <span class="math notranslate nohighlight">\(P(a)\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[P^{'}(a) = \text{Re}(P(a)) + i\text{Re}(Q(a))\sqrt{1 - a^{2}}\]</div>
<p><em>This is the convention we follow in this demo.</em></p>
</div>
</div>
<div class="section" id="let-s-plot-some-polynomials">
<h2>Let’s Plot some Polynomials<a class="headerlink" href="#let-s-plot-some-polynomials" title="Permalink to this headline">¶</a></h2>
<p>Now we put this theorem to the test! In this section we construct
the SRO <span class="math notranslate nohighlight">\(\hat{W}(a)\)</span>, and then use PennyLane to define the SPO.
To test the theorem we will randomly generate parameters
<span class="math notranslate nohighlight">\(\vec{\phi}\)</span> and plot the expectation value
<span class="math notranslate nohighlight">\(\langle + |\hat{U}_{sp}(\vec{\phi};a)|+\rangle\)</span> for
<span class="math notranslate nohighlight">\(a \in [-1, 1]\)</span>.</p>
<p>Next, we introduce a function called <code class="docutils literal notranslate"><span class="pre">rotation_mat(a)</span></code>,
which will construct the SRO matrix. We can also make a helper function
(<code class="docutils literal notranslate"><span class="pre">generate_many_sro(a_vals)</span></code>) which, given an array of possible values
for ‘<span class="math notranslate nohighlight">\(a\)</span>’, will generate an array of <span class="math notranslate nohighlight">\(\hat{W}(a)\)</span> associated
with each element. We use Pytorch to construct this array as it will later
be used as input when training our function fitting model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>


<span class="k">def</span> <span class="nf">rotation_mat</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a fixed value &#39;a&#39;, compute the signal rotation matrix W(a).</span>
<span class="sd">    (requires -1 &lt;= &#39;a&#39; &lt;= 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diag</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">off_diag</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>
    <span class="n">W</span> <span class="o">=</span> <span class="p">[[</span><span class="n">diag</span><span class="p">,</span> <span class="n">off_diag</span><span class="p">],</span> <span class="p">[</span><span class="n">off_diag</span><span class="p">,</span> <span class="n">diag</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">W</span>


<span class="k">def</span> <span class="nf">generate_many_sro</span><span class="p">(</span><span class="n">a_vals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a tensor of possible &#39;a&#39; vals, return a tensor of W(a)&quot;&quot;&quot;</span>
    <span class="n">w_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">a_vals</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">rotation_mat</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">w_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">w_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Now having access to the matrix elements of the SRO, we can leverage
PennyLane to define a quantum function that will compute the SPO.
Recall we are measuring in the Hadamard basis to
relax the third condition of the theorem. We
accomplish this by sandwiching the SPO between two Hadamard gates to
account for this change of basis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>


<span class="k">def</span> <span class="nf">QSP_circ</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This circuit applies the SPO. The components in the matrix</span>
<span class="sd">    representation of the final unitary are polynomials!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># set initial state |+&gt;</span>
    <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">phi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># final rotation</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># change of basis |+&gt; , |-&gt;</span>
    <span class="k">return</span>
</pre></div>
</div>
<p>Finally, we randomly generate the vector <span class="math notranslate nohighlight">\(\vec{\phi}\)</span> and plot the
expectation value <span class="math notranslate nohighlight">\(\langle +|\hat{U}_{sp}|+\rangle\)</span> as a function of
<span class="math notranslate nohighlight">\(a\)</span>. In this case we choose <span class="math notranslate nohighlight">\(d = 5\)</span>.
We expect to observe the following:</p>
<ul class="simple">
<li><p>Since <span class="math notranslate nohighlight">\(d\)</span> is odd, we expect all of the
polynomials we plot to have odd symmetry</p></li>
<li><p>Since <span class="math notranslate nohighlight">\(d = 5\)</span>, we expect none of the polynomials will have
terms ~ <span class="math notranslate nohighlight">\(O(a^6)\)</span> or higher</p></li>
<li><p>All of the polynomials are bounded by <span class="math notranslate nohighlight">\(\pm1\)</span></p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">d</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">a_vals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">w_mats</span> <span class="o">=</span> <span class="n">generate_many_sro</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">()</span>
<span class="n">gen</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">444422</span><span class="p">)</span>  <span class="c1"># set random seed for reproducibility</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">gen</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">matrix_func</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.matrix.html#pennylane.matrix" title="pennylane.matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><span class="n">QSP_circ</span><span class="p">)</span>
    <span class="n">y_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">matrix_func</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">w</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_mats</span><span class="p">]</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;poly #</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/random_poly.png"><img alt="../_images/random_poly.png" src="../_images/random_poly.png" style="width: 50%;" /></a>
</div>
<p>Exactly as predicted, all of these conditions are met!</p>
<ul class="simple">
<li><p>All curves have odd symmetry</p></li>
<li><p>Qualitatively, the plots look similar to polynomials of low degree</p></li>
<li><p>Each plot does not exceed <span class="math notranslate nohighlight">\(\pm1\)</span> !</p></li>
</ul>
</div>
<div class="section" id="function-fitting-with-quantum-signal-processing">
<h2>Function Fitting with Quantum Signal Processing<a class="headerlink" href="#function-fitting-with-quantum-signal-processing" title="Permalink to this headline">¶</a></h2>
<p>Another observation we can make about this theorem is the fact that it
holds true in both directions: If we have two polynomials <span class="math notranslate nohighlight">\(P(a)\)</span>
and <span class="math notranslate nohighlight">\(Q(a)\)</span> that satisfy the conditions of the theorem, then there
exists a <span class="math notranslate nohighlight">\(\vec{\phi}\)</span> for which we can construct a signal
processing operator which maps <span class="math notranslate nohighlight">\(a \to P(a)\)</span>.</p>
<p>In this section we try to answer the question:</p>
<p><strong>Can we learn the parameter values of</strong> <span class="math notranslate nohighlight">\(\vec{\phi}\)</span> <strong>to transform
our signal processing operator polynomial to fit a given function?</strong></p>
<p>In order to answer this question, we leverage the power of machine learning.
In this demo we assume you are familiar with some concepts from quantum
machine learning, for a refresher checkout this <a class="reference external" href="https://pennylane.ai/blog/2021/10/how-to-start-learning-quantum-machine-learning/">blog post on QML</a>.
We begin by building a machine learning model using Pytorch. The <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>
method handles the
random initialization of our parameter vector <span class="math notranslate nohighlight">\(\vec{\phi}\)</span>. The
<code class="docutils literal notranslate"><span class="pre">forward()</span></code> method takes an array of signal rotation matrices
<span class="math notranslate nohighlight">\(\hat{W}(a)\)</span> for varying <span class="math notranslate nohighlight">\(a\)</span>, and produces the
predicted <span class="math notranslate nohighlight">\(y\)</span> values.</p>
<p>Next we leverage the PennyLane function <a class="reference external" href="https://pennylane.readthedocs.io/en/stable/code/api/pennylane.matrix.html?highlight=qml%20matrix#pennylane.matrix">qml.matrix()</a>,
which accepts our quantum function (it can also accept quantum tapes and
QNodes) and returns its unitary matrix representation. We are interested
in the real value of the top left entry, this corresponds to
<span class="math notranslate nohighlight">\(P(a)\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">torch_pi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">QSP_Func_Fit</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">num_vals</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given the degree and number of samples, this method randomly</span>
<span class="sd">        initializes the parameter vector (randomness can be set by random_seed)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">random_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">torch_pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">()</span>
            <span class="n">gen</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">torch_pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">gen</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_phi</span> <span class="o">=</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_vals</span> <span class="o">=</span> <span class="n">num_vals</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega_mats</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;PennyLane forward implementation&quot;&quot;&quot;</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">generate_qsp_mat</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.matrix.html#pennylane.matrix" title="pennylane.matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><span class="n">QSP_circ</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">omega_mats</span><span class="p">:</span>
            <span class="n">u_qsp</span> <span class="o">=</span> <span class="n">generate_qsp_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">P_a</span> <span class="o">=</span> <span class="n">u_qsp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Taking the (0,0) entry of the matrix corresponds to &lt;0|U|0&gt;</span>
            <span class="n">y_pred</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_a</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we create a <code class="docutils literal notranslate"><span class="pre">Model_Runner</span></code> class to handle running the
optimization, storing the results, and providing plotting functionality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Model_Runner</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">x_vals</span><span class="p">,</span> <span class="n">process_x_vals</span><span class="p">,</span> <span class="n">y_true</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given a model and a series of model specific arguments, store everything in</span>
<span class="sd">        internal attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="n">degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">num_samples</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_vals</span> <span class="o">=</span> <span class="n">x_vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inp</span> <span class="o">=</span> <span class="n">process_x_vals</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_true</span> <span class="o">=</span> <span class="n">y_true</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">13_02_1967</span><span class="p">,</span> <span class="n">max_shots</span><span class="o">=</span><span class="mi">25000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>  <span class="c1"># easter egg: oddly specific seed?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run the optimization protocol on the model using Mean Square Error as a loss</span>
<span class="sd">        function and using stochastic gradient descent as the optimizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="n">num_vals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">loss_val</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">max_shots</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">loss_val</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inp</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_pred</span>

            <span class="c1"># Compute and print loss</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_pred</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_true</span><span class="p">)</span>
            <span class="n">loss_val</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---- iter: </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">, loss: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">loss_val</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2"> -----&quot;</span><span class="p">)</span>

            <span class="c1"># Perform a backward pass and update weights.</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

            <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">phi</span>

    <span class="k">def</span> <span class="nf">plot_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the results&quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_true</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s2">&quot;--b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;target func&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_pred</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s2">&quot;.g&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;optim params&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_y_pred</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s2">&quot;.r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;init params&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Now that we have a model, lets first attempt to fit a polynomial. We
expect this to perform well when the target polynomial also obeys the
symmetry and degree constraints that our quantum signal processing
polynomial does. To do this, we defined a function <code class="docutils literal notranslate"><span class="pre">custom_poly(x)</span></code>
which implements the target polynomial. In this case, we (arbitrarily)
choose the target polynomial:</p>
<div class="math notranslate nohighlight">
\[y = 4x^{5} - 5x^{3} + x\]</div>
<p>Lets see how well we can fit this polynomial!</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Depending on the initial parameters, training can take
anywhere from 10 - 30 mins</p>
</div>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">d</span> <span class="o">=</span> <span class="mi">9</span>  <span class="c1"># dim(phi) = d + 1,</span>
<span class="n">num_samples</span> <span class="o">=</span> <span class="mi">50</span>


<span class="k">def</span> <span class="nf">custom_poly</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A custom polynomial of degree &lt;= d and parity d % 2&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>


<span class="n">a_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
<span class="n">y_true</span> <span class="o">=</span> <span class="n">custom_poly</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="n">qsp_model_runner</span> <span class="o">=</span> <span class="n">Model_Runner</span><span class="p">(</span><span class="n">QSP_Func_Fit</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">a_vals</span><span class="p">,</span> <span class="n">generate_many_sro</span><span class="p">,</span> <span class="n">y_true</span><span class="p">)</span>

<span class="n">qsp_model_runner</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="n">qsp_model_runner</span><span class="o">.</span><span class="n">plot_result</span><span class="p">()</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>---- iter: 0, loss: 13.5938 -----
---- iter: 1000, loss: 11.8809 -----
---- iter: 2000, loss: 10.229 -----
---- iter: 3000, loss: 8.6693 -----
---- iter: 4000, loss: 7.2557 -----
---- iter: 5000, loss: 6.0084 -----
---- iter: 6000, loss: 4.9197 -----
---- iter: 7000, loss: 3.9801 -----
---- iter: 8000, loss: 3.1857 -----
---- iter: 9000, loss: 2.5312 -----
---- iter: 10000, loss: 2.0045 -----
---- iter: 11000, loss: 1.5873 -----
---- iter: 12000, loss: 1.2594 -----
---- iter: 13000, loss: 1.0021 -----
---- iter: 14000, loss: 0.7997 -----
---- iter: 15000, loss: 0.6397 -----
---- iter: 16000, loss: 0.5127 -----
</pre></div>
</div>
<div class="sphx-glr-script-out figure align-center">
<a class="reference internal image-reference" href="../_images/trained_poly.png"><img alt="../_images/trained_poly.png" src="../_images/trained_poly.png" style="width: 50%;" /></a>
</div>
<p>We were able to fit that polynomial quite well!
Lets try something more challenging: fitting a
non-polynomial function. One thing to keep in mind is the symmetry and
bounds constraints on our polynomials. If our target function does not
satisfy them as well, then we cannot hope to generate a good polynomial
fit, regardless of how long we train for.</p>
<p>A good non-polynomial candidate to fit to, that obeys our constraints,
is the step function. Let’s try it!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="mi">9</span>  <span class="c1"># dim(phi) = d + 1,</span>
<span class="n">num_samples</span> <span class="o">=</span> <span class="mi">50</span>


<span class="k">def</span> <span class="nf">step_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A step function (odd parity) which maps all values &lt;= 0 to -1</span>
<span class="sd">    and all values &gt; 0 to +1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">x_i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span> <span class="k">for</span> <span class="n">x_i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>


<span class="n">a_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
<span class="n">y_true</span> <span class="o">=</span> <span class="n">step_func</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="n">qsp_model_runner</span> <span class="o">=</span> <span class="n">Model_Runner</span><span class="p">(</span><span class="n">QSP_Func_Fit</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">a_vals</span><span class="p">,</span> <span class="n">generate_many_sro</span><span class="p">,</span> <span class="n">y_true</span><span class="p">)</span>

<span class="n">qsp_model_runner</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="n">qsp_model_runner</span><span class="o">.</span><span class="n">plot_result</span><span class="p">()</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>---- iter: 0, loss: 33.8345 -----
---- iter: 1000, loss: 19.0937 -----
---- iter: 2000, loss: 11.6557 -----
---- iter: 3000, loss: 8.2853 -----
---- iter: 4000, loss: 6.6824 -----
---- iter: 5000, loss: 5.8523 -----
---- iter: 6000, loss: 5.3855 -----
---- iter: 7000, loss: 5.1036 -----
---- iter: 8000, loss: 4.9227 -----
---- iter: 9000, loss: 4.8004 -----
---- iter: 10000, loss: 4.7138 -----
---- iter: 11000, loss: 4.6502 -----
---- iter: 12000, loss: 4.6018 -----
---- iter: 13000, loss: 4.5638 -----
---- iter: 14000, loss: 4.5333 -----
---- iter: 15000, loss: 4.5082 -----
---- iter: 16000, loss: 4.4872 -----
---- iter: 17000, loss: 4.4693 -----
---- iter: 18000, loss: 4.4537 -----
---- iter: 19000, loss: 4.4401 -----
---- iter: 20000, loss: 4.4281 -----
---- iter: 21000, loss: 4.4174 -----
---- iter: 22000, loss: 4.4078 -----
---- iter: 23000, loss: 4.3991 -----
---- iter: 24000, loss: 4.3912 -----
---- iter: 25000, loss: 4.3839 -----
</pre></div>
</div>
<div class="sphx-glr-script-out figure align-center">
<a class="reference internal image-reference" href="../_images/trained_step.png"><img alt="../_images/trained_step.png" src="../_images/trained_step.png" style="width: 50%;" /></a>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>In this demo, we explored the Quantum Signal Processing theorem, which
is a method to perform polynomial transformations on the entries of the
SRO <span class="math notranslate nohighlight">\(\hat{W}(a)\)</span>. This polynomial transformation
arises from the repeated application of <span class="math notranslate nohighlight">\(\hat{W}(a)\)</span> and the
parameterized Z-axis rotations <span class="math notranslate nohighlight">\(e^{i \phi \hat{Z}}\)</span>. Note, the
SRO is itself a transformation, in this case a rotation around the
X-axis by <span class="math notranslate nohighlight">\(\theta = -2 \cos^{-1}(a)\)</span>, which rotates our basis.
Thus the underlying principal of quantum signal processing is that we
can generate polynomial transformations through parameterized rotations
along a principal axis followed by change of basis transformations
which re-orients this axis.</p>
<p>This is the same principal at the heart of QSVT. In this case the subspace
in which we apply our parameterized rotations is defined by the singular
vectors, the change of basis transformation takes us between these
subspaces and this allows us to apply polynomial transformations on the
singular values of our matrix of interest.</p>
<p>We also showed that one could use a simple gradient descent model to
train a parameter vector <span class="math notranslate nohighlight">\(\vec{\phi}\)</span> to generate reasonably good
polynomial approximations of arbitrary functions (provided the function
satisfied the same constraints). This isn’t the only way to compute the
optimal values. It turns out there exist <em>efficient</em> algorithms for
explicitly computing the optimal values for <span class="math notranslate nohighlight">\(\vec{\phi}\)</span>
known as “Remez-type exchange algorithms” for analytic function fitting. If
you want to explore other approaches to function fitting, checkout this
<a class="reference external" href="https://pennylane.ai/qml/demos/quantum_neural_net.html">demo</a>
where we use a photonic neural network for function fitting.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/trained_step.gif"><img alt="../_images/trained_step.gif" src="../_images/trained_step.gif" style="width: 50%;" /></a>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>[1]: <em>John M. Martyn, Zane M. Rossi, Andrew K. Tan, Isaac L. Chuang. “A
Grand Unification of Quantum Algorithms”</em>  <a class="reference external" href="https://arxiv.org/abs/2105.02859">PRX Quantum 2,
040203</a><em>, 2021.</em></p>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/jay_soni.png" alt="Jay Soni" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Jay Soni</h4>
        <p class="bio-text__author-description">Jay completed his BSc. in Mathematical Physics from the University of Waterloo and currently works as a Quantum Software Developer at Xanadu. Fun fact, you will often find him sipping on a Tim Horton's IceCapp while he is coding.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-function-fitting-qsp-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/f53bc93b8cf576db7629e7c048dc9168/function_fitting_qsp.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">function_fitting_qsp.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/900a9da09f6bc5d976f925200c8bcd2b/function_fitting_qsp.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">function_fitting_qsp.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/function_fitting_qsp</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Function Fitting using Quantum Signal Processing</a><ul class='current'>
<li class='current'><a class="reference internal" href="#introduction">Introduction</a><ul class='current'>
<li class='current'><a class="reference internal" href="#theorem-quantum-signal-processing">Theorem: Quantum Signal Processing</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#let-s-plot-some-polynomials">Let’s Plot some Polynomials</a></li>
<li class='current'><a class="reference internal" href="#function-fitting-with-quantum-signal-processing">Function Fitting with Quantum Signal Processing</a></li>
<li class='current'><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/function_fitting_qsp</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_qml.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_learning_few_data.html" title="Generalization in QML from few training data"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_ml_classical_shadows.html" title="Machine learning for quantum many-body problems"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_qml.html" >Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Function Fitting using Quantum Signal Processing</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>