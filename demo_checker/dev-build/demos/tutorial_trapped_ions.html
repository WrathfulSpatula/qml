
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Learn all about trapped ion quantum computers, developed by companies such as IonQ and Honeywell." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/trapped_ions_tn.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Trapped ion quantum computers &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_trapped_ions.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Learn all about trapped ion quantum computers, developed by companies such as IonQ and Honeywell." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Trapped ion quantum computers &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_trapped_ions.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Error mitigation with Mitiq and PennyLane" href="tutorial_error_mitigation.html" />
    <link rel="prev" title="Quantum advantage with Gaussian Boson Sampling" href="gbs.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_error_mitigation.html" title="Error mitigation with Mitiq and PennyLane"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gbs.html" title="Quantum advantage with Gaussian Boson Sampling"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" accesskey="U">Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Trapped ion quantum computers</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-trapped-ions-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="trapped-ion-quantum-computers">
<span id="trapped-ions"></span><span id="sphx-glr-demos-tutorial-trapped-ions-py"></span><h1>Trapped ion quantum computers<a class="headerlink" href="#trapped-ion-quantum-computers" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_pasqal.html", "tutorial_sc_qubits.html", "tutorial_photonics.html"];
    var related_tutorials_titles = ['Quantum computation with neutral atoms', 'Quantum computing with superconducting qubits', 'Photonic quantum computers'];
</script></p>
<p><em>Author: Alvaro Ballon — Posted: 10 November 2021. Last updated: 26 August 2022.</em></p>
<p>The race for quantum advantage is on!
A host of competitors are using different technologies to build a useful quantum
computer. Some common approaches are <a href="#id1"><span class="problematic" id="id2">**</span></a>trapped ions,
<a class="reference internal" href="tutorial_sc_qubits.html"><span class="doc">superconducting qubits</span></a>, and
<a class="reference internal" href="tutorial_photonics.html"><span class="doc">photonics</span></a>, among others. Discussing whether there
is a superior framework leads to a neverending debate. All of them pose
complex technological challenges, which we can only solve through
innovation, inventiveness, hard work, and a bit of luck. It is difficult
to predict whether these problems are solvable in a given timeframe.
More often than not, our predictions have been wrong. Forecasting the winner
of this race is not easy at all!</p>
<p>Here, we introduce <strong>trapped ion quantum
computers</strong>. It is the preferred technology that research groups use at
several universities around the world, and at research companies like
<a class="reference external" href="https://www.honeywell.com/us/en/company/quantum">Honeywell</a> and <a class="reference external" href="https://ionq.com/">IonQ</a>.
In particular, Honeywell has achieved a
<a class="reference internal" href="quantum_volume.html"><span class="doc">quantum volume</span></a>
of 128, the largest in the market! As the name suggests, the
qubits are ions trapped by electric fields and manipulated with lasers.
Trapped ions have relatively long coherence times, which means that the qubits are
long-lived. Moreover, they can easily interact with their neighbours.
Scalability is a challenge, but, as we will see, there are
innovative ways to get around them.</p>
<p>After reading this demo, you will learn how trapped ion quantum computers
prepare, evolve, and measure quantum states. In particular, you will gain
knowledge on how single and multi-qubit gates are implemented and how we can
simulate them using PennyLane. You will also identify the features that
make trapped ion quantum computers an appropriate physical implementation, and where the
technical challenges lie, in terms of <strong>DiVincenzo’s criteria</strong> (see box below).
Finally, you will become familiar with the concepts required to understand recent articles on the topic
and read future papers to keep up-to-date with the most recent developments.</p>
<div class="alert alert-block alert-info docutils container">
<p><strong>Di Vincenzo’s criteria</strong>: In the year 2000, David DiVincenzo proposed a
wishlist for the experimental characteristics of a quantum computer <a class="footnote-reference brackets" href="#divincenzo2000" id="id3">1</a>.
DiVincenzo’s criteria have since become the main guideline for
physicists and engineers building quantum computers:</p>
<p>1. <strong>Well-characterized and scalable qubits</strong>. Many of the quantum systems that
we find in nature are not qubits, so we must find a way to make them behave as such.
Moreover, we need to put many of these systems together.</p>
<p>2. <strong>Qubit initialization</strong>. We must be able to prepare the same state repeatedly within
an acceptable margin of error.</p>
<p>3. <strong>Long coherence times</strong>. Qubits will lose their quantum properties after
interacting with their environment for a while. We would like them to last long
enough so that we can perform quantum operations.</p>
<p>4. <strong>Universal set of gates</strong>. We need to perform arbitrary operations on the
qubits. To do this, we require both single-qubit gates and two-qubit gates.</p>
<p>5. <strong>Measurement of individual qubits</strong>. To read the result of a quantum algorithm,
we must accurately measure the final state of a pre-chosen set of qubits.</p>
</div>
<div class="section" id="how-to-trap-an-ion">
<h2>How to trap an ion<a class="headerlink" href="#how-to-trap-an-ion" title="Permalink to this headline">¶</a></h2>
<p>Why do we use ions, i.e., charged atoms, as qubits? The main reason
is that they can be contained (that is, trapped) in one precise location using electric fields. It is
possible to contain neutral atoms using optical tweezers, but our focus
is on ions, which can be contained using an electromagnetic trap. Ion traps
are rather old technology: their history goes back to 1953 when Wolfgang
Paul proposed his now-called Paul trap <a class="footnote-reference brackets" href="#paul1953" id="id4">2</a>. For this invention, Paul and
Dehmelt were awarded the 1989 Physics Nobel Prize, since it is used to make highly
precise atomic clocks. Current trapped ion quantum computers extensively
use the Paul trap, but Paul won the prize six years before such an
application was proposed <a class="footnote-reference brackets" href="#ciraczoller" id="id5">3</a>!</p>
<p>It is not easy to create electric fields that contain the ion in a tiny
region of space. The ideal configuration of an electric field
—also known as a <em>potential</em>— would look like this:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/confining.png"><img alt="../_images/confining.png" src="../_images/confining.png" style="width: 70%;" /></a>
<div class="legend">
<p>Confining potential</p>
</div>
</div>
<p>The potential should be interpreted as a wall that the ion must climb
over to escape from a physical region. Positively charged ions will always roll
down from regions of high potential to low potential. So if we can
achieve an electric potential like the above, the ion should remain
trapped in the pit. However, using the laws of electrostatics, we can
show that it is impossible to create a confining potential with only
static electric fields. Instead, they produce saddle-shaped potentials:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/saddle_potential.png"><img alt="../_images/saddle_potential.png" src="../_images/saddle_potential.png" style="width: 70%;" /></a>
<div class="legend">
<p>Saddle-shaped potential allowed by electrostatics</p>
</div>
</div>
<p>This potential is problematic since the ion is contained in one
direction but could escape in the perpendicular direction. Therefore,
the solution is to use time-dependent electric fields to allow the
potential wall to move. What would happen, for example, if we rotated
the potential plotted above? We can imagine that if the saddle potential
rotates at a specific frequency, the wall will catch the ion as it tries
to escape in the downhill direction. Explicitly, the electric potential
that we generate is given by <a class="footnote-reference brackets" href="#malinowski" id="id6">4</a></p>
<div class="math notranslate nohighlight">
\[\Phi = \frac{1}{2}\left(u_x x^2 + u_y y^2 + u_z z^2\right) + \frac{1}{2}\left(v_x x^2 + v_y y^2 + v_z z^2\right)\cos(\omega t+\phi).\]</div>
<p>The parameters <span class="math notranslate nohighlight">\(u_i\)</span>, <span class="math notranslate nohighlight">\(v_i\)</span>, and <span class="math notranslate nohighlight">\(\phi\)</span> need to be
adjusted to the charge and mass of the ion and to the potential’s
angular frequency <span class="math notranslate nohighlight">\(\omega\)</span>. We have to tune these
parameters very carefully, since the ion could escape if we do not apply
the right forces at the right time. It takes a lot of care, but this
technique is so old that it is almost perfect by now. Here is what the
rotating potential would look like:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/Rotating.gif"><img alt="../_images/Rotating.gif" src="../_images/Rotating.gif" style="width: 70%;" /></a>
<div class="legend">
<p>A rotating potential with the correct frequency and magnitude
can contain an ion</p>
</div>
</div>
<p>We want to make a quantum computer, so having one qubit cannot be
enough. We would like as many as we can possibly afford! The good news
is that we have the technology to trap many ions and put them close
together in a one-dimensional array, called an ion chain. Why do we need
this particular configuration? To manipulate the qubits, we need the
system of ions to absorb photons. However, shooting a photon at an ion
can cause relative motion between ions. The
proximity between qubits will cause unwanted interactions, which could
modify their state. Happily, there is a solution to this issue: we place
the ions in a sufficiently spaced one-dimensional array and <strong>cool them
all down to the point where their motion in space is quantized</strong>. In
this scenario, photons that would bring the ion to their excited states
will not cause any relative motion. Instead, all ions will recoil
together <a class="footnote-reference brackets" href="#nandc2000" id="id7">5</a>. This phenomenon is called the <strong>Mossbauer effect</strong>. We will
see later that by carefully tuning the laser frequency, we can control
both the excitations of the ions and the motion of the ion chain. This
user-controlled motion is precisely what we need to perform quantum
operations with two qubits.</p>
</div>
<div class="section" id="trapped-ions-as-robust-qubits">
<h2>Trapped ions as robust qubits<a class="headerlink" href="#trapped-ions-as-robust-qubits" title="Permalink to this headline">¶</a></h2>
<p>Now that we know how to trap ions, we would like to use them as qubits.
Would any ion out there work well as a qubit? In fact, only a select few
isotopes will do the trick. The reason is that our qubit basis states
are the ground and excited states of an electron in the atom, and we
need to be able to transition between them using laser light. Therefore,
we would like the atom to have an excited state that is long-lived, and
also one that we may manipulate using frequencies that lasers can
produce. Thanks to semiconductor laser technology, we have a wide range
of frequencies that we can use in the visible and infrared ranges, so
getting the desired frequency is not too much of a problem. The best
ions for our purposes are single-charged ions in Group II of the
periodic table, such as Calcium-40, Beryllium-9, and Barium-138,
commonly used in university laboratories <a class="footnote-reference brackets" href="#bergou2021" id="id8">7</a>. The rare earth Ytterbium-171 is
used by IonQ and Honeywell. These elements have two <em>valence electrons</em>,
but their ionized version only has one. The valence electron is not so
tightly bound to the atom, so it is the one whose state we use to represent a
qubit.</p>
<div class="alert alert-block alert-info docutils container">
<p><strong>Atomic Physics Primer:</strong> Atoms consist of a positively charged nucleus
and negative electrons around them. The electrons inhabit energy
levels, which have a population limit. As the levels fill up, the
electrons occupy higher and higher energy levels. But as long as
there is space, electrons can change energy levels, with a preference
for the lower ones. This can happen spontaneously or due to external
influences.</p>
<p>When the lower energy levels are not occupied, the higher energy levels
are unstable: electrons will prefer to minimize their energy and jump to
a lower level on their own. What happens when an electron jumps from
a high energy level to a lower one? Conservation of energy tells us
that the energy must go somewhere. Indeed, a photon with an energy
equal to the energy lost by the electron is emitted. This energy is
proportional to the frequency (colour) of the photon.</p>
<p>Conversely, we can use laser light to induce the opposite process.
When an electron is in a stable or ground state, we can use lasers
with their frequency set roughly to the difference
in energy levels, or energy gap, between the ground state and an
excited state . If a photon hits an electron, it will go to that
higher energy state. When the light stimulus is removed, the excited
electrons will return to stable states. The time it takes them to do
so depends on the particular excited state they are in since,
sometimes, the laws of physics will make it harder for electrons to
jump back on their own.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/atomic1.png"><img alt="../_images/atomic1.png" src="../_images/atomic1.png" style="width: 60%;" /></a>
<div class="legend">
<p>Photons with an energy equal to the atomic gap drive excitations</p>
</div>
</div>
</div>
<p>Having chosen the ions that will act as our qubits, we need to prepare
them in a stable fiducial state, known as the <strong>ground state</strong> and
denoted by <span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span>. The preparation is done
by a procedure called <strong>optical pumping</strong>. To understand how it works, let us
take Calcium-40 as an example. In this case, the electron has two stable
states with the same energy, but different direction of rotation.
We denote these by <span class="math notranslate nohighlight">\(\left\lvert g_1 \right\rangle\)</span> and
<span class="math notranslate nohighlight">\(\left\lvert g_2\right\rangle\)</span>. We do not know which stable state
the electron is in, and we would like to ensure that the electron is in
the <span class="math notranslate nohighlight">\(\left\lvert g_1\right\rangle\)</span> state. This will be our chosen
fiducial state, so
<span class="math notranslate nohighlight">\(\left\lvert g\right\rangle = \left\lvert g_1\right\rangle\)</span>.
However, quantum mechanics forbids a direct transition between these two
stable states. To get from one state to the other, the electron
would have to change its rotation without giving out any energy, which
is impossible! But we can take a detour: we use circularly polarized
laser light of a particular wavelength (397nm for Calcium-40) to excite
<span class="math notranslate nohighlight">\(\left\lvert g_2\right\rangle\)</span> into a short-lived excited state
<span class="math notranslate nohighlight">\(\left\lvert \textrm{aux}\right\rangle\)</span>. This light does not
stimulate any other transitions in the ion so that an electron in the
ground state <span class="math notranslate nohighlight">\(\left\lvert g_1\right\rangle\)</span> will remain there.
Quantum mechanics tells us that, in a matter of nanoseconds, the excited electron
decays to our desired ground state <span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span>
with probability 1/3, but returns to
<span class="math notranslate nohighlight">\(\left\lvert g_2 \right\rangle\)</span> otherwise. For this reason, we
need to repeat the procedure many times, gradually “pumping” the
electrons in all (or the vast majority of) our ions to the ground state.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/pumping.png"><img alt="../_images/pumping.png" src="../_images/pumping.png" style="width: 60%;" /></a>
<div class="legend">
<p>Optical pumping to prepare the ground state</p>
</div>
</div>
<p>What about the other basis qubit state? It will be a long-lived excited
state, denoted by <span class="math notranslate nohighlight">\(\left\lvert e \right\rangle\)</span>. For the
Calcium-40 ion, this state is a <em>metastable state:</em> a state that
has a sufficiently long lifetime since quantum mechanics restricts, but
does not entirely forbid, transitions to a lower energy level. For
example, the metastable state of Calcium-40 has a half-life of about 1
second. While apparently short, most quantum operations can be performed
on a timescale of micro to milliseconds. The energy difference between the ground and
excited state corresponds to a laser frequency of 729nm, achievable with
an infrared laser. Therefore, we call this an <strong>optical qubit</strong>. An
alternative is to use an ion, such as Calcium-43, that has a <em>hyperfine
structure</em>, which means that the ground and excited states are separated by a very small
energy gap. In this case, the higher energy state has a virtually
infinite lifespan, since it is only slightly different
from the stable ground state. We can use a procedure similar to optical pumping to
transition between these two states, so while coherence times are longer
for these <strong>hyperfine qubits</strong>, gate implementation is more complicated
and needs a lot of precision.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/hyperfine.png"><img alt="../_images/hyperfine.png" src="../_images/hyperfine.png" style="width: 60%;" /></a>
<div class="legend">
<p>Optical vs. hyperfine qubits</p>
</div>
</div>
<p>We have now learned how trapped ions make for very stable qubits that
allow us to implement many quantum operations without decohering too
soon. We have also learned how to prepare these qubits in a stable
ground state. Does this mean that we have already satisfied DiVincezo’s
first, second, and third criteria? We have definitely fulfilled the
second one since optical pumping is a very robust method. However, we
have mainly been focusing on a single qubit and, since we have not
discussed scalability yet, we have not fully satisfied the first
criterion. Introducing more ions will pose additional challenges to
meeting the third criterion. For now, let us focus on how to satisfy
criteria 4 and 5, and we will come back to these issues once we discuss
what happens when we deal with multiple ions.</p>
</div>
<div class="section" id="non-demolition-measurements">
<h2>Non-demolition measurements<a class="headerlink" href="#non-demolition-measurements" title="Permalink to this headline">¶</a></h2>
<p>Let us now discuss the last step in a quantum computation: measuring the
qubits. Since it takes quite a bit of work to trap an ion, it would be
ideal if we could measure the state of our qubits without it escaping
from the trap. We definitely do not want to trap ions again after performing
one measurement. Moreover, we want measurements that can be repeated
on the same ions and yield consistent results. These are called <strong>non-demolition
measurements</strong>, and they are easy enough to carry out for trapped ions.</p>
<p>The measurement method uses a similar principle to that of optical
pumping. Once again, and continuing with the Calcium-40 example, we make
use of the auxiliary state. This time, we shine a laser light wavelength
of 397 nm that drives the transition from
<span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span> to the auxiliary state
<span class="math notranslate nohighlight">\(\left\lvert \textrm{aux} \right\rangle\)</span>. The transition is
short-lived; it will quickly go back to <span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span>,
emitting a photon of the same wavelength. The state
<span class="math notranslate nohighlight">\(\left\lvert e \right\rangle\)</span> is not affected. Therefore,
we will measure <span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span> if
we see the ion glowing: it continuously emits light at a wavelength of
397 nm. Conversely, if the ion is dark, we will have measured the result
corresponding to state <span class="math notranslate nohighlight">\(\left\lvert e\right\rangle\)</span>. To see the
photons emitted by the ions, we need to collect the photons using a lens
and a photomultiplier, a device that transforms weak light signals into
electric currents.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/measurement.png"><img alt="../_images/measurement.png" src="../_images/measurement.png" style="width: 60%;" /></a>
<div class="legend">
<p>Non-demolition measurement of ion states</p>
</div>
</div>
<p>Have we fully satisfied the fifth criterion? Via a careful experimental
arrangement, we can detect the emission of photons of each atom
individually, so we are on the right track. But in reality, there is
also some uncertainty in the measurement. In many quantum computing
algorithms, we only measure the state of a pre-chosen set of ions called
the <strong>ancilla</strong>. If these ions emit light, they can accidentally excite
other ions on the chain, causing decoherence. A way to avoid this source
of uncertainty is to use two species of ions: one for the ancilla and
one for the qubits that are not measured, or <strong>logical qubits</strong>.
In this case, the ions emitted by the ancilla ions would not excite the
logical qubits. However, using two different species of ions causes
extra trouble when we want to implement arbitrary qubit operations <a class="footnote-reference brackets" href="#hughes2020" id="id9">6</a>.</p>
</div>
<div class="section" id="rabi-oscillations-to-manipulate-single-qubits">
<h2>Rabi oscillations to manipulate single qubits<a class="headerlink" href="#rabi-oscillations-to-manipulate-single-qubits" title="Permalink to this headline">¶</a></h2>
<p>How do we make single-qubit quantum gates? Namely, is there a way to put the electron in a
superposition of the ground and excited states? Since we aim to change
the energy state of an electron, we have no choice but to continue using
lasers to shoot photons at it, tuning the frequency to the
energy gap. To understand how we would achieve a superposition by
interacting with the ion using light, let us look at a mathematical
operator called the <em>Hamiltonian</em>. In physics, the Hamiltonian describes
the motion and external forces around an object we want to study. One of
the main difficulties encountered in quantum mechanics is determining
the correct Hamiltonian for a system. In our case, this work has already
been done by quantum optics experts. After many simplifications
involving some approximations, we find that the Hamiltonian that
describes an electron in an ion resonant to the laser light is given by
the operator</p>
<div class="math notranslate nohighlight">
\[\hat{H}=\frac{\hbar\Omega}{2}\left(S_+ e^{i\varphi}+S_{-}e^{-i\varphi}\right).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\Omega\)</span> is the <strong>Rabi frequency</strong>. It is defined by
<span class="math notranslate nohighlight">\(\Omega=\mu_m B/2\hbar\)</span>, where <span class="math notranslate nohighlight">\(B\)</span> is the applied magnetic
field due to the laser, and <span class="math notranslate nohighlight">\(\mu_m\)</span> is the magnetic moment of the
ion. The phase <span class="math notranslate nohighlight">\(\varphi\)</span> measures the initial displacement of the
light wave at the atom’s position. The matrices <span class="math notranslate nohighlight">\(S_+\)</span> and
<span class="math notranslate nohighlight">\(S_-\)</span> are</p>
<div class="math notranslate nohighlight">
\[\begin{split}S_+=\left( \begin{array}{cc} 0 &amp; 0 \\ 1 &amp; 0\end{array}\right), \qquad S_-=\left( \begin{array}{cc} 0 &amp; 1 \\ 0 &amp; 0\end{array}\right).\end{split}\]</div>
<p>Hamiltonians in physics are helpful because they tell us how systems
change with time in the presence of external interactions. In quantum
mechanics, Hamiltonians are represented by matrices, and the evolution of a system is
calculated using Schrödinger’s equation. When the Hamiltonian does not
depend on time, a qubit starting in state
<span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span> will evolve into the following
time-dependent state:</p>
<div class="math notranslate nohighlight">
\[\left\lvert \psi(t)\right\rangle = \exp(-i \hat{H} t/\hbar)\left\lvert g \right\rangle,\]</div>
<p>where <span class="math notranslate nohighlight">\(\exp\)</span> denotes the matrix exponential and <span class="math notranslate nohighlight">\(t\)</span> is
the duration of the interaction, which is controlled using <em>pulses</em>, i.e., short
bursts of light. We do not need to
elaborate on how matrix exponentials are calculated, since we can
implement them using the scipy library in Python. Let us see how our
basis states <span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span> and
<span class="math notranslate nohighlight">\(\left\lvert e \right\rangle\)</span> (<span class="math notranslate nohighlight">\(\left\lvert 0 \right\rangle\)</span> and
<span class="math notranslate nohighlight">\(\left\lvert 1 \right\rangle\)</span> in PennyLane) evolve under the action of this
Hamiltonian. First, we write a function that returns the matrix exponential
<span class="math notranslate nohighlight">\(\exp(-i \hat{H} t/\hbar)\)</span> as a function of <span class="math notranslate nohighlight">\(\varphi\)</span> and the
duration <span class="math notranslate nohighlight">\(t\)</span> of the pulse, with <span class="math notranslate nohighlight">\(\Omega\)</span> set to 100 kHz.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span>

<span class="n">Omega</span> <span class="o">=</span> <span class="mi">100</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S_plus</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S_minus</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>


<span class="k">def</span> <span class="nf">evolution</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a><span class="p">):</span>
    <span class="n">Ham</span> <span class="o">=</span> <span class="n">Omega</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S_plus</span></a> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S_minus</span></a> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Ham</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a><span class="p">)</span>
</pre></div>
</div>
<p>With this operator implemented, we can determine the sequences of pulses that
produce common gates. For example,  there is a combination of pulses
with different phases and durations that yield the Hadamard gate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ion_hadamard</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;We use a series of seemingly arbitrary pulses that will give the Hadamard gate.</span>
<span class="sd">    Why this is the case will become clear later&quot;&quot;&quot;</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>

<span class="c1">#For comparison, we use the Hadamard built into PennyLane</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hadamard</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>

<span class="c1">#We confirm that the values given by both functions are the same up to numerical error</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_hadamard</span></a><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hadamard</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_hadamard</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hadamard</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[ True  True]
[ True  True]
</pre></div>
</div>
<p>Note that the desired gate was obtained up to a global phase factor.
A similar exercise can be done for the <span class="math notranslate nohighlight">\(T\)</span> gate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ion_Tgate</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tgate</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.T.html#pennylane.T" title="pennylane.T" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">T</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>


<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_Tgate</span></a><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tgate</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_Tgate</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tgate</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[ True  True]
[ True  True]
</pre></div>
</div>
<p>This PennyLane code shows that we can obtain a Hadamard gate and a
<span class="math notranslate nohighlight">\(T\)</span> gate using consecutive pulses with different times and phases. Namely,
to get a Hadamard gate, we need five pulses, all of them with duration
<span class="math notranslate nohighlight">\(t=\frac{\pi}{2\Omega}\)</span>, where the second and the fourth pulse
have a phase of <span class="math notranslate nohighlight">\(\pi/2\)</span>. The Hadamard and <span class="math notranslate nohighlight">\(T\)</span> gates together can be used to
implement any operation on a single qubit, to an arbitrary degree of approximation. We
see that timing and dephasing our laser pulses provides a versatile way
to manipulate single qubits.</p>
<p>To get a better idea about how the duration
of the pulses affects the state that we generate, let us plot the probability
of obtaining the state <span class="math notranslate nohighlight">\(\left\lvert e \right\rangle\)</span> against the
duration of the pulse for a fixed phase of <span class="math notranslate nohighlight">\(\varphi = 0\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">evolution_prob</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a><span class="p">):</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">evolution</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="n">Omega</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.probs.html#pennylane.probs" title="pennylane.probs" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">probs</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">evolution_prob</span></a><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a><span class="p">]</span>

<span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#9D2EC5&quot;</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
    <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;time (in units of 1/Ω)&quot;</span><span class="p">,</span>
    <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Probability&quot;</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Probability of measuring the excited state&quot;</span>
<span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_trapped_ions_001.png" srcset="../_images/sphx_glr_tutorial_trapped_ions_001.png" alt="Probability of measuring the excited state" class = "sphx-glr-single-img"/><p>We see that the probability of obtaining the excited state changes with
the duration of the pulse, reaching a maximum at a time
<span class="math notranslate nohighlight">\(t=\pi/\Omega\)</span>, and then vanishing at <span class="math notranslate nohighlight">\(t=2\pi/\Omega\)</span>. This
pattern keeps repeating itself and is known as a <strong>Rabi oscillation</strong>.</p>
<p>In fact, we can solve the Schrödinger equation
explicitly (feel free to do this if you want to practice solving
differential equations!). If we do this, we can deduce that the
ground state <span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span> evolves to <a class="footnote-reference brackets" href="#bergou2021" id="id10">7</a></p>
<div class="math notranslate nohighlight">
\[\left\lvert \psi_0(t) \right\rangle = \cos\left(\frac{\Omega t}{2}\right)\left\lvert g \right\rangle -i\sin\left(\frac{\Omega t}{2}\right) e^{i\varphi}\left\lvert e \right\rangle .\]</div>
<p>We observe that we can obtain an arbitrary superposition of qubits by
adjusting the duration of the interaction and the phase. This means
that we can produce any single-qubit gate! To be more precise, let us
see what would happen if the initial state was
<span class="math notranslate nohighlight">\(\left\lvert e \right\rangle\)</span>. As before, we can show that the
evolution is given by</p>
<div class="math notranslate nohighlight">
\[\left\lvert \psi_1(t) \right\rangle = -i\sin\left(\frac{\Omega t}{2}\right)e^{-i\varphi}\left\lvert g \right\rangle +\cos\left(\frac{\Omega t}{2}\right)\left\lvert e \right\rangle .\]</div>
<p>Therefore, the unitary induced by a laser pulse of amplitude
<span class="math notranslate nohighlight">\(B\)</span>, duration <span class="math notranslate nohighlight">\(t\)</span>, and phase <span class="math notranslate nohighlight">\(\varphi\)</span> on an ion
with magnetic moment <span class="math notranslate nohighlight">\(\mu_m\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}U(\Omega,\varphi,t)=\left( \begin{array}{cc} \cos\left(\frac{\Omega t}{2}\right) &amp; -i\sin\left(\frac{\Omega t}{2}\right)e^{-i\varphi} \\ -i\sin\left(\frac{\Omega t}{2}\right)e^{i\varphi} &amp; \cos\left(\frac{\Omega t}{2}\right)\end{array}\right),\end{split}\]</div>
<p>which has the form of a general rotation. Since we can generate
arbitrary X and Y rotations using <span class="math notranslate nohighlight">\(\varphi=0\)</span> and
<span class="math notranslate nohighlight">\(\varphi=\pi/2\)</span>, Rabi oscillations allow us to build a
universal set of single-qubit gates.</p>
<p>Achieving the required superpositions of quantum states requires precise
control of the timing and phase of the pulse. This feat is not easy, but
it is not the most challenging step towards creating a trapped-ion
quantum computer. For typical Rabi frequencies of <span class="math notranslate nohighlight">\(\Omega=100\)</span>
kHz, the single-qubit gates can be implemented in a few milliseconds
with high accuracy. Thus, we can implement quantum algorithms involving
many gates even for the seemingly short lifespans of optical qubits. As
a consequence, we have now satisfied the single-qubit gate requirement of criterion 4.
The rest of this criterion is not theoretically difficult to implement.
However, it can be experimentally challenging.</p>
</div>
<div class="section" id="the-ion-chain-as-a-harmonic-oscillator">
<h2>The ion chain as a harmonic oscillator<a class="headerlink" href="#the-ion-chain-as-a-harmonic-oscillator" title="Permalink to this headline">¶</a></h2>
<p>To fully address the fourth criterion, we need to create
gates on two qubits. How can we
achieve this? It turns out that placing ions in a
chain is ideal for multiple-qubit gate implementations. When cooled
down, the entire ion chain acts as a <strong>quantum harmonic oscillator</strong>,
meaning that it can vibrate with energies that are multiples of Planck’s
constant <span class="math notranslate nohighlight">\(\hbar\)</span> times a fundamental frequency
<span class="math notranslate nohighlight">\(\omega\)</span>:</p>
<div class="math notranslate nohighlight">
\[E=n\hbar\omega.\]</div>
<p>When the chain is oscillating with energy <span class="math notranslate nohighlight">\(E=n\hbar\omega\)</span>, we
denote the harmonic oscillator state, also known as <strong>phonon state</strong> or
<strong>motional state</strong>, by <span class="math notranslate nohighlight">\(\left\lvert n\right\rangle\)</span>. The harmonic
oscillator can absorb and emit energy in multiples of
<span class="math notranslate nohighlight">\(\hbar\omega\)</span>, in packets of energy known as <strong>phonons</strong>.
When we shine laser light on a particular atom of
the ion chain, the entire chain could absorb the energy of the photons
and start oscillating. However, we have seen that this does not happen
when the atoms are cooled down and the light frequency matches the
energy gap. Instead, the atom changes energy level, and we can
manipulate a single qubit. But what happens when the frequency is away
from this value? In most cases, it does nothing, but it will excite both
the atom and the harmonic oscillator in some special circumstances. We
can use the harmonic oscillator states as auxiliary states that will
allow us to build two-qubit gates.</p>
<p>Let us introduce some notation that will help us understand exactly how
the two-qubit gates are implemented. When an ion is in the ground state
<span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\)</span> and the chain is in the state
<span class="math notranslate nohighlight">\(\left\lvert n \right\rangle\)</span>, we will write the state as
<span class="math notranslate nohighlight">\(\left\lvert g \right\rangle \left\lvert n \right\rangle\)</span>, and
similarly when the ion is in the excited state
<span class="math notranslate nohighlight">\(\left\lvert e \right\rangle\)</span>. If we are studying two ions at the
same time, then we will write the states in the form
<span class="math notranslate nohighlight">\(\left\lvert g \right\rangle\left\lvert g \right\rangle\left\lvert n \right\rangle\)</span>,
where the last <span class="math notranslate nohighlight">\(\left\lvert n \right\rangle\)</span> always represents the
state of the oscillating ion chain. Suppose that the ion’s energy gap
value is <span class="math notranslate nohighlight">\(\Delta\)</span>, and we shine light of frequency
<span class="math notranslate nohighlight">\(\omega_b=\omega+\Delta\)</span> on a particular ion. If it is in the
ground state, it will absorb an energy <span class="math notranslate nohighlight">\(\Delta\)</span>, and the ion chain
will absorb the rest. Therefore, this light frequency induces the
following <strong>blue sideband</strong> transition:</p>
<div class="math notranslate nohighlight">
\[\left\lvert g \right\rangle \left\lvert n \right\rangle \rightarrow \left\lvert e \right\rangle \left\lvert n+1\right\rangle.\]</div>
<p>By using the frequency <span class="math notranslate nohighlight">\(\omega_r=\Delta-\omega\)</span>, we can instead
excite the ion and de-excite the ion chain, also known as a
<strong>red sideband</strong> transition:</p>
<div class="math notranslate nohighlight">
\[\left\lvert g \right\rangle \left\lvert n \right\rangle \rightarrow \left\lvert e \right\rangle \left\lvert n-1\right\rangle.\]</div>
<p>Crucially, this frequency will do nothing if the ion chain is in the
state of zero energy.
If the light frequency is exactly <span class="math notranslate nohighlight">\(\Delta\)</span>,
the ion chain does not absorb any phonons, but the ion does become
excited. We will call this a <strong>carrier</strong> transition.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/sidebands.png"><img alt="../_images/sidebands.png" src="../_images/sidebands.png" style="width: 60%;" /></a>
<div class="legend">
<p>Effects of the sideband and carrier frequencies on an ion chain</p>
</div>
</div>
<p>Since the oscillations of the ion chain are quantum states, we may
wonder whether we can also create superpositions of motional states. For
both the red and blue sideband frequencies, the Hamiltonian turns out to
be similar to the one we saw above, but with a different Rabi frequency
<span class="math notranslate nohighlight">\(\tilde{\Omega}\)</span>. Following the same prescription as with single
ions, we can tune the duration and phase of the pulses to form
superpositions of phonon states. For example, for a blue sideband pulse
of duration <span class="math notranslate nohighlight">\(t=\pi/2\tilde{\Omega}\)</span> and phase
<span class="math notranslate nohighlight">\(\varphi=\pi/2\)</span>, a system of two ions in both the motional and
electronic ground state evolves as</p>
<div class="math notranslate nohighlight">
\[\left\lvert g\right\rangle \left\lvert g\right\rangle \left\lvert n\right\rangle \rightarrow \frac{1}{\sqrt{2}}\left(\left\lvert g\right\rangle \left\lvert g\right\rangle \left\lvert n\right\rangle + \left\lvert e\right\rangle \left\lvert g\right\rangle \left\lvert n+1\right\rangle\right)\]</div>
<p>when the pulse is incident on the first ion. Similarly, other choices of
duration and phase allow for arbitrary superpositions between phonon
states. This freedom to act on the motional states gives us the
necessary tools to implement two-qubit gates. We will see two examples
and use one of them to build a CNOT gate which, as is well-known, allows
for universal computations when combined with single-qubit gates.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The results above are relatively simple to understand, but they
are not exact. In particular, to guarantee that the sideband frequencies
will have the effects we described on the ion chain, the separation between
ions must be large enough, in a range known as the Lamb-Dicke regime. If we do
not operate under this condition, stronger interactions will come into
play, and we will not be able to act on individual ions with the laser
beams.</p>
</div>
</div>
<div class="section" id="entangling-ions-with-multi-qubit-gates">
<h2>Entangling ions with multi-qubit gates<a class="headerlink" href="#entangling-ions-with-multi-qubit-gates" title="Permalink to this headline">¶</a></h2>
<div class="alert alert-block alert-info docutils container">
<p><strong>Maximally entangled states:</strong> When all outcomes have the same
probability in an entangled state, such as in the two-ion state</p>
<div class="math notranslate nohighlight">
\[\left\lvert \psi \right\rangle = \frac{1}{\sqrt{2}}\left(\left\lvert e \right\rangle \left\lvert g \right\rangle +
\left\lvert g \right\rangle \left\lvert e \right\rangle\right),\]</div>
<p>we say that it is <strong>maximally entangled</strong>. To be able to do arbitrary
computations and for quantum advantage to be possible, we need two-qubit gates
that, combined with single qubit gates, produce maximally entangled states.
The CNOT gate is an example of this, and we will learn about others below.</p>
</div>
<p>The <strong>Cirac-Zoller</strong> gate <a class="footnote-reference brackets" href="#ciraczoller" id="id11">3</a> can completely entangle ions. It is also the
simplest way to illustrate how we can use the states of the harmonic
oscillator as an aid to create two-qubit gates. For a chain
with zero motional energy, we saw above that
applying a blue sideband pulse of duration <span class="math notranslate nohighlight">\(t=\pi/2\tilde{\Omega}\)</span> and phase
<span class="math notranslate nohighlight">\(\varphi=\pi/2\)</span> to the first ion gives us the state</p>
<div class="math notranslate nohighlight">
\[\left\lvert \psi \right\rangle = \frac{1}{\sqrt{2}}\left(\left\lvert g\right\rangle \left\lvert g\right\rangle \left\lvert 0\right\rangle + \left\lvert e\right\rangle \left\lvert g\right\rangle \left\lvert 1\right\rangle\right).\]</div>
<p>We can then use a similar idea to keep creating superpositions until we
end up in a maximally entangled state. The steps to implement the
Cirac-Zoller gate are shown on the diagram:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/CZgate.png"><img alt="../_images/CZgate.png" src="../_images/CZgate.png" style="width: 85%;" /></a>
<div class="legend">
<p>Implementation of the Cirac-Zoller gate using phonon states</p>
</div>
</div>
<p>We see that the consecutive application of a blue sideband, a carrier
frequency, and a red sideband, with different durations, gives us a
maximally entangled state. It is important to note that, in the last
step, the part of the superposition that has no chain motion is
unaffected by the red sideband. This property allows the creation of
entanglement in electronic states by using the phonon states.</p>
<p>However, the implementation of the Cirac-Zoller gate in real life is
plagued by problems. First, the ion chain needs to be completely cooled
down to the ground motional state, which can never be achieved. Second,
the gate is too slow. Surely, if we use hyperfine qubits, we can take as
long as we want to implement the gates. The problem comes from the
harmonic oscillator states. Since ion chains are large and less isolated
from the environment, phonon states are rather short-lived due to
decoherence.</p>
<p>For actual applications, we use a more ingenious gate, known as the
<strong>Mølmer-Sørensen</strong> gate <a class="footnote-reference brackets" href="#molmer1999" id="id12">8</a>. It has the advantage that the ions do not
need to be perfectly cooled to the motional ground state for it to work.
It relies on simultaneously shining two lasers at different frequencies
<span class="math notranslate nohighlight">\(\omega_{\pm}\)</span> on the two target ions, which are slightly detuned
from the atomic energy gap <span class="math notranslate nohighlight">\(\Delta\)</span>:</p>
<div class="math notranslate nohighlight">
\[\omega_{\pm}=\Delta \pm \delta\]</div>
<p>The net effect of this interaction with laser light is to excite
<span class="math notranslate nohighlight">\(\left\lvert g \right\rangle \left\lvert g \right\rangle \left\lvert n \right\rangle \rightarrow \left\lvert e \right\rangle \left\lvert e \right\rangle\left\lvert n \right\rangle\)</span>,
and it can do so through any of the four paths shown below:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/molmer_sorensen.png"><img alt="../_images/molmer_sorensen.png" src="../_images/molmer_sorensen.png" style="width: 60%;" /></a>
<div class="legend">
<p>Mølmer-Sørensen gate implemented with two simultaneous laser pulses</p>
</div>
</div>
<p>Using a quantum mechanical technique known as perturbation theory, we
can deduce that there is also a Rabi frequency <span class="math notranslate nohighlight">\(\Omega_{MS}\)</span>
associated with this evolution. Therefore, adjusting the time and the
phase of the lasers can lead to a superposition of
<span class="math notranslate nohighlight">\(\left\lvert g \right\rangle \left\lvert g \right\rangle \left\lvert n \right\rangle\)</span>
and
<span class="math notranslate nohighlight">\(\left\lvert e \right\rangle \left\lvert e \right\rangle\left\lvert n \right\rangle\)</span>.
For example, we can obtain the state
<span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}\left(\left\lvert g \right\rangle \left\lvert g \right\rangle\left\lvert n \right\rangle +\left\lvert e \right\rangle \left\lvert e \right\rangle\left\lvert n \right\rangle\right)\)</span>
which, in the two-ion subsystem, corresponds to the maximally entangled state
<span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}\left(\left\lvert g \right\rangle \left\lvert g \right\rangle +\left\lvert e \right\rangle \left\lvert e \right\rangle\right)\)</span>.
Using Schrödinger’s equation allows us to derive how the qubits evolve
when we apply the Mølmer-Sørensen protocol for a time <span class="math notranslate nohighlight">\(t\)</span>. The
Hamiltonian is more involved, so we will not do this. We simply state
the result (for zero phase) and implement it via a Python function</p>
<div class="math notranslate nohighlight">
\[\begin{split}U_{MS}(t) =\left( \begin{array}{cccc}
\cos(\frac{\Omega_{MS}t}{2}) &amp; 0 &amp; 0 &amp; -i\sin(\frac{\Omega_{MS} t}{2})\\
0 &amp; \cos(\frac{\Omega_{MS} t}{2}) &amp; -i\sin(\frac{\Omega_{MS} t}{2}) &amp; 0 \\
0 &amp; -i\sin(\frac{\Omega_{MS} t}{2}) &amp; \cos(\frac{\Omega_{MS} t}{2}) &amp; 0 \\
 -i\sin(\frac{\Omega_{MS} t}{2}) &amp; 0 &amp; 0 &amp; \cos(\frac{\Omega_{MS} t}{2})
 \end{array}
 \right)\end{split}\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Omega</span> <span class="o">=</span> <span class="mi">100</span>


<span class="k">def</span> <span class="nf">Molmer_Sorensen</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a><span class="p">):</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Omega</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">t</span></a> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ms</span>
</pre></div>
</div>
<p>Since the CNOT gate is commonly used in quantum algorithms, let us
determine how to obtain it from the Mølmer-Sørensen gate.
It is possible to do so by using a combination of
single-qubit rotations and the Mølmer-Sørensen gate applied for a period of
<span class="math notranslate nohighlight">\(t=\pi/2\Omega_{MS}\)</span>. Explicitly, we do this using the
following circuit <a class="footnote-reference brackets" href="#brown2019" id="id13">9</a>:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/CNOTgate.png"><img alt="../_images/CNOTgate.png" src="../_images/CNOTgate.png" style="width: 100%;" /></a>
<div class="legend">
<p>Circuit for the CNOT gate using rotations and an MS gate</p>
</div>
</div>
<p>where <span class="math notranslate nohighlight">\(RX\)</span> and <span class="math notranslate nohighlight">\(RY\)</span> are the usual rotations around the X and Y
axes, and <span class="math notranslate nohighlight">\(MS(t)\)</span> denotes the Mølmer-Sørensen gate applied for a
time <span class="math notranslate nohighlight">\(t/\Omega_{MS}\)</span>. Let us verify that this is indeed the case
by building the circuit in PennyLane:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev2</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span><span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev2</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ion_cnot</span><span class="p">(</span><span class="n">basis_state</span><span class="p">):</span>

    <span class="c1">#Prepare the two-qubit basis states from the input</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.BasisStatePreparation.html#pennylane.BasisStatePreparation" title="pennylane.BasisStatePreparation" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">BasisStatePreparation</span></a><span class="p">(</span><span class="n">basis_state</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="c1">#Implements the circuit shown above</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">Molmer_Sorensen</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">Omega</span><span class="p">),</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>

<span class="c1">#Compare with built-in CNOT</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev2</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cnot_gate</span><span class="p">(</span><span class="n">basis_state</span><span class="p">):</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.BasisStatePreparation.html#pennylane.BasisStatePreparation" title="pennylane.BasisStatePreparation" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">BasisStatePreparation</span></a><span class="p">(</span><span class="n">basis_state</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>

<span class="c1">#Check that they are the same up to numerical error and global phase</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_cnot</span></a><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cnot_gate</span></a><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_cnot</span></a><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cnot_gate</span></a><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_cnot</span></a><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cnot_gate</span></a><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ion_cnot</span></a><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cnot_gate</span></a><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[ True  True  True  True]
[ True  True  True  True]
[ True  True  True  True]
[ True  True  True  True]
</pre></div>
</div>
<p>This is indeed the CNOT gate, up to a global phase.
At sufficiently low temperatures, the Rabi frequency <span class="math notranslate nohighlight">\(\Omega_{MS}\)</span>
does not depend on the initial harmonic oscillator state, so this method
can be used reliably even when we fail to cool down the ion chain
completely. This property also makes this gate more robust to the
decoherence of the chain.</p>
</div>
<div class="section" id="the-problem-with-too-many-ions">
<h2>The problem with too many ions<a class="headerlink" href="#the-problem-with-too-many-ions" title="Permalink to this headline">¶</a></h2>
<p>We have learned that the trapped ion paradigm allows us to prepare and
measure individual qubits, and that we can implement single and
multi-qubit gates with high accuracy. What’s not to like? As in every
physical realization of quantum computers, trapped ions come with
advantages and disadvantages. The main problem shared by all physical
implementations of quantum computers is scalability. The root of the
problem and the technological challenges involved depend on our
particular framework.</p>
<p>To understand why scalability is a problem for trapped ions, let us
consider a long ion chain. As discussed in the previous section, to
implement multi-qubit gates, we need to lean on the harmonic oscillator
states of the ion chains. These turn out to be a blessing and a curse
simultaneously. Quantum computing with trapped ions would not be
possible without motional states. However, if we put more ions in the
chain, the values of the frequencies needed to excite it become too
close together. As a consequence, unless we are extremely careful with
our laser frequencies, we may end up in the wrong quantum state. We do
not have infinite precision, so when the number of ions becomes close to
100, our current gate technology becomes practically unusable.</p>
<p>Is there a way to make the frequency values more spread out? One way is
to reduce the Rabi frequency of the Mølmer-Sørensen gate, which we
control by changing the strength of the laser light. Disappointingly,
not only does this strategy make it harder to control the ion, but it
also increases the time needed to apply the Mølmer-Sørensen gate. As
already mentioned in the previous section, time is of the essence when
applying multi-qubit gates since the motional states of the chain are
extremely sensitive to decoherence. We cannot afford to have even slower
gates.</p>
<p>Which of the DiVincenzo criteria do trapped ions quantum computers still
fail to meet? Criterion 1 is only met partially: we do have robust
qubits, but there seems to be a hard technological limit for
scalability. Criterion 3 also becomes an issue when the ion chain is too
long since coherence times for motional states become shorter. The
two-qubit requirement of criterion 4 is related to this decoherence problem since
multi-qubit gates can take too long to implement accurately in a long
ion chain. Criterion 2, as already discussed, does not present too much
of a problem thanks to optical pumping technology. However, problems remain for criterion 5.
As we already saw, we can use two different
species of ions to obtain good measurements. But, in general, it is
challenging to implement consecutive good-quality two-qubit gates
between different ion species; strategies like the Mølmer-Sørensen
gate will not work and need modification.</p>
</div>
<div class="section" id="the-state-of-the-art">
<h2>The state of the art<a class="headerlink" href="#the-state-of-the-art" title="Permalink to this headline">¶</a></h2>
<p>Of course, no matter how insurmountable these challenges seem to be,
physicists will not give up. Many ingenious ways to address these
technical complications have already been proposed. Not surprisingly, it
is one of the hottest research topics in quantum computing, and papers
with newer technologies have probably been published since this tutorial
was written.</p>
<p>The main issue discussed above is that a long ion chain is noisy and
makes qubits challenging to manipulate. In 2002, Kielpinski and
collaborators <a class="footnote-reference brackets" href="#qccd2002" id="id14">11</a> came up with an intelligent solution: if size is a
problem, let us make the chain shorter! Of course, we would still like
to be able to manipulate thousands of qubits. To achieve this, we could
build a segmented trap, also known as a <strong>QCCD</strong> (Quantum Charge-Coupled
Device) <strong>architecture</strong>. The idea is to make our traps mobile. We could
move ions from one place to another whenever we need to apply a
multi-qubit gate and move them far away when we need to manipulate them
individually. Thus, the chain that we interact with when we need to
entangle qubits is not long. This method makes the motional states less
prone to decoherence. The phonon frequencies are also sufficiently
spread apart so that the gates can be implemented.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/qccd.png"><img alt="../_images/qccd.png" src="../_images/qccd.png" style="width: 60%;" /></a>
<div class="legend">
<p>Example of a proposed QCCD architecture, as in <a class="footnote-reference brackets" href="#amini2010" id="id15">12</a></p>
</div>
</div>
<p>QCCD architectures sound like a straightforward solution, but seeing as
we do not have large quantum computers yet, there must be some nuances.
In practice, moving ions around a trap is not easy at all. The
containing potential must be changed in a highly accurate manner to
transport the ions without losing them. Such technology has not been
perfected yet. While it has been possible to manipulate ions and make
them interact, the traps we need for a good quantum computer are
somewhat involved. We want multiple segments in the trap that allow for
arbitrary ions to be brought together to run quantum algorithms without
any limitations. In April 2021, Honeywell reported building a
multi-segment QCCD architecture with six qubits and two interaction
zones <a class="footnote-reference brackets" href="#pino2021" id="id16">13</a>. However, it is unclear how this proposed technology would scale
to higher orders of magnitude.</p>
<p>Another path towards a solution would be to simply accept the short
coherence times of the ion chains, and try to make the two-qubit gates
faster. Such an approach is being followed by the startup IonQ. In
January 2021, they showed that it is possible to speed up the
Mølmer-Sørensen gate by one order of magnitude by changing the shape
of the laser pulse <a class="footnote-reference brackets" href="#blumel2021" id="id17">14</a>. Such a speedup might not be enough as the ion chain
grows. However, a combination of approaches involving QCCDs and
faster gates may yield the solution to the scalability problem in the
future.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is another proposed solution to apply two-qubit gates efficiently, which
involves connecting the ions with photons. Using polarization state
measurements, we can also entangle electronic states <a class="footnote-reference brackets" href="#monroe2014" id="id18">10</a>. This technology
is still in the early stages of development.</p>
</div>
<p>Implementing multi-qubit gates is not the only problem for
trapped-ion quantum computers. There is still much to do to improve the
precision of measurements, for example. Most of the photons emitted by
ions during a measurement are lost, so it would be good to find ways to
direct more of them to the detector. One can do this using a waveguide architecture inside
the trap. Similarly, as the number of ions grows, the number of laser
beams we need does as well <a class="footnote-reference brackets" href="#niffenegger2020" id="id19">15</a>. Again, waveguides can also be used to
direct the photons to target ions. Combined with a better QCCD
architecture, this optical integration would well-equip us to run
quantum computing algorithms with trapped ions.</p>
</div>
<div class="section" id="concluding-remarks">
<h2>Concluding Remarks<a class="headerlink" href="#concluding-remarks" title="Permalink to this headline">¶</a></h2>
<p>Ion trapping is currently one of the most widespread physical implementations
of quantum computers, both in academia and in industry. Their popularity comes
as no surprise, since the physical principles that make the paradigm work are
simple enough, and the necessary technology is already well-developed.
Granted, there are challenging technical difficulties to scale these quantum
computers further. However, viable solutions have been proposed, and many
institutions around the world are working non-stop to make them a reality.
Moreover, what could be considered simple prototypes of such technologies have
already proven extremely powerful. The big unknown is whether such devices can scale as much as we
would like them to. It would be unwise to give up only because the challenge is
imposing. After all, personal computers were the fruit of hard work and
inventiveness, and very few people were able to predict that they would scale
as much as they have. Now you possess a high-level knowledge of how trapped
ion computers work! Make sure to read any new papers that come out
to keep updated on new developments. Will the trapped ion framework
emerge victorious in this race to obtain a useful quantum computer? Only time will tell!</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="divincenzo2000"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>D. DiVincenzo. (2000) “The Physical Implementation of Quantum Computation”,
<a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1002/1521-3978(200009)48:9/11%3C771::AID-PROP771%3E3.0.CO;2-E">Fortschritte der Physik 48 (9–11): 771–783</a>.
(<a class="reference external" href="https://arxiv.org/abs/quant-ph/0002077">arXiv</a>)</p>
</dd>
<dt class="label" id="paul1953"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>W. Paul, H. Steinwedel. (1953) “Ein neues Massenspektrometer ohne Magnetfeld”,
RZeitschrift für Naturforschung A 8 (7): 448-450.</p>
</dd>
<dt class="label" id="ciraczoller"><span class="brackets">3</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>J. Cirac, P. Zoller. (1995) “Quantum Computations with Cold Trapped Ions”.
Physical Review Letters 74 (20): 4091–4094.</p>
</dd>
<dt class="label" id="malinowski"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>M. Malinowski. (2021) “Unitary and Dissipative Trapped-​Ion Entanglement Using
Integrated Optics”. PhD Thesis retrieved from <a class="reference external" href="https://ethz.ch/content/dam/ethz/special-interest/phys/quantum-electronics/tiqi-dam/documents/phd_theses/Thesis-Maciej-Malinowski">ETH thesis repository</a>.</p>
</dd>
<dt class="label" id="nandc2000"><span class="brackets"><a class="fn-backref" href="#id7">5</a></span></dt>
<dd><p>M. A. Nielsen, and I. L. Chuang (2000) “Quantum Computation and Quantum Information”,
Cambridge University Press.</p>
</dd>
<dt class="label" id="hughes2020"><span class="brackets"><a class="fn-backref" href="#id9">6</a></span></dt>
<dd><p>A. Hughes, V. Schafer, K. Thirumalai, et al. (2020)
“Benchmarking a High-Fidelity Mixed-Species Entangling Gate”
<a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.125.080504">Phys. Rev. Lett. 125, 080504</a>.
(<a class="reference external" href="https://arxiv.org/abs/2004.08162">arXiv</a>)</p>
</dd>
<dt class="label" id="bergou2021"><span class="brackets">7</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>J. Bergou, M. Hillery, and M. Saffman. (2021) “Quantum Information Processing”,
Springer.</p>
</dd>
<dt class="label" id="molmer1999"><span class="brackets"><a class="fn-backref" href="#id12">8</a></span></dt>
<dd><p>A. Sørensen, K. Mølmer.  (1999) “Multi-particle entanglement of hot trapped ions”,
<a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.82.1835">Physical Review Letters. 82 (9): 1835–1838</a>.
(<a class="reference external" href="https://arxiv.org/abs/quant-ph/9810040">arXiv</a>)</p>
</dd>
<dt class="label" id="brown2019"><span class="brackets"><a class="fn-backref" href="#id13">9</a></span></dt>
<dd><p>M. Brown, M. Newman, and K. Brown. (2019)
“Handling leakage with subsystem codes”,
<a class="reference external" href="https://iopscience.iop.org/article/10.1088/1367-2630/ab3372">New J. Phys. 21 073055</a>.
(<a class="reference external" href="https://arxiv.org/abs/1903.03937">arXiv</a>)</p>
</dd>
<dt class="label" id="monroe2014"><span class="brackets"><a class="fn-backref" href="#id18">10</a></span></dt>
<dd><p>C. Monroe, R. Ruassendorf, A Ruthven, et al. (2019)
“Large scale modular quantum computer architecture with atomic memory and photonic interconnects”,
<a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.89.022317">Phys. Rev. A 89 022317</a>.
(<a class="reference external" href="https://arxiv.org/abs/1208.0391">arXiv</a>)</p>
</dd>
<dt class="label" id="qccd2002"><span class="brackets"><a class="fn-backref" href="#id14">11</a></span></dt>
<dd><p>D. Kielpinski, C. Monroe, and D. Wineland. (2002)
“Architecture for a large-scale ion-trap quantum computer”,
<a class="reference external" href="https://www.nature.com/articles/nature00784">Nature 417, 709–711 (2002).</a>.</p>
</dd>
<dt class="label" id="amini2010"><span class="brackets"><a class="fn-backref" href="#id15">12</a></span></dt>
<dd><p>J. Amini, H. Uys, J. Wesenberg, et al. (2010)
“Toward scalable ion traps for quantum information processing”,
<a class="reference external" href="https://iopscience.iop.org/article/10.1088/1367-2630/12/3/033031/meta">New J. Phys 12 033031</a>.
(<a class="reference external" href="https://arxiv.org/abs/0909.2464">arXiv</a>)</p>
</dd>
<dt class="label" id="pino2021"><span class="brackets"><a class="fn-backref" href="#id16">13</a></span></dt>
<dd><p>J. Pino, J. Dreiling, J, C, Figgatt, et al. (2021)
“Demonstration of the trapped-ion quantum CCD computer architecture”.
<a class="reference external" href="https://www.nature.com/articles/s41586-021-03318-4">Nature 592, 209–213</a>.
(<a class="reference external" href="https://arxiv.org/abs/2003.01293">arXiv</a>)</p>
</dd>
<dt class="label" id="blumel2021"><span class="brackets"><a class="fn-backref" href="#id17">14</a></span></dt>
<dd><p>R. Blumel, N. Grzesiak, N. Nguyen, et al. (2021)
“Efficient Stabilized Two-Qubit Gates on a Trapped-Ion Quantum Computer”
<a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.126.220503">Phys. Rev. Lett. 126, 220503</a>.
(<a class="reference external" href="https://arxiv.org/abs/2101.07887">arXiv</a>)</p>
</dd>
<dt class="label" id="niffenegger2020"><span class="brackets"><a class="fn-backref" href="#id19">15</a></span></dt>
<dd><p>R. Niffenegger, J. Stuart, C.Sorace-Agaskar, et al. (2020)
“Integrated multi-wavelength control of an ion qubit”
<a class="reference external" href="https://www.nature.com/articles/s41586-020-2811-x">Nature volume 586, pages538–542</a>.
(<a class="reference external" href="https://arxiv.org/abs/2001.05052">arXiv</a>)</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/alvaro_ballon.png" alt="Alvaro Ballon" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Alvaro Ballon</h4>
        <p class="bio-text__author-description">Alvaro is a quantum computing educator at Xanadu. His work involves making the latest developments in quantum computing accessible to the community.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.470 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-trapped-ions-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/e238501c5333859d7665cdaba4176e5c/tutorial_trapped_ions.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_trapped_ions.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/0a5fb7225c6653272fd372d3b5ea2839/tutorial_trapped_ions.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_trapped_ions.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_trapped_ions</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Trapped ion quantum computers</a><ul class='current'>
<li class='current'><a class="reference internal" href="#how-to-trap-an-ion">How to trap an ion</a></li>
<li class='current'><a class="reference internal" href="#trapped-ions-as-robust-qubits">Trapped ions as robust qubits</a></li>
<li class='current'><a class="reference internal" href="#non-demolition-measurements">Non-demolition measurements</a></li>
<li class='current'><a class="reference internal" href="#rabi-oscillations-to-manipulate-single-qubits">Rabi oscillations to manipulate single qubits</a></li>
<li class='current'><a class="reference internal" href="#the-ion-chain-as-a-harmonic-oscillator">The ion chain as a harmonic oscillator</a></li>
<li class='current'><a class="reference internal" href="#entangling-ions-with-multi-qubit-gates">Entangling ions with multi-qubit gates</a></li>
<li class='current'><a class="reference internal" href="#the-problem-with-too-many-ions">The problem with too many ions</a></li>
<li class='current'><a class="reference internal" href="#the-state-of-the-art">The state of the art</a></li>
<li class='current'><a class="reference internal" href="#concluding-remarks">Concluding Remarks</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_trapped_ions</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_quantum-computing.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_error_mitigation.html" title="Error mitigation with Mitiq and PennyLane"
             >next</a> |</li>
        <li class="right" >
          <a href="gbs.html" title="Quantum advantage with Gaussian Boson Sampling"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" >Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Trapped ion quantum computers</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>