
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Machine learning for many-body problems" property="og:description" />
<meta content="https://pennylane.ai/qml/_images/ml_classical_shadow.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Machine learning for quantum many-body problems &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_ml_classical_shadows.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Machine learning for many-body problems" property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Machine learning for quantum many-body problems &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_ml_classical_shadows.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Function Fitting using Quantum Signal Processing" href="function_fitting_qsp.html" />
    <link rel="prev" title="Quantum advantage in learning from experiments" href="tutorial_learning_from_experiments.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="function_fitting_qsp.html" title="Function Fitting using Quantum Signal Processing"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_learning_from_experiments.html" title="Quantum advantage in learning from experiments"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_qml.html" accesskey="U">Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Machine learning for quantum many-body problems</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-ml-classical-shadows-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="machine-learning-for-quantum-many-body-problems">
<span id="sphx-glr-demos-tutorial-ml-classical-shadows-py"></span><h1>Machine learning for quantum many-body problems<a class="headerlink" href="#machine-learning-for-quantum-many-body-problems" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_classical_shadows.html", "tutorial_kernel_based_training.html", "tutorial_kernels_module.html"];
    var related_tutorials_titles = ['Classical Shadows', 'Kernel-based training with scikit-learn', 'Training and evaluating quantum kernels'];
</script></p>
<p><em>Author: Utkarsh Azad — Posted: 02 May 2022. Last Updated: 09 May 2022</em></p>
<p>Storing and processing a complete description of an <span class="math notranslate nohighlight">\(n\)</span>-qubit quantum mechanical
system is challenging because the amount of memory required generally scales exponentially
with the number of qubits. The quantum community has recently addressed this challenge by using
the <a class="reference internal" href="tutorial_classical_shadows.html"><span class="doc">classical shadow</span></a> formalism, which allows us to build more concise classical descriptions
of quantum states using randomized single-qubit measurements. It was argued in Ref. <a class="footnote-reference brackets" href="#preskill" id="id1">1</a>
that combining classical shadows with classical machine learning enables using learning models
that efficiently predict properties of the quantum systems, such as the expectation value of a
Hamiltonian, correlation functions, and entanglement entropies.</p>
<div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="../_images/class_shadow_ml.png"><img alt="Combining ML with Classical Shadow" src="../_images/class_shadow_ml.png" style="width: 80%;" /></a>
<p class="caption"><span class="caption-text">Combining machine learning and classical shadows</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>In this demo, we describe one of the ideas presented in Ref. <a class="footnote-reference brackets" href="#preskill" id="id2">1</a> for using classical
shadow formalism and machine learning to predict the ground-state properties of the
2D antiferromagnetic Heisenberg model. We begin by learning how to build the Heisenberg model,
calculate its ground-state properties, and compute its classical shadow. Finally, we demonstrate
how to use <a class="reference internal" href="tutorial_kernels_module.html"><span class="doc">kernel-based learning models</span></a> to predict ground-state properties from the learned
classical shadows. So let’s get started!</p>
<div class="section" id="building-the-2d-heisenberg-model">
<h2>Building the 2D Heisenberg Model<a class="headerlink" href="#building-the-2d-heisenberg-model" title="Permalink to this headline">¶</a></h2>
<p>We define a two-dimensional antiferromagnetic <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_Heisenberg_model">Heisenberg model</a> as a square
lattice, where a spin-1/2 particle occupies each site. The antiferromagnetic
nature and the overall physics of this model depend on the couplings
<span class="math notranslate nohighlight">\(J_{ij}\)</span> present between the spins, as reflected in the Hamiltonian
associated with the model:</p>
<div class="math notranslate nohighlight">
\[H = \sum_{i &lt; j} J_{ij}(X_i X_j + Y_i Y_j + Z_i Z_j) .\]</div>
<p>Here, we consider the family of Hamiltonians where all the couplings <span class="math notranslate nohighlight">\(J_{ij}\)</span>
are sampled uniformly from [0, 2]. We build a coupling matrix <span class="math notranslate nohighlight">\(J\)</span> by providing
the number of rows <span class="math notranslate nohighlight">\(N_r\)</span> and columns <span class="math notranslate nohighlight">\(N_c\)</span> present in the square lattice.
The dimensions of this matrix are <span class="math notranslate nohighlight">\(N_s \times N_s\)</span>, where <span class="math notranslate nohighlight">\(N_s = N_r \times N_c\)</span>
is the total number of spin particles present in the model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">pennylane.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">anp</span>

<span class="k">def</span> <span class="nf">build_coupling_mats</span><span class="p">(</span><span class="n">num_mats</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">):</span>
    <span class="n">num_spins</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="n">num_cols</span>
    <span class="n">coupling_mats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_mats</span><span class="p">,</span> <span class="n">num_spins</span><span class="p">,</span> <span class="n">num_spins</span><span class="p">))</span>
    <span class="n">coup_terms</span> <span class="o">=</span> <span class="n">anp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_mats</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="n">num_cols</span> <span class="o">-</span> <span class="n">num_rows</span> <span class="o">-</span> <span class="n">num_cols</span><span class="p">))</span>
    <span class="c1"># populate edges to build the grid lattice</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_spins</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">sj</span> <span class="o">%</span> <span class="n">num_cols</span> <span class="ow">and</span> <span class="n">sj</span> <span class="o">-</span> <span class="n">si</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">sj</span> <span class="o">-</span> <span class="n">si</span> <span class="o">==</span> <span class="n">num_cols</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_mats</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">term</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">coup_terms</span><span class="p">[</span><span class="n">itr</span><span class="p">]):</span>
            <span class="n">coupling_mats</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coupling_mats</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">term</span>
    <span class="k">return</span> <span class="n">coupling_mats</span>
</pre></div>
</div>
<p>For this demo, we study a model with four spins arranged on the nodes of
a square lattice. We require four qubits for simulating this model;
one qubit for each spin. We start by building a coupling matrix <code class="docutils literal notranslate"><span class="pre">J_mat</span></code>
using our previously defined function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nr</span><span class="p">,</span> <span class="n">Nc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="n">Nr</span> <span class="o">*</span> <span class="n">Nc</span>  <span class="c1"># Ns</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a> <span class="o">=</span> <span class="n">build_coupling_mats</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nr</span><span class="p">,</span> <span class="n">Nc</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>We can now visualize the model instance by representing the coupling matrix as a
<code class="docutils literal notranslate"><span class="pre">networkx</span></code> graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a><span class="p">),</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">Nc</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">Nc</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;lightblue&quot;</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">node_size</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s2">&quot;firebrick&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_ml_classical_shadows_001.png" srcset="../_images/sphx_glr_tutorial_ml_classical_shadows_001.png" alt="tutorial ml classical shadows" class = "sphx-glr-single-img"/><p>We then use the same coupling matrix <code class="docutils literal notranslate"><span class="pre">J_mat</span></code> to obtain the Hamiltonian
<span class="math notranslate nohighlight">\(H\)</span> for the model we have instantiated above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>

<span class="k">def</span> <span class="nf">Hamiltonian</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a><span class="p">):</span>
    <span class="n">coeffs</span><span class="p">,</span> <span class="n">ops</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">ns</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">coeff</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">coeff</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">]:</span>
                <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">@</span> <span class="n">op</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
    <span class="n">H</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hamiltonian.html#pennylane.Hamiltonian" title="pennylane.Hamiltonian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hamiltonian</span></a><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">ops</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hamiltonian =</span><span class="se">\n</span><span class="si">{</span><span class="n">Hamiltonian</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Hamiltonian =
  (0.44013459956570355) [X2 X3]
+ (0.44013459956570355) [Y2 Y3]
+ (0.44013459956570355) [Z2 Z3]
+ (1.399024099899152) [X0 X2]
+ (1.399024099899152) [Y0 Y2]
+ (1.399024099899152) [Z0 Z2]
+ (1.920034606671837) [X0 X1]
+ (1.920034606671837) [Y0 Y1]
+ (1.920034606671837) [Z0 Z1]
+ (1.9997345852477584) [X1 X3]
+ (1.9997345852477584) [Y1 Y3]
+ (1.9997345852477584) [Z1 Z3]
</pre></div>
</div>
<p>For the Heisenberg model, a property of interest is usually the two-body
correlation function <span class="math notranslate nohighlight">\(C_{ij}\)</span>, which for a pair of spins <span class="math notranslate nohighlight">\(i\)</span>
and <span class="math notranslate nohighlight">\(j\)</span> is defined as the following operator:</p>
<div class="math notranslate nohighlight">
\[\hat{C}_{ij} = \frac{1}{3} (X_i X_j + Y_iY_j + Z_iZ_j).\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">corr_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">]:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">@</span> <span class="n">op</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Identity.html#pennylane.Identity" title="pennylane.Identity" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Identity</span></a><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ops</span>
</pre></div>
</div>
<p>The expectation value of each such operator <span class="math notranslate nohighlight">\(\hat{C}_{ij}\)</span> with respect to
the ground state <span class="math notranslate nohighlight">\(|\psi_{0}\rangle\)</span> of the model can be used to build
the correlation matrix <span class="math notranslate nohighlight">\(C\)</span>:</p>
<div class="math notranslate nohighlight">
\[{C}_{ij} = \langle \hat{C}_{ij} \rangle = \frac{1}{3} \langle \psi_{0} | X_i X_j + Y_iY_j + Z_iZ_j | \psi_{0} \rangle .\]</div>
<p>Hence, to build <span class="math notranslate nohighlight">\(C\)</span> for the model, we need to calculate its
ground state <span class="math notranslate nohighlight">\(|\psi_{0}\rangle\)</span>. We do this by diagonalizing
the Hamiltonian for the model. Then, we obtain the eigenvector corresponding
to the smallest eigenvalue.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hamiltonian.html#pennylane.Hamiltonian" title="pennylane.Hamiltonian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham</span></a> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">J_mat</span></a><span class="p">)</span>
<span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hamiltonian.html#pennylane.Hamiltonian.sparse_matrix" title="pennylane.Hamiltonian.sparse_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">ham</span><span class="o">.</span><span class="n">sparse_matrix</span></a><span class="p">())</span>
<span class="n">psi0</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)]</span>
</pre></div>
</div>
<p>We then build a circuit that initializes the qubits into the ground
state and measures the expectation value of the provided set of observables.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev_exact</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">)</span> <span class="c1"># for exact simulation</span>

<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">observables</span><span class="p">):</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="c1"># normalize the state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observables</span><span class="p">]</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit_exact</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QNode</span></a><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">dev_exact</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we execute this circuit to obtain the exact correlation matrix
<span class="math notranslate nohighlight">\(C\)</span>. We compute the correlation operators <span class="math notranslate nohighlight">\(\hat{C}_{ij}\)</span> and
their expectation values with respect to the ground state <span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="n">corrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">coups</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">build_exact_corrmat</span><span class="p">(</span><span class="n">coups</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">psi</span><span class="p">):</span>
    <span class="n">corr_mat_exact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coups</span><span class="p">):</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">corr_mat_exact</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corr_mat_exact</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">circuit</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">observables</span><span class="o">=</span><span class="p">[</span><span class="n">o</span><span class="p">])</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">corr</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
            <span class="p">)</span>
            <span class="n">corr_mat_exact</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_mat_exact</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">corr_mat_exact</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">expval_exact</span></a> <span class="o">=</span> <span class="n">build_exact_corrmat</span><span class="p">(</span><span class="n">coups</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit_exact</span></a><span class="p">,</span> <span class="n">psi0</span><span class="p">)</span>
</pre></div>
</div>
<p>Once built, we can visualize the correlation matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">expval_exact</span></a><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;RdBu&quot;</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Exact Correlation Matrix&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.80</span>    <span class="p">)</span>
<span class="n">bar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$C_</span><span class="si">{ij}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">bar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_ml_classical_shadows_002.png" srcset="../_images/sphx_glr_tutorial_ml_classical_shadows_002.png" alt="Exact Correlation Matrix" class = "sphx-glr-single-img"/></div>
<div class="section" id="constructing-classical-shadows">
<h2>Constructing Classical Shadows<a class="headerlink" href="#constructing-classical-shadows" title="Permalink to this headline">¶</a></h2>
<p>Now that we have built the Heisenberg model, the next step is to construct
a <a class="reference internal" href="tutorial_classical_shadows.html"><span class="doc">classical shadow</span></a> representation for its ground state. To construct an
approximate classical representation of an <span class="math notranslate nohighlight">\(n\)</span>-qubit quantum state <span class="math notranslate nohighlight">\(\rho\)</span>,
we perform randomized single-qubit measurements on <span class="math notranslate nohighlight">\(T\)</span>-copies of
<span class="math notranslate nohighlight">\(\rho\)</span>. Each measurement is chosen randomly among the Pauli bases
<span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span>, or <span class="math notranslate nohighlight">\(Z\)</span> to yield random <span class="math notranslate nohighlight">\(n\)</span> pure product
states <span class="math notranslate nohighlight">\(|s_i\rangle\)</span> for each copy:</p>
<div class="math notranslate nohighlight">
\[|s_{i}^{(t)}\rangle \in \{|0\rangle, |1\rangle, |+\rangle, |-\rangle, |i+\rangle, |i-\rangle\}.\]</div>
<div class="math notranslate nohighlight">
\[S_T(\rho) = \big\{|s_{i}^{(t)}\rangle: i\in\{1,\ldots, n\},\ t\in\{1,\ldots, T\} \big\}.\]</div>
<p>Each of the <span class="math notranslate nohighlight">\(|s_i^{(t)}\rangle\)</span> provides us with a snapshot of the
state <span class="math notranslate nohighlight">\(\rho\)</span>, and the <span class="math notranslate nohighlight">\(nT\)</span> measurements yield the complete
set <span class="math notranslate nohighlight">\(S_{T}\)</span>, which requires just <span class="math notranslate nohighlight">\(3nT\)</span> bits to be stored
in classical memory. This is discussed in further detail in our previous
demo about <a class="reference internal" href="tutorial_classical_shadows.html"><span class="doc">classical shadows</span></a>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/class_shadow_prep.png"><img alt="Preparing Classical Shadows" src="../_images/class_shadow_prep.png" style="width: 100%;" /></a>
</div>
<p>To prepare a classical shadow for the ground state of the Heisenberg
model, we simply reuse the circuit template used above and reconstruct
a <code class="docutils literal notranslate"><span class="pre">QNode</span></code> utilizing a device that performs single-shot measurements.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev_oshot</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit_oshot</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QNode</span></a><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">dev_oshot</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we define a function to build the classical shadow for the quantum
state prepared by a given <span class="math notranslate nohighlight">\(n\)</span>-qubit circuit using <span class="math notranslate nohighlight">\(T\)</span>-copies
of randomized Pauli basis measurements</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen_class_shadow</span><span class="p">(</span><span class="n">circ_template</span><span class="p">,</span> <span class="n">circuit_params</span><span class="p">,</span> <span class="n">num_shadows</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">):</span>
    <span class="c1"># prepare the complete set of available Pauli operators</span>
    <span class="n">unitary_ops</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">]</span>
    <span class="c1"># sample random Pauli measurements uniformly</span>
    <span class="n">unitary_ensmb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_shadows</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">outcomes</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_shadows</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_shadows</span><span class="p">):</span>
        <span class="c1"># for each snapshot, extract the Pauli basis measurement to be performed</span>
        <span class="n">meas_obs</span> <span class="o">=</span> <span class="p">[</span><span class="n">unitary_ops</span><span class="p">[</span><span class="n">unitary_ensmb</span><span class="p">[</span><span class="n">ns</span><span class="p">,</span> <span class="n">i</span><span class="p">]](</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)]</span>
        <span class="c1"># perform single shot randomized Pauli measuremnt for each qubit</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">outcomes</span></a><span class="p">[</span><span class="n">ns</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">circ_template</span><span class="p">(</span><span class="n">circuit_params</span><span class="p">,</span> <span class="n">observables</span><span class="o">=</span><span class="n">meas_obs</span><span class="p">)</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">outcomes</span></a><span class="p">,</span> <span class="n">unitary_ensmb</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">outcomes</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis</span></a> <span class="o">=</span> <span class="n">gen_class_shadow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit_oshot</span></a><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First five measurement outcomes =</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">outcomes</span></a><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First five measurement bases =</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis</span></a><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>First five measurement outcomes =
 [[ 1. -1.  1. -1.]
 [ 1. -1. -1.  1.]
 [-1.  1. -1.  1.]
 [-1. -1. -1.  1.]
 [ 1.  1. -1. -1.]]
First five measurement bases =
 [[2 2 0 0]
 [2 0 0 2]
 [2 2 0 2]
 [2 1 0 2]
 [1 2 0 2]]
</pre></div>
</div>
<p>Furthermore, <span class="math notranslate nohighlight">\(S_{T}\)</span> can be used to construct an approximation
of the underlying <span class="math notranslate nohighlight">\(n\)</span>-qubit state <span class="math notranslate nohighlight">\(\rho\)</span> by averaging over <span class="math notranslate nohighlight">\(\sigma_t\)</span>:</p>
<div class="math notranslate nohighlight">
\[\sigma_T(\rho) = \frac{1}{T} \sum_{1}^{T} \big(3|s_{1}^{(t)}\rangle\langle s_1^{(t)}| - \mathbb{I}\big)\otimes \ldots \otimes \big(3|s_{n}^{(t)}\rangle\langle s_n^{(t)}| - \mathbb{I}\big).\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">snapshot_state</span><span class="p">(</span><span class="n">meas_list</span><span class="p">,</span> <span class="n">obs_list</span><span class="p">):</span>
    <span class="c1"># undo the rotations done for performing Pauli measurements in the specific basis</span>
    <span class="n">rotations</span> <span class="o">=</span> <span class="p">[</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="c1"># X-basis</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">adjoint</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.S.html#pennylane.S" title="pennylane.S" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">S</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">))),</span> <span class="c1"># Y-basis</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Identity.html#pennylane.Identity" title="pennylane.Identity" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Identity</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="c1"># Z-basis</span>
    <span class="p">]</span>

    <span class="c1"># reconstruct snapshot from local Pauli measurements</span>
    <span class="n">rho_snapshot</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">meas_out</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis</span></a> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">meas_list</span><span class="p">,</span> <span class="n">obs_list</span><span class="p">):</span>
        <span class="c1"># preparing state |s_i&gt;&lt;s_i| using the post measurement outcome:</span>
        <span class="c1"># |0&gt;&lt;0| for 1 and |1&gt;&lt;1| for -1</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="k">if</span> <span class="n">meas_out</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="n">local_rho</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">rotations</span><span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis</span></a><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">state</span> <span class="o">@</span> <span class="n">rotations</span><span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis</span></a><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">rho_snapshot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">rho_snapshot</span><span class="p">,</span> <span class="n">local_rho</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rho_snapshot</span>

<span class="k">def</span> <span class="nf">shadow_state_reconst</span><span class="p">(</span><span class="n">shadow</span><span class="p">):</span>
    <span class="n">num_snapshots</span><span class="p">,</span> <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">meas_lists</span><span class="p">,</span> <span class="n">obs_lists</span> <span class="o">=</span> <span class="n">shadow</span>

    <span class="c1"># Reconstruct the quantum state from its classical shadow</span>
    <span class="n">shadow_rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="n">num_qubits</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">num_qubits</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_snapshots</span><span class="p">):</span>
        <span class="n">shadow_rho</span> <span class="o">+=</span> <span class="n">snapshot_state</span><span class="p">(</span><span class="n">meas_lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">obs_lists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">shadow_rho</span> <span class="o">/</span> <span class="n">num_snapshots</span>
</pre></div>
</div>
<p>To see how well the reconstruction works for different values of <span class="math notranslate nohighlight">\(T\)</span>,
we look at the <a class="reference external" href="https://en.wikipedia.org/wiki/Fidelity_of_quantum_states">fidelity</a>
of the actual quantum state with respect to the reconstructed quantum state from
the classical shadow with <span class="math notranslate nohighlight">\(T\)</span> copies. On average, as the number of copies
<span class="math notranslate nohighlight">\(T\)</span> is increased, the reconstruction becomes more effective with average
higher fidelity values (orange) and lower variance (blue). Eventually, in the
limit <span class="math notranslate nohighlight">\(T\rightarrow\infty\)</span>, the reconstruction will be exact.</p>
<div class="figure align-center" id="id6">
<a class="reference internal image-reference" href="../_images/fidel_snapshot.png"><img alt="Fidelity of reconstructed ground state with different shadow sizes :math:`T`" src="../_images/fidel_snapshot.png" style="width: 80%;" /></a>
<p class="caption"><span class="caption-text">Fidelity of the reconstructed ground state with different shadow sizes <span class="math notranslate nohighlight">\(T\)</span></span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>The reconstructed quantum state <span class="math notranslate nohighlight">\(\sigma_T\)</span> can also be used to
evaluate expectation values <span class="math notranslate nohighlight">\(\text{Tr}(O\sigma_T)\)</span> for some localized
observable <span class="math notranslate nohighlight">\(O = \bigotimes_{i}^{n} P_i\)</span>, where <span class="math notranslate nohighlight">\(P_i \in \{I, X, Y, Z\}\)</span>.
However, as shown above, <span class="math notranslate nohighlight">\(\sigma_T\)</span> would be only an approximation of
<span class="math notranslate nohighlight">\(\rho\)</span> for finite values of <span class="math notranslate nohighlight">\(T\)</span>. Therefore, to estimate
<span class="math notranslate nohighlight">\(\langle O \rangle\)</span> robustly, we use the median of means
estimation. For this purpose, we split up the <span class="math notranslate nohighlight">\(T\)</span> shadows into
<span class="math notranslate nohighlight">\(K\)</span> equally-sized groups and evaluate the median of the mean
value of <span class="math notranslate nohighlight">\(\langle O \rangle\)</span> for each of these groups.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">estimate_shadow_obs</span><span class="p">(</span><span class="n">shadow</span><span class="p">,</span> <span class="n">observable</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">shadow_size</span> <span class="o">=</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># convert Pennylane observables to indices</span>
    <span class="n">map_name_to_int</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;PauliX&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;PauliY&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;PauliZ&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observable</span><span class="p">,</span> <span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">)):</span>
        <span class="n">target_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_name_to_int</span><span class="p">[</span><span class="n">observable</span><span class="o">.</span><span class="n">name</span><span class="p">]])</span>
        <span class="n">target_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">observable</span><span class="o">.</span><span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_name_to_int</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observable</span><span class="o">.</span><span class="n">obs</span><span class="p">])</span>
        <span class="n">target_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observable</span><span class="o">.</span><span class="n">obs</span><span class="p">])</span>

    <span class="c1"># perform median of means to return the result</span>
    <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meas_list</span><span class="p">,</span> <span class="n">obs_lists</span> <span class="o">=</span> <span class="n">shadow</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shadow_size</span><span class="p">,</span> <span class="n">shadow_size</span> <span class="o">//</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">meas_list_k</span><span class="p">,</span> <span class="n">obs_lists_k</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">meas_list</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">shadow_size</span> <span class="o">//</span> <span class="n">k</span><span class="p">],</span>
            <span class="n">obs_lists</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">shadow_size</span> <span class="o">//</span> <span class="n">k</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">obs_lists_k</span><span class="p">[:,</span> <span class="n">target_locs</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">meas_list_k</span><span class="p">[</span><span class="n">indices</span><span class="p">][:,</span> <span class="n">target_locs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we estimate the correlation matrix <span class="math notranslate nohighlight">\(C^{\prime}\)</span> from the
classical shadow approximation of the ground state.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="n">corrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">coups</span><span class="p">]</span>
<span class="n">qbobs</span> <span class="o">=</span> <span class="p">[</span><span class="n">qob</span> <span class="k">for</span> <span class="n">qobs</span> <span class="ow">in</span> <span class="n">corrs</span> <span class="k">for</span> <span class="n">qob</span> <span class="ow">in</span> <span class="n">qobs</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">build_estim_corrmat</span><span class="p">(</span><span class="n">coups</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <span class="n">num_obs</span><span class="p">,</span> <span class="n">shadow</span><span class="p">):</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_obs</span><span class="p">))</span> <span class="c1"># group size</span>
    <span class="n">corr_mat_estim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coups</span><span class="p">):</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">corrs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">corr_mat_estim</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corr_mat_estim</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">estimate_shadow_obs</span><span class="p">(</span><span class="n">shadow</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">corr</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">3</span>
            <span class="p">)</span>
            <span class="n">corr_mat_estim</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_mat_estim</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">corr_mat_estim</span>

<span class="n">shadow</span> <span class="o">=</span> <span class="n">gen_class_shadow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit_oshot</span></a><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">expval_estmt</span></a> <span class="o">=</span> <span class="n">build_estim_corrmat</span><span class="p">(</span><span class="n">coups</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">qbobs</span><span class="p">),</span> <span class="n">shadow</span><span class="p">)</span>
</pre></div>
</div>
<p>This time, let us visualize the deviation observed between the exact correlation
matrix (<span class="math notranslate nohighlight">\(C\)</span>) and the estimated correlation matrix (<span class="math notranslate nohighlight">\(C^{\prime}\)</span>)
to assess the effectiveness of classical shadow formalism.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">expval_exact</span></a><span class="o">-</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">expval_estmt</span></a><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;RdBu&quot;</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Error in estimating the</span><span class="se">\n</span><span class="s2">correlation matrix&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="n">bar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>
<span class="n">bar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Delta C_</span><span class="si">{ij}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">bar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_ml_classical_shadows_003.png" srcset="../_images/sphx_glr_tutorial_ml_classical_shadows_003.png" alt="Error in estimating the correlation matrix" class = "sphx-glr-single-img"/></div>
<div class="section" id="training-classical-machine-learning-models">
<h2>Training Classical Machine Learning Models<a class="headerlink" href="#training-classical-machine-learning-models" title="Permalink to this headline">¶</a></h2>
<p>There are multiple ways in which we can combine classical shadows and
machine learning. This could include training a model to learn
the classical representation of quantum systems based on some system
parameter, estimating a property from such learned classical representations,
or a combination of both. In our case, we consider the problem of using
<a class="reference internal" href="tutorial_kernel_based_training.html"><span class="doc">kernel-based models</span></a> to learn the ground-state representation of the
Heisenberg model Hamiltonian <span class="math notranslate nohighlight">\(H(x_l)\)</span> from the coupling vector <span class="math notranslate nohighlight">\(x_l\)</span>,
where <span class="math notranslate nohighlight">\(x_l = [J_{i,j} \text{ for } i &lt; j]\)</span>. The goal is to predict the
correlation functions <span class="math notranslate nohighlight">\(C_{ij}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\big\{x_l \rightarrow \sigma_T(\rho(x_l)) \rightarrow \text{Tr}(\hat{C}_{ij} \sigma_T(\rho(x_l))) \big\}_{l=1}^{N}.\]</div>
<p>Here, we consider the following kernel-based machine learning model <a class="footnote-reference brackets" href="#neurtangkernel" id="id3">2</a>:</p>
<div class="math notranslate nohighlight">
\[\hat{\sigma}_{N} (x) = \sum_{l=1}^{N} \kappa(x, x_l)\sigma_T (x_l) = \sum_{l=1}^{N} \left(\sum_{l^{\prime}=1}^{N} k(x, x_{l^{\prime}})(K+\lambda I)^{-1}_{l, l^{\prime}} \sigma_T(x_l) \right),\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda &gt; 0\)</span> is a regularization parameter in cases when
<span class="math notranslate nohighlight">\(K\)</span> is not invertible, <span class="math notranslate nohighlight">\(\sigma_T(x_l)\)</span> denotes the classical
representation of the ground state <span class="math notranslate nohighlight">\(\rho(x_l)\)</span> of the Heisenberg
model constructed using <span class="math notranslate nohighlight">\(T\)</span> randomized Pauli measurements, and
<span class="math notranslate nohighlight">\(K_{ij}=k(x_i, x_j)\)</span> is the kernel matrix with
<span class="math notranslate nohighlight">\(k(x, x^{\prime})\)</span> as the kernel function.</p>
<p>Similarly, estimating an expectation value on the predicted ground state
<span class="math notranslate nohighlight">\(\sigma_T(x_l)\)</span> using the trained model can then be done by
evaluating:</p>
<div class="math notranslate nohighlight">
\[\text{Tr}(\hat{O} \hat{\sigma}_{N} (x)) = \sum_{l=1}^{N} \kappa(x, x_l)\text{Tr}(O\sigma_T (x_l)).\]</div>
<p>We train the classical kernel-based models using <span class="math notranslate nohighlight">\(N = 70\)</span>
randomly chosen values of the coupling matrices <span class="math notranslate nohighlight">\(J\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># imports for ML methods and techniques</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>
<span class="kn">from</span> <span class="nn">sklearn.kernel_ridge</span> <span class="kn">import</span> <span class="n">KernelRidge</span>
</pre></div>
</div>
<p>First, to build the dataset, we use the function <code class="docutils literal notranslate"><span class="pre">build_dataset</span></code> that
takes as input the size of the dataset (<code class="docutils literal notranslate"><span class="pre">num_points</span></code>), the topology of
the lattice (<code class="docutils literal notranslate"><span class="pre">Nr</span></code> and <code class="docutils literal notranslate"><span class="pre">Nc</span></code>), and the number of randomized
Pauli measurements (<span class="math notranslate nohighlight">\(T\)</span>) for the construction of classical shadows.
The <code class="docutils literal notranslate"><span class="pre">X_data</span></code> is the set of coupling vectors that are defined as a
stripped version of the coupling matrix <span class="math notranslate nohighlight">\(J\)</span>, where only non-duplicate
and non-zero <span class="math notranslate nohighlight">\(J_{ij}\)</span> are considered. The <code class="docutils literal notranslate"><span class="pre">y_exact</span></code> and
<code class="docutils literal notranslate"><span class="pre">y_clean</span></code> are the set of correlation vectors, i.e., the flattened
correlation matrix <span class="math notranslate nohighlight">\(C\)</span>, computed with respect to the ground-state
obtained from exact diagonalization and classical shadow representation
(with <span class="math notranslate nohighlight">\(T=500\)</span>), respectively.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_dataset</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">Nr</span><span class="p">,</span> <span class="n">Nc</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>

    <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">Nr</span> <span class="o">*</span> <span class="n">Nc</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_exact</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_estim</span></a> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">coupling_mats</span> <span class="o">=</span> <span class="n">build_coupling_mats</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">Nr</span><span class="p">,</span> <span class="n">Nc</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coupling_mat</span> <span class="ow">in</span> <span class="n">coupling_mats</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hamiltonian.html#pennylane.Hamiltonian" title="pennylane.Hamiltonian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham</span></a> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">coupling_mat</span><span class="p">)</span>
        <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hamiltonian.html#pennylane.Hamiltonian.sparse_matrix" title="pennylane.Hamiltonian.sparse_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">ham</span><span class="o">.</span><span class="n">sparse_matrix</span></a><span class="p">())</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)]</span>
        <span class="n">shadow</span> <span class="o">=</span> <span class="n">gen_class_shadow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit_oshot</span></a><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">num_qubits</span><span class="p">)</span>

        <span class="n">coups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">corrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">corr_function</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">coups</span><span class="p">]</span>
        <span class="n">qbobs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">corrs</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">expval_exact</span></a> <span class="o">=</span> <span class="n">build_exact_corrmat</span><span class="p">(</span><span class="n">coups</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">circuit_exact</span></a><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
        <span class="n">expval_estim</span> <span class="o">=</span> <span class="n">build_estim_corrmat</span><span class="p">(</span><span class="n">coups</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">qbobs</span><span class="p">),</span> <span class="n">shadow</span><span class="p">)</span>

        <span class="n">coupling_vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coup</span> <span class="ow">in</span> <span class="n">coupling_mat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">coup</span> <span class="ow">and</span> <span class="n">coup</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coupling_vec</span><span class="p">:</span>
                <span class="n">coupling_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coup</span><span class="p">)</span>
        <span class="n">coupling_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coupling_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coupling_vec</span><span class="p">)</span>

        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span><span class="o">.</span><span class="n">append</span></a><span class="p">(</span><span class="n">coupling_vec</span><span class="p">)</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_exact</span><span class="o">.</span><span class="n">append</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">expval_exact</span></a><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_estim</span><span class="o">.</span><span class="n">append</span></a><span class="p">(</span><span class="n">expval_estim</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_exact</span></a><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_estim</span></a><span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_exact</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_estim</span></a> <span class="o">=</span> <span class="n">build_dataset</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">Nr</span><span class="p">,</span> <span class="n">Nc</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X_data</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_data</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_estim</span></a>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X_data</span></a><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_data</span></a><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_exact</span></a><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>((100, 4), (100, 16), (100, 16))
</pre></div>
</div>
<p>Now that our dataset is ready, we can shift our focus to the ML models.
Here, we use two different Kernel functions: (i) Gaussian Kernel and
(ii) Neural Tangent Kernel. For both of them, we consider the
regularization parameter <span class="math notranslate nohighlight">\(\lambda\)</span> from the following set of values:</p>
<div class="math notranslate nohighlight">
\[\lambda = \left\{ 0.0025, 0.0125, 0.025, 0.05, 0.125, 0.25, 0.5, 1.0, 5.0, 10.0 \right\}.\]</div>
<p>Next, we define the kernel functions <span class="math notranslate nohighlight">\(k(x, x^{\prime})\)</span> for each
of the mentioned kernels:</p>
<div class="math notranslate nohighlight">
\[k(x, x^{\prime}) = e^{-\gamma||x - x^{\prime}||^{2}_{2}}. \tag{Gaussian Kernel}\]</div>
<p>For the Gaussian kernel, the hyperparameter
<span class="math notranslate nohighlight">\(\gamma = N^{2}/\sum_{i=1}^{N} \sum_{j=1}^{N} ||x_i-x_j||^{2}_{2} &gt; 0\)</span>
is chosen to be the inverse of the average Euclidean distance
<span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_j\)</span>. The kernel is implemented using the
radial-basis function (rbf) kernel in the <code class="docutils literal notranslate"><span class="pre">sklearn</span></code> library.</p>
<div class="math notranslate nohighlight">
\[k(x, x^{\prime}) = k^{\text{NTK}}(x, x^{\prime}). \tag{Neural Tangent Kernel}\]</div>
<p>The neural tangent kernel <span class="math notranslate nohighlight">\(k^{\text{NTK}}\)</span> used here is equivalent
to an infinite-width feed-forward neural network with four hidden
layers and that uses the rectified linear unit (ReLU) as the activation
function. This is implemented using the <code class="docutils literal notranslate"><span class="pre">neural_tangents</span></code> library.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">neural_tangents</span> <span class="kn">import</span> <span class="n">stax</span>
<span class="n">init_fn</span><span class="p">,</span> <span class="n">apply_fn</span><span class="p">,</span> <span class="n">kernel_fn</span> <span class="o">=</span> <span class="n">stax</span><span class="o">.</span><span class="n">serial</span><span class="p">(</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Relu</span><span class="p">(),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Relu</span><span class="p">(),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Relu</span><span class="p">(),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Relu</span><span class="p">(),</span>
    <span class="n">stax</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">kernel_NN</span> <span class="o">=</span> <span class="n">kernel_fn</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X_data</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X_data</span></a><span class="p">,</span> <span class="s2">&quot;ntk&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kernel_NN</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kernel_NN</span><span class="p">)):</span>
        <span class="n">kernel_NN</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">((</span><span class="n">kernel_NN</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">kernel_NN</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>For the above two defined kernel methods, we obtain the best learning
model by performing hyperparameter tuning using cross-validation for
the prediction task of each <span class="math notranslate nohighlight">\(C_{ij}\)</span>. For this purpose, we
implement the function <code class="docutils literal notranslate"><span class="pre">fit_predict_data</span></code>, which takes input as the
correlation function index <code class="docutils literal notranslate"><span class="pre">cij</span></code>, kernel matrix <code class="docutils literal notranslate"><span class="pre">kernel</span></code>, and internal
kernel mapping <code class="docutils literal notranslate"><span class="pre">opt</span></code> required by the kernel-based regression models
from the <code class="docutils literal notranslate"><span class="pre">sklearn</span></code> library.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>

<span class="k">def</span> <span class="nf">fit_predict_data</span><span class="p">(</span><span class="n">cij</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>

    <span class="c1"># training data (estimated from measurement data)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_estim</span></a><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cij</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X_data</span></a><span class="p">))])</span>
    <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
        <span class="n">kernel</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">24</span>
    <span class="p">)</span>

    <span class="c1"># testing data (exact expectation values)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_clean</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_exact</span></a><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cij</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X_data</span></a><span class="p">))])</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">y_test_clean</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_clean</span></a><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>

    <span class="c1"># hyperparameter tuning with cross validation</span>
    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># Epsilon-Support Vector Regression</span>
        <span class="p">(</span><span class="k">lambda</span> <span class="n">Cx</span><span class="p">:</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVR</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">opt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">Cx</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)),</span>
        <span class="c1"># Kernel-Ridge based Regression</span>
        <span class="p">(</span><span class="k">lambda</span> <span class="n">Cx</span><span class="p">:</span> <span class="n">KernelRidge</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">opt</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Cx</span><span class="p">))),</span>
    <span class="p">]</span>

    <span class="c1"># Regularization parameter</span>
    <span class="n">hyperparams</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0025</span><span class="p">,</span> <span class="mf">0.0125</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
    <span class="n">best_pred</span><span class="p">,</span> <span class="n">best_cv_score</span><span class="p">,</span> <span class="n">best_test_score</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">hyperparam</span> <span class="ow">in</span> <span class="n">hyperparams</span><span class="p">:</span>
            <span class="n">cv_score</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">cross_val_score</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">(</span><span class="n">hyperparam</span><span class="p">),</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                    <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_root_mean_squared_error&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">best_cv_score</span> <span class="o">&gt;</span> <span class="n">cv_score</span><span class="p">:</span>
                <span class="n">best_model</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">hyperparam</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
                <span class="n">best_pred</span> <span class="o">=</span> <span class="n">best_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
                <span class="n">best_cv_score</span> <span class="o">=</span> <span class="n">cv_score</span>
                <span class="n">best_test_score</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span>
                    <span class="n">best_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y_test_clean</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">best_pred</span><span class="p">,</span> <span class="n">y_test_clean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">best_cv_score</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">best_test_score</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>We perform the fitting and prediction for each <span class="math notranslate nohighlight">\(C_{ij}\)</span> and print
the output in a tabular format.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kernel_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Gaussian kernel&quot;</span><span class="p">,</span> <span class="s2">&quot;Neural Tangent kernel&quot;</span><span class="p">]</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">kernel_data</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_qubits</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel_list</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">y_predclean</span><span class="p">,</span> <span class="n">y_predicts1</span><span class="p">,</span> <span class="n">y_predicts2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">cij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">**</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">y_predict</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_clean</span></a><span class="p">,</span> <span class="n">cv_score</span><span class="p">,</span> <span class="n">test_score</span> <span class="o">=</span> <span class="n">fit_predict_data</span><span class="p">(</span><span class="n">cij</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X_data</span></a><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="s2">&quot;rbf&quot;</span><span class="p">)</span>
    <span class="n">y_predclean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_clean</span></a><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">kernel_data</span></a><span class="p">[</span><span class="n">cij</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv_score</span><span class="p">,</span> <span class="n">test_score</span><span class="p">)</span>
    <span class="n">y_predicts1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_predict</span><span class="p">)</span>
    <span class="n">y_predict</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y_clean</span></a><span class="p">,</span> <span class="n">cv_score</span><span class="p">,</span> <span class="n">test_score</span> <span class="o">=</span> <span class="n">fit_predict_data</span><span class="p">(</span><span class="n">cij</span><span class="p">,</span> <span class="n">kernel_NN</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">kernel_data</span></a><span class="p">[</span><span class="n">cij</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv_score</span><span class="p">,</span> <span class="n">test_score</span><span class="p">)</span>
    <span class="n">y_predicts2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_predict</span><span class="p">)</span>

<span class="c1"># For each C_ij print (best_cv_score, test_score) pair</span>
<span class="n">row_format</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:&gt;25}{:&gt;35}{:&gt;35}</span><span class="s2">&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">row_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;Correlation&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">kernel_list</span><span class="p">))</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">data</span></a> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">kernel_data</span></a><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="n">row_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> C_</span><span class="si">{</span><span class="n">idx</span><span class="o">//</span><span class="n">num_qubits</span><span class="si">}{</span><span class="n">idx</span><span class="o">%</span><span class="n">num_qubits</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2">| &quot;</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">data</span></a><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="nb">str</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">data</span></a><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Correlation                    Gaussian kernel              Neural Tangent kernel
   C_00   |                           [-0.  0.]                          [-0.  0.]
   C_01   |                   [0.09606 0.06424]                  [0.12163 0.07457]
   C_02   |                   [0.11482 0.05912]                  [0.12282 0.08256]
   C_03   |                   [0.09302 0.05405]                  [0.11818 0.05958]
   C_10   |                   [0.09606 0.06424]                  [0.12163 0.07457]
   C_11   |                           [-0.  0.]                          [-0.  0.]
   C_12   |                   [0.12182 0.03944]                  [0.12482 0.066  ]
   C_13   |                   [0.09993 0.06709]                  [0.11544 0.0794 ]
   C_20   |                   [0.11482 0.05912]                  [0.12282 0.08256]
   C_21   |                   [0.12182 0.03944]                  [0.12482 0.066  ]
   C_22   |                           [-0.  0.]                          [-0.  0.]
   C_23   |                   [0.1114  0.06528]                  [0.12207 0.06713]
   C_30   |                   [0.09302 0.05405]                  [0.11818 0.05958]
   C_31   |                   [0.09993 0.06709]                  [0.11544 0.0794 ]
   C_32   |                   [0.1114  0.06528]                  [0.12207 0.06713]
   C_33   |                           [-0.  0.]                          [-0.  0.]
</pre></div>
</div>
<p>Overall, we find that the models with the Gaussian kernel performed
better than those with NTK for predicting the expectation value
of the correlation function <span class="math notranslate nohighlight">\(C_{ij}\)</span> for the ground state of
the Heisenberg model. However, the best choice of <span class="math notranslate nohighlight">\(\lambda\)</span>
differed substantially across the different <span class="math notranslate nohighlight">\(C_{ij}\)</span> for both
kernels. We present the predicted correlation matrix <span class="math notranslate nohighlight">\(C^{\prime}\)</span>
for randomly selected Heisenberg models from the test set below for
comparison against the actual correlation matrix <span class="math notranslate nohighlight">\(C\)</span>, which is
obtained from the ground state found using exact diagonalization.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
<span class="n">corr_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_predclean</span><span class="p">,</span> <span class="n">y_predicts1</span><span class="p">,</span> <span class="n">y_predicts2</span><span class="p">]</span>
<span class="n">plt_plots</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>

<span class="n">cols</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;From </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Exact Diagonalization&quot;</span><span class="p">,</span> <span class="s2">&quot;Gaussian Kernel&quot;</span><span class="p">,</span> <span class="s2">&quot;Neur. Tang. Kernel&quot;</span><span class="p">]</span>
<span class="p">]</span>
<span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Model </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">plt_plots</span><span class="p">]</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cols</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rows</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>

<span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">corr_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">corr_vals</span><span class="p">):</span>
        <span class="n">shw</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corr_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">plt_plots</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Nr</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">,</span> <span class="n">Nr</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">),</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;RdBu&quot;</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nr</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nr</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">))</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">itr</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.86</span><span class="p">)</span>
<span class="n">cbar_ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">([</span><span class="mf">0.90</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.015</span><span class="p">,</span> <span class="mf">0.71</span><span class="p">])</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">shw</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cbar_ax</span><span class="p">)</span>

<span class="n">bar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$C_</span><span class="si">{ij}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">bar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_ml_classical_shadows_004.png" srcset="../_images/sphx_glr_tutorial_ml_classical_shadows_004.png" alt="From Exact Diagonalization, From Gaussian Kernel, From Neur. Tang. Kernel" class = "sphx-glr-single-img"/><p>Finally, we also attempt to showcase the effect of the size of training data
<span class="math notranslate nohighlight">\(N\)</span> and the number of Pauli measurements <span class="math notranslate nohighlight">\(T\)</span>. For this, we look
at the average root-mean-square error (RMSE) in prediction for each kernel
over all two-point correlation functions <span class="math notranslate nohighlight">\(C_{ij}\)</span>. Here, the first
plot looks at the different training sizes <span class="math notranslate nohighlight">\(N\)</span> with a fixed number of
randomized Pauli measurements <span class="math notranslate nohighlight">\(T=100\)</span>. In contrast, the second plot
looks at the different shadow sizes <span class="math notranslate nohighlight">\(T\)</span> with a fixed training data size
<span class="math notranslate nohighlight">\(N=70\)</span>. The performance improvement seems to be saturating after a
sufficient increase in <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(T\)</span> values for all two kernels
in both the cases.</p>
<a class="reference internal image-reference" href="../_images/rmse_training.png"><img alt="../_images/rmse_training.png" src="../_images/rmse_training.png" style="width: 47%;" /></a>
<a class="reference internal image-reference" href="../_images/rmse_shadow.png"><img alt="../_images/rmse_shadow.png" src="../_images/rmse_shadow.png" style="width: 47%;" /></a>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>This demo illustrates how classical machine learning models can benefit from
the classical shadow formalism for learning characteristics and predicting
the behavior of quantum systems. As argued in Ref. <a class="footnote-reference brackets" href="#preskill" id="id4">1</a>, this raises
the possibility that models trained on experimental or quantum data data can
effectively address quantum many-body problems that cannot be solved using
classical methods alone.</p>
</div>
<div class="section" id="references">
<span id="ml-classical-shadow-references"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="preskill"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id4">3</a>)</span></dt>
<dd><p>H. Y. Huang, R. Kueng, G. Torlai, V. V. Albert, J. Preskill, “Provably
efficient machine learning for quantum many-body problems”,
<a class="reference external" href="https://arxiv.org/abs/2106.12627">arXiv:2106.12627 [quant-ph]</a> (2021)</p>
</dd>
<dt class="label" id="neurtangkernel"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>A. Jacot, F. Gabriel, and C. Hongler. “Neural tangent kernel:
Convergence and generalization in neural networks”. <a class="reference external" href="https://proceedings.neurips.cc/paper/2018/file/5a4be1fa34e62bb8a6ec6b91d2462f5a-Paper.pdf">NeurIPS, 8571–8580</a> (2018)</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/utkarsh_azad.png" alt="Utkarsh Azad" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Utkarsh Azad</h4>
        <p class="bio-text__author-description">Utkarsh is a quantum software researcher at Xanadu, working on making quantum computing more useful and accessible, with a focus on exploring its applications in natural sciences. Whenever he's not tinkering with code, he will be walking miles searching either for fractals in nature or a cup of filter coffee.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 3 minutes  37.144 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-ml-classical-shadows-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/5aa2b140cc479b04f55b7872d7f302e1/tutorial_ml_classical_shadows.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_ml_classical_shadows.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/d06b83df467d602d032bada26de2019f/tutorial_ml_classical_shadows.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_ml_classical_shadows.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_ml_classical_shadows</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Machine learning for quantum many-body problems</a><ul class='current'>
<li class='current'><a class="reference internal" href="#building-the-2d-heisenberg-model">Building the 2D Heisenberg Model</a></li>
<li class='current'><a class="reference internal" href="#constructing-classical-shadows">Constructing Classical Shadows</a></li>
<li class='current'><a class="reference internal" href="#training-classical-machine-learning-models">Training Classical Machine Learning Models</a></li>
<li class='current'><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_ml_classical_shadows</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_qml.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="function_fitting_qsp.html" title="Function Fitting using Quantum Signal Processing"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_learning_from_experiments.html" title="Quantum advantage in learning from experiments"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_qml.html" >Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Machine learning for quantum many-body problems</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>