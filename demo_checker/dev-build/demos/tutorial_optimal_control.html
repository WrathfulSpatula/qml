
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Optimize pulse programs to obtain digital gates." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/thumbnail_tutorial_optimal_control.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Optimal control for gate compilation &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_optimal_control.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Optimize pulse programs to obtain digital gates." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Optimal control for gate compilation &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/xanadu.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_optimal_control.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Here comes the SU(N): multivariate quantum gates and gradients" href="tutorial_here_comes_the_sun.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_here_comes_the_sun.html" title="Here comes the SU(N): multivariate quantum gates and gradients"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_optimization.html" accesskey="U">Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Optimal control for gate compilation</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#sphx-glr-download-demos-tutorial-optimal-control-py"><span class="std std-ref">Go to the end</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="optimal-control-for-gate-compilation">
<span id="sphx-glr-demos-tutorial-optimal-control-py"></span><h1>Optimal control for gate compilation<a class="headerlink" href="#optimal-control-for-gate-compilation" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_pulse_programming101.html", "tutorial_neutral_atoms.html", "ahs_aquila.html"];
    var related_tutorials_titles = ['Introduction to pulse programming in PennyLane', 'Introduction to neutral atom quantum computers', 'Pulse programming on Rydberg atom hardware'];
</script></p>
<p>Today, quantum computations are largely phrased in the language of quantum circuits,
composed of digital quantum gates.
However, most quantum hardware does not come with such digital
gates as elementary native operations.
Instead, the hardware allows us to play sequences of analog electromagnetic pulses,
for example by shining laser pulses on trapped ions or Rydberg atoms, or by sending microwave
pulses onto superconducting qubit cavities.
These pulses need to be calibrated to produce the desired digital gates, and in
this tutorial we will be concerned with exactly this task.</p>
<p>For this, we will parametrize a pulse sequence, which leads to a whole <em>space</em>
of possible sequences. Then we optimize the pulse parameters in order to
find a configuration in this space that behaves as closely to the target gate
as possible.
More concretely, we will optimize simple pulse programs on two and three qubits to
obtain a CNOT and a Toffoli gate.
This training of control parameters to achieve a specific time
evolution is a standard task in the field of <em>quantum optimal control</em>.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference external image-reference" href="javascript:void(0);"><img alt="Illustration of a metal hand crafting a CNOT gate, using qubit systems" src="../_images/OptimalControl_control_quantum_systems.png" style="width: 100%;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For an introduction, see
<a class="reference internal" href="tutorial_pulse_programming101.html"><span class="doc">the demo on differentiable pulse programming</span></a>
in PennyLane.
Instead of optimizing pulses to yield digital quantum gates,
we may use them directly to solve optimization problems, as is also showcased in this
introductory demo. If you are interested in specific hardware pulses, take a look at
<a class="reference internal" href="tutorial_neutral_atoms.html"><span class="doc">an introduction to neutral-atom quantum computing</span></a>
or <a class="reference internal" href="ahs_aquila.html"><span class="doc">the tutorial on the QuEra Aquila device</span></a>, which treat pulse
programming with Rydberg atoms.</p>
<div class="section" id="quantum-optimal-control">
<h2>Quantum optimal control<a class="headerlink" href="#quantum-optimal-control" title="Permalink to this headline">¶</a></h2>
<p>The overarching goal of quantum optimal control is to find the best way to steer
a microscopical physical system such that its dynamics matches a desired behaviour.
The meaning of “best” and “desired behaviour” will depend on the specific
task, and it is important to specify the underlying assumptions and constraints on
the system controls in order to make the problem statement well-defined.
Once we specified all these details, optimal control theory is concerned with
questions like
“How close can the system get to modelling the desired behaviour?”,
“How can we find the best (sequence of) control parameters to obtain the desired behaviour?”,
or
“What is the shortest time in which the system can reach a specific state, given some
initial state?” (controlling at the so-called quantum speed limit) <a class="footnote-reference brackets" href="#canevamurphy09" id="id1">1</a>.</p>
<p>In this tutorial, we consider the control of few-qubit systems through pulse sequences,
with the goal to produce a given target, namely a digital gate, to the highest possible
precision.
To do this, we will choose an ansatz for the pulse sequence that contains
free parameters and define a profit function that quantifies the similarity between
the qubit operation and the target gate.
Then, we maximize this function by optimizing the pulse parameters until we
find the desired gate to a sufficient precision–or can no longer improve on the
approximation we found.
For the training phase, we will make use of fully-differentiable classical simulations
of the qubit dynamics, allowing us to make use of backpropagation – an efficient
differentiation technique widely used in machine learning – and gradient-based
optimization.
At the same time we attempt to find pulse shapes and control parameters that are
(to some degree) realistically feasible, including bounded
pulse amplitudes and rates of change of the amplitudes.</p>
<p>Tutorials that use other techniques are available, for example, for the
<a class="reference external" href="https://qutip.org/qutip-tutorials/#optimal-control">open-source quantum toolbox QuTiP</a>.</p>
</div>
<div class="section" id="gate-calibration-via-pulse-programming">
<h2>Gate calibration via pulse programming<a class="headerlink" href="#gate-calibration-via-pulse-programming" title="Permalink to this headline">¶</a></h2>
<p>Here, we briefly discuss the general setup of pulse programs that we will use for our
optimal control application. For more details, you may peruse the related
tutorials focusing on pulse programming.</p>
<p>Consider a quantum system comprised of <span class="math notranslate nohighlight">\(n\)</span> two-level systems, or qubits, described
by a Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H(\boldsymbol{p}, t) = H_d + \sum_{i=1}^K f_i(\boldsymbol{p_i}, t) H_i.\]</div>
<p>As we can see, <span class="math notranslate nohighlight">\(H\)</span> depends on the time <span class="math notranslate nohighlight">\(t\)</span> and on a set of control parameters
<span class="math notranslate nohighlight">\(\boldsymbol{p}\)</span>, which is composed of one parameter vector <span class="math notranslate nohighlight">\(\boldsymbol{p_i}\)</span>
per term. Both <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{p}\)</span>
feed into functions <span class="math notranslate nohighlight">\(f_i\)</span> that return scalar coefficients
for the (constant) Hamiltonian terms <span class="math notranslate nohighlight">\(H_i\)</span>. In addition, there is a constant drift
Hamiltonian <span class="math notranslate nohighlight">\(H_d\)</span>.
We will assume that the Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> fully describes the system of interest and,
in particular, we do not consider sources of noise in the system, such as leakage, dephasing,
or crosstalk, i.e. the accidental interaction with other parts of a larger, surrounding system.</p>
<p>The time evolution of the state of our quantum system will be described
by the Schrödinger equation associated with <span class="math notranslate nohighlight">\(H\)</span>.
However, for our purposes it will be more useful to consider the full unitary evolution that
the Hamiltonian causes, independently of the initial state. This way, we can compare it to
the digital target gate without iterating over different input and output states.
The Schrödinger equation dictates the behaviour of the evolution operator <span class="math notranslate nohighlight">\(U\)</span> to be</p>
<div class="math notranslate nohighlight">
\[\frac{d}{dt} U(\boldsymbol{p}, t) = -i H(\boldsymbol{p}, t) U(\boldsymbol{p}, t),\]</div>
<p>where we implicitly fixed the initial time of the evolution to <span class="math notranslate nohighlight">\(t_0=0\)</span>.
It is possible to simulate the dynamics of sufficiently small quantum systems on
a classical computer by solving the ordinary differential equation (ODE) above numerically.
For a fixed pulse duration <span class="math notranslate nohighlight">\(T\)</span> and given control parameters <span class="math notranslate nohighlight">\(\boldsymbol{p}\)</span>,
a numerical ODE solver computes the matrix <span class="math notranslate nohighlight">\(U(\boldsymbol{p}, T)\)</span>.</p>
<p>How can we tell whether the evolution of the qubit system is close to the digital gate
we aim to produce? We will need a measure of similarity, or fidelity.</p>
<p>In this tutorial we will describe the similarity of two unitary matrices <span class="math notranslate nohighlight">\(U\)</span> and
<span class="math notranslate nohighlight">\(V\)</span> on <span class="math notranslate nohighlight">\(n\)</span> qubits with a fidelity function:</p>
<div class="math notranslate nohighlight">
\[f(U,V) = \frac{1}{2^n}\big|\operatorname{tr}(U^\dagger V)\big|.\]</div>
<p>It is similar to an overlap measure obtained from the
<a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm">Frobenius norm</a>
but it allows us to ignore differences in the global phase.
Note that fidelity is often used to compare quantum states rather than gates,
and that noise often plays a role in this context. Here we only consider unitary
gates.</p>
<p>We can maximize the fidelity function above to train the pulse parameters. For this
purpose we write</p>
<div class="math notranslate nohighlight">
\[F(\boldsymbol{p}) \equiv f(U_\text{target}, U(\boldsymbol{p}, T)).\]</div>
<p>Here <span class="math notranslate nohighlight">\(U_\text{target}\)</span> is the unitary matrix of the gate that we want to compile.
We consider the total duration <span class="math notranslate nohighlight">\(T\)</span> as a fixed constraint to the optimization
problem and therefore we do not denote it as a free parameter of <span class="math notranslate nohighlight">\(F\)</span>.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference external image-reference" href="javascript:void(0);"><img alt="Illustration of a mountain with a path drawn from the ground to the peak, with markers for a pulse unitary and a CNOT gate" src="../_images/OptimalControl_distance.png" style="width: 100%;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>We can then maximize the fidelity <span class="math notranslate nohighlight">\(F\)</span>, for example, using gradient-based
optimization algorithms like Adam <a class="footnote-reference brackets" href="#kingmaba14" id="id2">2</a>.
But how do we obtain the gradient of a function that requires us to run an ODE solver
to obtain its value? We are in luck! The implementation of pulse programming in PennyLane is
fully differentiable via backpropagation thanks to its backend based on the machine
learning library <a class="reference external" href="https://jax.readthedocs.io/en/latest/">JAX</a>.
This enables us to optimize the gate sequences using efficiently computed gradients
(provided the target gate is not too large).</p>
<p>Before we climb mount fidelity for particular example gates, let’s briefly talk about
the pulse shape that we will use.</p>
</div>
<div class="section" id="smooth-rectangle-pulses">
<h2>Smooth rectangle pulses<a class="headerlink" href="#smooth-rectangle-pulses" title="Permalink to this headline">¶</a></h2>
<p>Let’s look at a building block that we will use a lot: smoothened rectangular pulses.
We start with a simple rectangular pulse</p>
<div class="math notranslate nohighlight">
\[R_\infty(t, (\Omega, t_0, t_1)) = \Omega \Theta(t-t_0) \Theta(t_1-t)\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega\)</span> is the amplitude, <span class="math notranslate nohighlight">\(t_0\)</span> and <span class="math notranslate nohighlight">\(t_1\)</span> are the start and end
times of the pulse, and <span class="math notranslate nohighlight">\(\Theta(t)\)</span> is the
<a class="reference external" href="https://en.wikipedia.org/wiki/Heaviside_step_function">Heaviside step function</a>
which is one for <span class="math notranslate nohighlight">\(t\geq 0\)</span> and zero otherwise.
The trainable parameters of this pulse are the amplitude and the start/end times.</p>
<p>There are two main issues with <span class="math notranslate nohighlight">\(R_\infty\)</span> for our purposes:</p>
<ol class="arabic simple">
<li><p>The Heaviside step function is not differentiable with respect
to the times <span class="math notranslate nohighlight">\(t_0\)</span> and <span class="math notranslate nohighlight">\(t_1\)</span> in the conventional sense (but
only if we were to consider distributions in addition to functions), and in
particular we cannot differentiate the resulting <span class="math notranslate nohighlight">\(U(\boldsymbol{p},T)\)</span>
within the automatic differentiation framework provided by JAX.</p></li>
<li><p>The instantaneous change in the amplitude will not be realizable in practice.
In reality, the pulses describe some electromagnetic control field that can only
be changed at a bounded rate and in a smooth manner. <span class="math notranslate nohighlight">\(R_\infty\)</span> is not
only not smooth, it is not even continuous. So we should consider smooth
pulses with a bounded rate of change instead.</p></li>
</ol>
<p>We can solve both these issues by smoothening the rectangular pulse:
We simply replace the step functions above by a smooth variant, namely by sigmoid functions:</p>
<div class="math notranslate nohighlight">
\[\begin{split}R_k(t, (\Omega, t_0, t_1)) &amp;= \Omega S(t-t_0, k) S(t_1-t, k)\\
S(t, k) &amp;= (1+\exp(-k t))^{-1}.\end{split}\]</div>
<p>We introduced an additional parameter, <span class="math notranslate nohighlight">\(k\)</span>, that controls the steepness of the sigmoid
functions and can be adapted to the constraints posed by hardware on the maximal rate of change.
In contrast to <span class="math notranslate nohighlight">\(R_\infty\)</span>, its sister <span class="math notranslate nohighlight">\(R_k\)</span> is smooth in all three arguments
<span class="math notranslate nohighlight">\(\Omega\)</span>, <span class="math notranslate nohighlight">\(t_0\)</span> and <span class="math notranslate nohighlight">\(t_1\)</span>, and training these three parameters with
automatic differentiation will not be a problem.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference external image-reference" href="javascript:void(0);"><img alt="Sketch of converting a rectangular pulse shape into a smoothened rectangular pulse shape" src="../_images/OptimalControl_Smoother_Rectangles.png" style="width: 100%;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Let’s implement the smooth rectangle function using JAX’s <code class="docutils literal notranslate"><span class="pre">numpy</span></code>. We
directly implement the product of the two sigmoids in the function <code class="docutils literal notranslate"><span class="pre">sigmoid_rectangle</span></code>:</p>
<div class="math notranslate nohighlight">
\[R_k(t, (\Omega, t_0, t_1), k)=
\Omega [1+\exp(-k (t-t_0))+\exp(-k (t_1-t))+\exp(-k(t_1-t_0))]^{-1}.\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>

<span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_enable_x64&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># Use float64 precision</span>
<span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_platform_name&quot;</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>  <span class="c1"># Disables a warning regarding device choice</span>


<span class="k">def</span> <span class="nf">sigmoid_rectangle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">t_0</span><span class="p">,</span> <span class="n">t_1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Smooth-rectangle pulse between t_0 and t_1, with amplitude Omega.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Omega</span> <span class="o">/</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">t_0</span><span class="p">))</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_1</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_1</span> <span class="o">-</span> <span class="n">t_0</span><span class="p">))</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Let’s look at a rectangular pulse and its smoothened sister, for a number of
different smoothness parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">t_0</span><span class="p">,</span> <span class="n">t_1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">)</span>
<span class="n">amplitude</span> <span class="o">=</span> <span class="mf">2.3</span>
<span class="n">ks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">rect</span> <span class="o">=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">heaviside</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">t_0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">heaviside</span><span class="p">(</span><span class="n">t_1</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">:</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">sigmoid_rectangle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">t_0</span><span class="p">,</span> <span class="n">t_1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Smooth rectangle $R_k$, $k=</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Rectangle $R_{</span><span class="se">\\</span><span class="s2">infty}$, $k</span><span class="se">\\</span><span class="s2">to</span><span class="se">\\</span><span class="s2">infty$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower center&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;time $t$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Pulse function&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_optimal_control_001.png" srcset="../_images/sphx_glr_tutorial_optimal_control_001.png" alt="tutorial optimal control" class = "sphx-glr-single-img"/><p>We see that for very large <span class="math notranslate nohighlight">\(k\)</span>, the smooth rectangle becomes practically
indistinguishable from the original rectangle function <span class="math notranslate nohighlight">\(R_\infty\)</span>. This means
that we can consider the smooth <span class="math notranslate nohighlight">\(R_k\)</span> a <em>generalization</em> of the pulse shape,
rather than a restriction.</p>
<p>In the examples below, we will use a pulse ansatz <span class="math notranslate nohighlight">\(S_k\)</span> that sums multiple smooth rectangles
<span class="math notranslate nohighlight">\(R_k\)</span> with the same value for <span class="math notranslate nohighlight">\(k\)</span> but individual start/end times
<span class="math notranslate nohighlight">\(t_{0/1}\)</span> and amplitudes <span class="math notranslate nohighlight">\(\Omega\)</span>.
With this nicely trainable pulse shape in our hands, we now turn to the first gate
calibration task.</p>
</div>
<div class="section" id="pulse-ansatz-for-cnot-calibration">
<h2>Pulse ansatz for CNOT calibration<a class="headerlink" href="#pulse-ansatz-for-cnot-calibration" title="Permalink to this headline">¶</a></h2>
<p>In this first example we will tune a two-qubit pulse to produce a standard CNOT gate.</p>
<p>We start by choosing a system Hamiltonian.
It contains the drift term <span class="math notranslate nohighlight">\(H_d = Z_0 + Z_1\)</span>, i.e. a Pauli <span class="math notranslate nohighlight">\(Z\)</span> operator
acting on each qubit, with a constant unit amplitude.
The parametrized part uses five generating terms: Pauli <span class="math notranslate nohighlight">\(Z\)</span> acting on the
first qubit (<span class="math notranslate nohighlight">\(Z_0\)</span>), all three Pauli operators acting on the second qubit
(<span class="math notranslate nohighlight">\(X_1, Y_1, Z_1\)</span>) and a single interaction term <span class="math notranslate nohighlight">\(Z_0X_1\)</span>, resembling an
abstract cross-resonance driving term. For all coefficient functions we choose
the same function, <span class="math notranslate nohighlight">\(f_i=S_k\ \forall i\)</span> (see the section above), but with distinct
parameters. That is, our Hamiltonian is</p>
<div class="math notranslate nohighlight">
\[H(\boldsymbol{p}, t) = \underset{H_d}{\underbrace{Z_0 + Z_1}}
+ S_k(\boldsymbol{p_1}, t) Z_0
+ S_k(\boldsymbol{p_2}, t) X_1
+ S_k(\boldsymbol{p_3}, t) Y_1
+ S_k(\boldsymbol{p_4}, t) Z_1
+ \underset{\text{interaction}}{\underbrace{S_k(\boldsymbol{p_5}, t) Z_0X_1}}\]</div>
<p>Due to this choice, the <span class="math notranslate nohighlight">\(Z_0\)</span> term
commutes with all other terms, including the drift term, and can be considered a
correction of the drive term to obtain the correct action on the first qubit.
Although the interaction term was chosen to resemble a typical interaction in a
superconducting cross resonance drive, this Hamiltonian remains a toy model.
Realistic hardware Hamiltonians may impose additional constraints or provide
fewer controls, and we do not consider the unit systems of such real-world systems
here.</p>
<p>The idea behind using the sum of smooth rectangles function for the parametrization
is the following:
Many methods in quantum optimal control work with discretized pulse shapes that keep
the pulse envelope constant for short time bins. This approach leads to a large number
of parameters that need to be trained, and it requires us to manually enforce that the
values do not differ by too much between neighbouring time bins.
The smooth rectangles introduced above have a limited rate of change by design, and
the number of parameters is much smaller than in generic discretization approaches.
Each coefficient function <span class="math notranslate nohighlight">\(S_k\)</span> sums <span class="math notranslate nohighlight">\(P\)</span> smooth rectangles
<span class="math notranslate nohighlight">\(R_k\)</span> with individual amplitudes and start and end times. Overall, this leads to
<span class="math notranslate nohighlight">\(n=5\cdot 3\cdot P=15P\)</span> parameters in <span class="math notranslate nohighlight">\(H\)</span>.
In this and the next example, we chose <span class="math notranslate nohighlight">\(P\)</span> heuristically.</p>
<p>Before we define this Hamiltonian, we implement the sum over multiple
<code class="docutils literal notranslate"><span class="pre">sigmoid_rectangle</span></code> functions, including two normalization steps.
First, we normalize the start and end times of the rectangles to the interval
<span class="math notranslate nohighlight">\([\epsilon, T-\epsilon]\)</span>, which makes sure that the pulse amplitudes are
close to zero at <span class="math notranslate nohighlight">\(t=0\)</span> and <span class="math notranslate nohighlight">\(t=T\)</span>. Without this step, we might be
tuning the pulses to be turned on (off) instantaneously at the beginning (end) of the
sequence, negating our effort on the pulse shape itself not to vary too quickly.
Second, we normalize the final output value to the interval
<span class="math notranslate nohighlight">\((-\Omega_\text{max}, \Omega_\text{max})\)</span>, which
allows us to bound the maximal amplitudes of the pulses to a realizable range while
maintaining differentiability.</p>
<p>For the normalization steps, we define a <code class="docutils literal notranslate"><span class="pre">sigmoid</span></code> and a <code class="docutils literal notranslate"><span class="pre">normalize</span></code> function.
The first is a straightforward implementation of <span class="math notranslate nohighlight">\(R_k\)</span> whereas the second
uses the <code class="docutils literal notranslate"><span class="pre">sigmoid</span></code> function to normalize real numbers to the interval <span class="math notranslate nohighlight">\((-1, 1)\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sigmoid function with steepness parameter k.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Smoothly normalize a real input value to the interval (-1, 1) using &#39;sigmoid&#39;</span>
<span class="sd">    with steepness parameter k.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>


<span class="k">def</span> <span class="nf">smooth_rectangles</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">max_amp</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the sum of P smooth-rectangle pulses and normalize their</span>
<span class="sd">    starting and ending times, as well as the total output amplitude.</span>

<span class="sd">    Args:</span>
<span class="sd">        params (tensor_like): Amplitudes and start and end times for the rectangles,</span>
<span class="sd">            in the order &#39;[amp_1, ... amp_P, t_{1, 0}, t_{1, 1}, ... t_{P, 0}, t_{P, 1}]&#39;.</span>
<span class="sd">        t (float): Time at which to evaluate the pulse function.</span>
<span class="sd">        k (float): Steepness of the sigmoid functions that delimit the rectangles</span>
<span class="sd">        max_amp (float): Maximal amplitude of the rectangles. The output will be normalized</span>
<span class="sd">            to the interval &#39;(-max_amp, max_amp)&#39;.</span>
<span class="sd">        eps (float): Margin to the beginning and end of the pulse sequence within which the</span>
<span class="sd">            start and end times of the individual rectangles need to lie.</span>
<span class="sd">        T (float): Total duration of the pulse.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of sum of smooth-rectangle pulses at &#39;t&#39; for the given parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="c1"># Split amplitudes from times</span>
    <span class="n">amps</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="p">[</span><span class="n">P</span><span class="p">])</span>
    <span class="c1"># Normalize times to be sufficiently far away from 0 and T</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">times</span> <span class="o">-</span> <span class="n">T</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span>
    <span class="c1"># Extract the start and end times of single rectangles</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="c1"># Sum products of sigmoids (unit rectangles), rescaled with the amplitudes</span>
    <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigmoid_rectangle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">amp</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span> <span class="n">times</span><span class="p">)]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rectangles</span><span class="p">]))</span>
    <span class="c1"># Normalize the output value to be in [-max_amp, max_amp] with standard steepness</span>
    <span class="k">return</span> <span class="n">max_amp</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s look at this function for some example parameters, with the same steepness
parameter <span class="math notranslate nohighlight">\(k=20\)</span> for all rectangles in the sum:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="n">T</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># Total pulse sequence time</span>
<span class="n">k</span> <span class="o">=</span> <span class="mf">20.0</span>  <span class="c1"># Steepness parameter</span>
<span class="n">max_amp</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Maximal amplitude \Omega_{max}</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">T</span>  <span class="c1"># Margin for the start/end times of the rectangles</span>
<span class="c1"># Bind hyperparameters to the smooth_rectangles function</span>
<span class="n">S_k</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth_rectangles</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">max_amp</span><span class="o">=</span><span class="n">max_amp</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>

<span class="c1"># Set some arbitrary amplitudes and times</span>
<span class="n">amps</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">])</span>  <span class="c1"># Four amplitudes</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">3.7</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">,</span> <span class="mf">5.9</span><span class="p">])</span>  <span class="c1"># Four pairs of start/end times</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">amps</span><span class="p">,</span> <span class="n">times</span><span class="p">])</span>  <span class="c1"># Amplitudes and times form the trainable parameters</span>

<span class="n">plot_times</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="n">plot_S_k</span> <span class="o">=</span> <span class="p">[</span><span class="n">S_k</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">plot_times</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plot_times</span><span class="p">,</span> <span class="n">plot_S_k</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Time t&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;Pulse function $S_k(p, t)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_optimal_control_002.png" srcset="../_images/sphx_glr_tutorial_optimal_control_002.png" alt="tutorial optimal control" class = "sphx-glr-single-img"/><p>Note that the rectangles are rather round for these generic parameters.
The optimized parameters in the training workflows below will lead to more
sharply defined pulses that resemble rectangles more closely. The amplitude normalization
step in <code class="docutils literal notranslate"><span class="pre">smooth_rectangles</span></code> enables us to produce them in a differentiable manner,
as was our goal with introducing <span class="math notranslate nohighlight">\(R_k\)</span>.
Also note that the normalization of the final output value is not a simple clipping
step, but again a smooth function. As a consequence, the amplitudes <code class="docutils literal notranslate"><span class="pre">1.9</span></code> and <code class="docutils literal notranslate"><span class="pre">-2.</span></code>
in the example above, which are not in the interval <code class="docutils literal notranslate"><span class="pre">[-1,</span> <span class="pre">1]</span></code>,
are not set to <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">-1</span></code> but take smaller absolute values.
Finally, also note that the start and end times of the smooth rectangles are being
normalized as well, in order to not end up too close to the boundaries of the
total time interval. While this makes the pulse times differ from the input times,
our pulse training will automatically consider this normalization step so that
it has no major consequences for us.</p>
<p>Using this function, we now may build the parametrized pulse Hamiltonian and the
fidelity function discussed above. We make use of just-in-time (JIT) compilation,
which will make the first execution of <code class="docutils literal notranslate"><span class="pre">profit</span></code> and <code class="docutils literal notranslate"><span class="pre">grad</span></code> slower, but speed
up the subsequent executions a lot. For optimization workflows of small-scale
functions, this almost always pays off.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Y</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a>

<span class="n">num_wires</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># Hamiltonian terms of the drift and parametrized parts of H</span>
<span class="n">ops_H_d</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">ops_param</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">X</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Y</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">X</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="c1"># Coefficients: 1 for drift Hamiltonian and smooth rectangles for parametrized part</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">S_k</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops_param</span><span class="p">]</span>
<span class="c1"># Build H</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pulse.ParametrizedHamiltonian.html#pennylane.pulse.ParametrizedHamiltonian" title="pennylane.pulse.ParametrizedHamiltonian" class="sphx-glr-backref-module-pennylane-pulse sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.dot.html#pennylane.dot" title="pennylane.dot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">dot</span></a><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">ops_H_d</span> <span class="o">+</span> <span class="n">ops_param</span><span class="p">)</span>
<span class="c1"># Set tolerances for the ODE solver</span>
<span class="n">atol</span> <span class="o">=</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span>

<span class="c1"># Target unitary is CNOT. We get its matrix and note that we do not need the dagger</span>
<span class="c1"># because CNOT is Hermitian.</span>
<span class="n">target</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="n">target_name</span> <span class="o">=</span> <span class="s2">&quot;CNOT&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Our target unitary is a </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2"> gate, with matrix</span><span class="se">\n</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pulse_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the unitary time evolution matrix of the pulse for given parameters.&quot;&quot;&quot;</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.evolve.html#pennylane.evolve" title="pennylane.evolve" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">evolve</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pulse.ParametrizedHamiltonian.html#pennylane.pulse.ParametrizedHamiltonian" title="pennylane.pulse.ParametrizedHamiltonian" class="sphx-glr-backref-module-pennylane-pulse sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)(</span><span class="n">params</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>


<span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
<span class="k">def</span> <span class="nf">profit</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the fidelity function for given parameters.&quot;&quot;&quot;</span>
    <span class="c1"># Compute the unitary time evolution of the pulse Hamiltonian</span>
    <span class="n">op_mat</span> <span class="o">=</span> <span class="n">pulse_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="c1"># Compute the fidelity between the target and the pulse evolution</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">op_mat</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_wires</span>


<span class="n">grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">profit</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Our target unitary is a CNOT gate, with matrix
[[1 0 0 0]
 [0 1 0 0]
 [0 0 0 1]
 [0 0 1 0]]
</pre></div>
</div>
<p>For the arbitrary parameters from above, of course we get a rather arbitrary unitary
time evolution, which does not match the CNOT at all:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops_param</span><span class="p">)</span>
<span class="n">arb_mat</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">pulse_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">arb_profit</span> <span class="o">=</span> <span class="n">profit</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;The arbitrarily chosen parameters yield the unitary</span><span class="se">\n</span><span class="si">{</span><span class="n">arb_mat</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;which has a fidelity of </span><span class="si">{</span><span class="n">arb_profit</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>The arbitrarily chosen parameters yield the unitary
[[-0.0315+0.2074j  0.967 +0.1442j  0.    +0.j      0.    +0.j    ]
 [ 0.6004+0.7717j -0.1653+0.1292j  0.    +0.j      0.    +0.j    ]
 [ 0.    +0.j      0.    +0.j      0.8553-0.1974j  0.4013+0.2618j]
 [ 0.    +0.j      0.    +0.j     -0.0311-0.4781j -0.5918+0.6482j]]
which has a fidelity of 0.052782.
</pre></div>
</div>
<p>Before we can start the optimization, we require initial parameters.
We set small alternating amplitudes and evenly distributed start and end times
for <span class="math notranslate nohighlight">\(P=3\)</span> smoothened rectangles. This choice leads to
a total of <span class="math notranslate nohighlight">\(15P=45\)</span> parameters in the pulse sequence.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Number of rectangles P</span>
<span class="c1"># Initial parameters for the start and end times of the rectangles</span>
<span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="n">T</span> <span class="o">-</span> <span class="n">eps</span><span class="p">,</span> <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops_param</span><span class="p">]</span>
<span class="c1"># All initial parameters: small alternating amplitudes and times</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="mf">0.1</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="p">)],</span> <span class="n">time</span><span class="p">])</span> <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">]</span>
</pre></div>
</div>
<p>Now we are all set up to train the parameters of the pulse sequence to produce
our target gate, the CNOT. We will use the Adam optimizer <a class="footnote-reference brackets" href="#kingmaba14" id="id3">2</a>, implemented in the
<a class="reference external" href="https://optax.readthedocs.io/en/latest/">optax</a>
library to our convenience. We keep track of the optimization via a list that contains
the parameters and fidelity values. Then we can plot the fidelity across the optimization.
As we will run a second optimization later on, we code up the optimizer run as a function.
This function will report on the optimization progress and duration, and it will plot
the trajectory of the profit function during the optimization.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">optax</span>


<span class="k">def</span> <span class="nf">run_adam</span><span class="p">(</span><span class="n">profit_fn</span><span class="p">,</span> <span class="n">grad_fn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">):</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
    <span class="c1"># Initialize the Adam optimizer</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="mf">0.97</span><span class="p">)</span>
    <span class="n">opt_state</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="c1"># Initialize a memory buffer for the optimization</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">profit_fn</span><span class="p">(</span><span class="n">params</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">grad_fn</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">updates</span><span class="p">,</span> <span class="n">opt_state</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">opt_state</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">updates</span><span class="p">)</span>
        <span class="n">hist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">params</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">profit_fn</span><span class="p">(</span><span class="n">params</span><span class="p">)])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_steps</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step </span><span class="si">{</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">c</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">profit_hist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">hist</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">profit_hist</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Iteration&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Fidelity $F(p)$&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The optimization took </span><span class="si">{</span><span class="n">end_time</span><span class="o">-</span><span class="n">start_time</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> (CPU) seconds.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hist</span>


<span class="n">learning_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.2</span>  <span class="c1"># negative learning rate leads to maximization</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">hist</span> <span class="o">=</span> <span class="n">run_adam</span><span class="p">(</span><span class="n">profit</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_optimal_control_003.png" srcset="../_images/sphx_glr_tutorial_optimal_control_003.png" alt="tutorial optimal control" class = "sphx-glr-single-img"/><div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Step   50: 0.993980
Step  100: 0.999696
Step  150: 0.999628
Step  200: 0.999854
Step  250: 0.999977
Step  300: 0.999995
Step  350: 0.999998
Step  400: 1.000000
Step  450: 1.000000
Step  500: 1.000000
The optimization took 36.8 (CPU) seconds.
</pre></div>
</div>
<p>As we can see, Adam steadily increases the fidelity, bringing the pulse program
closer and closer to the target unitary. On its way, the optimizer produces a mild
oscillating behaviour. The precision to which the optimization can produce the
target unitary depends on the expressivity of the pulses we use,
but also on the precision with which we run the ODE solver and the hyperparameters
of the optimizer.</p>
<p>Let’s pick those parameters with the largest fidelity we observed during
the training and take a look at the pulses we found. We again prepare a function
that plots the pulse sequence, which we can reuse later on.
For the single-qubit terms, we encode their qubit in the color and the type of Pauli
operator in the line style of the plotted line.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;#70CEFF&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;#C756B2&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;#FDC357&quot;</span><span class="p">}</span>
<span class="n">dashes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>


<span class="k">def</span> <span class="nf">plot_optimal_pulses</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">pulse_fn</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">target_name</span><span class="p">):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">profit_hist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">hist</span><span class="p">))</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hspace&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">},</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Pick optimal parameters from the buffer of all observed profit values</span>
    <span class="n">max_params</span><span class="p">,</span> <span class="n">max_profit</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">profit_hist</span><span class="p">))]</span>
    <span class="n">plot_times</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
    <span class="c1"># Iterate over pulse parameters and parametrized operators</span>
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">max_params</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="c1"># Create label, and pick correct axis</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Convert the label into a concise string. This differs depending on</span>
        <span class="c1"># whether the operator has a single or multiple Pauli terms. Pick the line style</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$</span><span class="si">{</span><span class="n">label</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">$&quot;</span>
            <span class="n">dash</span> <span class="o">=</span> <span class="n">dashes</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">wires</span><span class="p">,</span> <span class="n">label</span><span class="p">)])</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span>
            <span class="n">dash</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Set color according to qubit the term acts on</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">wires</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># Plot the pulse</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulse_fn</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">plot_times</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plot_times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">dashes</span><span class="o">=</span><span class="n">dash</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="c1"># Set legends and axis descriptions</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Single-qubit terms&quot;</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">))))</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Two-qubit terms&quot;</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">, Fidelity=</span><span class="si">{</span><span class="n">max_profit</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;Pulse function $f(p, t)$&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Time $t$&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;Pulse function $S_k(p, t)$&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">plot_optimal_pulses</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">S_k</span><span class="p">,</span> <span class="n">ops_param</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">target_name</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_optimal_control_004.png" srcset="../_images/sphx_glr_tutorial_optimal_control_004.png" alt="CNOT, Fidelity=1.000000" class = "sphx-glr-single-img"/><p>We observe that a single rectangular pulse is sufficient for some of the
generating terms in the Hamiltonian whereas others end up at rather intricate
pulse shapes. We see that their shape is closer to
actual rectangles now, in particular for those with a saturated amplitude.</p>
<p>The final fidelity tells us that we achieved our goal of finding a pulse
sequence that implements a unitary close to a CNOT gate.
It could be optimized further, for example by running the optimization for more
training iterations, by tuning the optimizer further to avoid oscillations,
or by increasing the precision with which we run the ODE solver.
This likely would also allow to reduce the total duration of the pulse.</p>
</div>
<div class="section" id="pulse-sequence-for-toffoli">
<h2>Pulse sequence for Toffoli<a class="headerlink" href="#pulse-sequence-for-toffoli" title="Permalink to this headline">¶</a></h2>
<p>The second example we consider is the compilation of a Toffoli–or CCNOT–gate.
We reuse most of the workflow from above and only change the pulse Hamiltonian as
well as a few hyperparameters.</p>
<p>In particular, the Hamiltonian uses the drift term <span class="math notranslate nohighlight">\(H_d=Z_0+Z_1+Z_2\)</span>
and the generators are all single-qubit Pauli operators on all three qubits, together
with the interaction generators <span class="math notranslate nohighlight">\(Z_0X_1, Z_1X_2, Z_2X_0\)</span>. Again,
all parametrized terms use the coefficient function <code class="docutils literal notranslate"><span class="pre">smooth_rectangles</span></code>.
We allow for a longer pulse duration of <span class="math notranslate nohighlight">\(3\pi\)</span> and five smooth rectangles in
each pulse shape.</p>
<p>In summary, we use nine single-qubit generators and three two-qubit generators, with
five rectangles in each pulse shape and each rectangle being given by an amplitude and
a start and end time. The pulse sequence thus has <span class="math notranslate nohighlight">\((9+3)\cdot 5\cdot 3=180\)</span>
parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_wires</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1"># New pulse hyperparameters</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># Longer total duration</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">T</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># More rectangles in sum: P=5</span>
<span class="n">S_k</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth_rectangles</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">max_amp</span><span class="o">=</span><span class="n">max_amp</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>

<span class="c1"># Hamiltonian terms of the drift and parametrized parts of H</span>
<span class="n">ops_H_d</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">ops_param</span> <span class="o">=</span> <span class="p">[</span><span class="n">pauli_op</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">pauli_op</span> <span class="ow">in</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Y</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_wires</span><span class="p">)]</span>
<span class="n">ops_param</span> <span class="o">+=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">X</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">X</span></a><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">Z</span></a><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">X</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>

<span class="c1"># Coefficients: 1. for drift Hamiltonian and smooth rectangles for parametrized part</span>
<span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">S_k</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops_param</span><span class="p">]</span>
<span class="c1"># Build H</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pulse.ParametrizedHamiltonian.html#pennylane.pulse.ParametrizedHamiltonian" title="pennylane.pulse.ParametrizedHamiltonian" class="sphx-glr-backref-module-pennylane-pulse sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.dot.html#pennylane.dot" title="pennylane.dot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">dot</span></a><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">ops_H_d</span> <span class="o">+</span> <span class="n">ops_param</span><span class="p">)</span>
<span class="c1"># Set tolerances for the ODE solver</span>
<span class="n">atol</span> <span class="o">=</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span>

<span class="c1"># Target unitary is Toffoli. We get its matrix and note that we do not need the dagger</span>
<span class="c1"># because Toffoli is Hermitian and unitary.</span>
<span class="n">target</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Toffoli.html#pennylane.Toffoli" title="pennylane.Toffoli" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Toffoli</span></a><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="n">target_name</span> <span class="o">=</span> <span class="s2">&quot;Toffoli&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Our target unitary is a </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2"> gate, with matrix</span><span class="se">\n</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pulse_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the unitary time evolution matrix of the pulse for given parameters.&quot;&quot;&quot;</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.evolve.html#pennylane.evolve" title="pennylane.evolve" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">evolve</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pulse.ParametrizedHamiltonian.html#pennylane.pulse.ParametrizedHamiltonian" title="pennylane.pulse.ParametrizedHamiltonian" class="sphx-glr-backref-module-pennylane-pulse sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)(</span><span class="n">params</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>


<span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
<span class="k">def</span> <span class="nf">profit</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the fidelity function for given parameters.&quot;&quot;&quot;</span>
    <span class="c1"># Compute the unitary time evolution of the pulse Hamiltonian</span>
    <span class="n">op_mat</span> <span class="o">=</span> <span class="n">pulse_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="c1"># Compute the fidelity between the target and the pulse evolution</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">op_mat</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_wires</span>


<span class="n">grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">profit</span><span class="p">))</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Our target unitary is a Toffoli gate, with matrix
[[1 0 0 0 0 0 0 0]
 [0 1 0 0 0 0 0 0]
 [0 0 1 0 0 0 0 0]
 [0 0 0 1 0 0 0 0]
 [0 0 0 0 1 0 0 0]
 [0 0 0 0 0 1 0 0]
 [0 0 0 0 0 0 0 1]
 [0 0 0 0 0 0 1 0]]
</pre></div>
</div>
<p>We create initial parameters similar to the above but allow for a larger number
of <span class="math notranslate nohighlight">\(1200\)</span> optimization steps and use a reduced learning rate (by absolute value)
in the optimization with Adam. Our <code class="docutils literal notranslate"><span class="pre">run_adam</span></code> function from above comes
in handy and also provides an overview of the optimization process in the
produced plot.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="n">T</span> <span class="o">-</span> <span class="n">eps</span><span class="p">,</span> <span class="n">P</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops_param</span><span class="p">]</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="p">)],</span> <span class="n">time</span><span class="p">])</span> <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">]</span>

<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">learning_rate</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2e-3</span>
<span class="n">hist</span> <span class="o">=</span> <span class="n">run_adam</span><span class="p">(</span><span class="n">profit</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">)</span>

<span class="n">params_hist</span><span class="p">,</span> <span class="n">profit_hist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">hist</span><span class="p">))</span>
<span class="n">max_params</span> <span class="o">=</span> <span class="n">params_hist</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">profit_hist</span><span class="p">))]</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_optimal_control_005.png" srcset="../_images/sphx_glr_tutorial_optimal_control_005.png" alt="tutorial optimal control" class = "sphx-glr-single-img"/><div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Step  120: 0.772116
Step  240: 0.827255
Step  360: 0.890429
Step  480: 0.930445
Step  600: 0.984312
Step  720: 0.995645
Step  840: 0.998453
Step  960: 0.999210
Step 1080: 0.999538
Step 1200: 0.999708
The optimization took 380.5 (CPU) seconds.
</pre></div>
</div>
<p>This looks promising: Adam maximized the fidelity successfully and we thus compiled
a pulse sequence that implements a Toffoli gate!
To inspect how close the compiled pulse sequence is to the Toffoli gate,
we can apply it to an exemplary quantum state, say <span class="math notranslate nohighlight">\(|110\rangle\)</span>,
and investigate the returned probabilities. A perfect Toffoli gate would
flip the third qubit, returning a probability of one in the last entry
and zeros elsewhere.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.devices.default_qubit_jax.DefaultQubitJax.html#pennylane.devices.default_qubit_jax.DefaultQubitJax" title="pennylane.devices.default_qubit_jax.DefaultQubitJax" class="sphx-glr-backref-module-pennylane-devices-default_qubit_jax sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">dev</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit.jax&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.devices.default_qubit_jax.DefaultQubitJax.html#pennylane.devices.default_qubit_jax.DefaultQubitJax" title="pennylane.devices.default_qubit_jax.DefaultQubitJax" class="sphx-glr-backref-module-pennylane-devices-default_qubit_jax sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">dev</span></a><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="c1"># Prepare |110&gt;</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Apply pulse sequence</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.evolve.html#pennylane.evolve" title="pennylane.evolve" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">evolve</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pulse.ParametrizedHamiltonian.html#pennylane.pulse.ParametrizedHamiltonian" title="pennylane.pulse.ParametrizedHamiltonian" class="sphx-glr-backref-module-pennylane-pulse sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)(</span><span class="n">params</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="c1"># Return quantum state</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.probs.html#pennylane.probs" title="pennylane.probs" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">probs</span></a><span class="p">()</span>


<span class="n">probs</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">node</span></a><span class="p">(</span><span class="n">max_params</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The state |110&gt; is mapped to the probability vector</span><span class="se">\n</span><span class="si">{</span><span class="n">jnp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>The state |110&gt; is mapped to the probability vector
[1.34000e-04 2.90000e-04 2.12000e-04 7.80000e-05 1.18000e-04 5.30000e-05
 1.10000e-05 9.99104e-01].
</pre></div>
</div>
<p>We see that the returned probabilities are close to the expected vector. The
last entry is close to one, the others are almost zero.
However, there are more possible inputs to the gate, and we hardly want to
stare at eight probability vectors to understand the quality of the compiled
pulse sequence. Instead, let’s plot the transition amplitudes with which our
compiled pulse sequence maps computational basis vectors to each other.
We include the complex phase of the amplitudes in the color of the bars.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>

<span class="n">dim</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">dim</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.27</span>  <span class="c1"># Input state indices</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">dim</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.36</span>  <span class="c1"># Output state indices</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">pulse_matrix</span><span class="p">(</span><span class="n">max_params</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># Pulse matrix, reshaped to be a sequence of values</span>
<span class="n">phases</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>  <span class="c1"># Complex phases</span>
<span class="n">color_norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">bar_colors</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">turbo</span><span class="p">(</span><span class="n">color_norm</span><span class="p">(</span><span class="n">phases</span><span class="p">))</span>
<span class="c1"># Barplot with x, y positions, bottom, width, depth and height values for bars</span>
<span class="n">ax</span><span class="o">.</span><span class="n">bar3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">shade</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">bar_colors</span><span class="p">)</span>
<span class="c1"># Specify a few visual attributes of the axes object</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
    <span class="n">xticks</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)),</span>
    <span class="n">yticks</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)),</span>
    <span class="n">xticklabels</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&gt;&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)],</span>
    <span class="n">yticklabels</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&gt;&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)],</span>
    <span class="n">zticks</span><span class="o">=</span><span class="p">[</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)],</span>
    <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Input state&quot;</span><span class="p">,</span>
    <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Output state&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># Add axes for the colorbar</span>
<span class="n">cax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">([</span><span class="mf">0.85</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.62</span><span class="p">])</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">turbo</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">color_norm</span><span class="p">)</span>
<span class="n">sc</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>
<span class="c1"># Plot colorbar</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_optimal_control_006.png" srcset="../_images/sphx_glr_tutorial_optimal_control_006.png" alt="tutorial optimal control" class = "sphx-glr-single-img"/><p>The transition amplitudes are as expected, except for very small deviations.
All computational basis states are mapped to themselves, but the last two are
swapped. The color of the entries close to one does not correspond to a phase
of zero. However, the fact that they have the same color tells us that this
deviation is a global phase, so that the pulse sequence is equivalent to
the Toffoli gate.
Let’s also look at the pulse sequence itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot_optimal_pulses</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">S_k</span><span class="p">,</span> <span class="n">ops_param</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">target_name</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_optimal_control_007.png" srcset="../_images/sphx_glr_tutorial_optimal_control_007.png" alt="Toffoli, Fidelity=0.999708" class = "sphx-glr-single-img"/><p>As we can see, the optimized smooth rectangles do not fill out the time at maximal
amplitudes. This means that we probably can find shorter pulse sequences with
larger amplitudes that produce a Toffoli with the
same fidelity. If you are interested, take a shot at it and try to
optimize the sequence with respect to the number of generators and pulse duration!</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>In this tutorial we calibrated a two-qubit and a three-qubit pulse sequence
to obtain a CNOT and a Toffoli gate, respectively. For this, we used smooth
rectangular pulse shapes together with toy pulse Hamiltonians, and obtained
very good approximations to the target gates.
Thanks to JAX, just-in-time (JIT) compiling and the PennyLane <code class="docutils literal notranslate"><span class="pre">pulse</span></code>
module, training the pulse sequences was simple to implement and fast to run.</p>
<p>There are many different techniques in quantum optimal control that can be
used to calibrate pulse sequences, some of which include gradient-based
training. A widely-used technique called GRAPE <a class="footnote-reference brackets" href="#khanejareiss05" id="id4">3</a>
makes use of discretized pulses, which leads to a large number of free parameters
to be optimized with gradient ascent.
The technique shown here reduces the parameter count significantly
and provides smooth, bounded shapes by definition.</p>
<p>Yet another method that does <em>not</em> use gradient-based optimization is
the chopped random-basis quantum optimization (CRAB) algorithm <a class="footnote-reference brackets" href="#doriacalarco11" id="id5">4</a>.
It uses a different parametrization altogether, exploiting randomized basis functions
for the pulse envelopes.</p>
<p>While setting up the application examples, we accommodated for
some requirements of realistic hardware, like smooth pulse shapes with bounded
maximal amplitudes and bounded rates of change, and we tried to use only few
interaction terms between qubits. However, it is important to note
that the shown optimization remains a toy model for calibration of
quantum hardware. We did not take into account the interaction terms
or pulse shapes available on realistic devices and their control electronics.
We also did not consider a unit system tied to real devices, and we
ignored noise, which plays a very important role in today’s quantum devices
and in quantum optimal control.
We leave the extension to real-world pulse Hamiltonians and noisy systems
to a future tutorial–or maybe your work?</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="canevamurphy09"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>T. Caneva, M. Murphy, T. Calarco, R. Fazio, S. Montangero, V. Giovannetti and G. Santoro
“Optimal Control at the Quantum Speed Limit”
<a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.240501">Phys. Rev. Lett. 103, 240501</a>,
<a class="reference external" href="https://arxiv.org/abs/0902.4193">arxiv:0902.4193</a>, 2009</p>
</dd>
<dt class="label" id="kingmaba14"><span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>D. Kingma and J. Ba
“Adam: A method for Stochastic Optimization”
<a class="reference external" href="https://arxiv.org/abs/1412.6980">arxiv:1412.6980</a>, 2014</p>
</dd>
<dt class="label" id="khanejareiss05"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>N. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbrüggen, S.J. Glaser
“Optimal Control of Coupled Spin Dynamics:
Design of NMR Pulse Sequences by Gradient Ascent Algorithms”
<a class="reference external" href="https://www.ch.nat.tum.de/fileadmin/w00bzu/ocnmr/pdf/94_GRAPE_JMR_05_.pdf">J. Magn. Reson. 172, 296-305</a>,
2005</p>
</dd>
<dt class="label" id="doriacalarco11"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>P. Doria, T. Calarco and S. Montangero
“Optimal Control Technique for Many-Body Quantum Dynamics”
<a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.106.190501">Phys. Rev. Lett. 106, 190501</a>,
<a class="reference external" href="https://arxiv.org/abs/1003.3750">arxiv:1003.3750</a>, 2011</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/david_wierichs.jpg" alt="David Wierichs" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">David Wierichs</h4>
        <p class="bio-text__author-description">David is a researcher and quantum software developer at Xanadu, who likes to think about quantum gradients and how to use them in variational quantum algorithms. He enjoys sharing ideas in science and open source software and likes implementing cool stuff in PennyLane.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 8 minutes  30.262 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-optimal-control-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/822d743ac82c1c45fac4cb44c777c41c/tutorial_optimal_control.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_optimal_control.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/bfd59b155573601faef6de250a31d66e/tutorial_optimal_control.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_optimal_control.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_optimal_control</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Optimal control for gate compilation</a><ul class='current'>
<li class='current'><a class="reference internal" href="#quantum-optimal-control">Quantum optimal control</a></li>
<li class='current'><a class="reference internal" href="#gate-calibration-via-pulse-programming">Gate calibration via pulse programming</a></li>
<li class='current'><a class="reference internal" href="#smooth-rectangle-pulses">Smooth rectangle pulses</a></li>
<li class='current'><a class="reference internal" href="#pulse-ansatz-for-cnot-calibration">Pulse ansatz for CNOT calibration</a></li>
<li class='current'><a class="reference internal" href="#pulse-sequence-for-toffoli">Pulse sequence for Toffoli</a></li>
<li class='current'><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_optimal_control</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_optimization.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_here_comes_the_sun.html" title="Here comes the SU(N): multivariate quantum gates and gradients"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_optimization.html" >Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Optimal control for gate compilation</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>