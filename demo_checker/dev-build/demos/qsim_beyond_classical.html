
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Use Google's qsim simulator to explore the barriers between quantum and classical computing, and recreate their benchmarks and circuits." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/sycamore.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Beyond classical computing with qsim &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/qsim_beyond_classical.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Use Google's qsim simulator to explore the barriers between quantum and classical computing, and recreate their benchmarks and circuits." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Beyond classical computing with qsim &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/qsim_beyond_classical.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quantum advantage with Gaussian Boson Sampling" href="gbs.html" />
    <link rel="prev" title="Quantum computation with neutral atoms" href="tutorial_pasqal.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="gbs.html" title="Quantum advantage with Gaussian Boson Sampling"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_pasqal.html" title="Quantum computation with neutral atoms"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" accesskey="U">Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Beyond classical computing with qsim</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-qsim-beyond-classical-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="beyond-classical-computing-with-qsim">
<span id="qsim-beyond-classical"></span><span id="sphx-glr-demos-qsim-beyond-classical-py"></span><h1>Beyond classical computing with qsim<a class="headerlink" href="#beyond-classical-computing-with-qsim" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_quantum_metrology.html", "tutorial_noisy_circuit_optimization.html", "quantum_volume.html"];
    var related_tutorials_titles = ['Variationally optimizing measurement protocols', 'Optimizing noisy circuits with Cirq', 'Quantum volume'];
</script></p>
<p><em>Author: Theodor Isacsson — Posted: 30 November 2020. Last updated: 10 September 2021.</em></p>
<div class="figure align-right">
<a class="reference internal image-reference" href="../_images/qc.png"><img alt="../_images/qc.png" src="../_images/qc.png" style="height: 300pt;" /></a>
</div>
<p>In the paper <a class="reference external" href="https://www.nature.com/articles/s41586-019-1666-5">Quantum supremacy using a programmable superconducting
processor</a>, the
Google AI Quantum team and collaborators showed that the Sycamore quantum processor could
complete a task that would take a classical computer potentially thousands
of years. They faced their quantum chip off against JEWEL—one of the
world’s most powerful supercomputers—using a classical statevector simulator called
<a class="reference external" href="https://github.com/quantumlib/qsim">qsim</a>. The main idea behind this
showdown was to prove that a quantum device could solve a specific task
that no classical method could do in a reasonable amount of time.</p>
<p>For the face-off, a pseudo-random quantum circuit was constructed by alternating
single-qubit and two-qubit gates in a specific, semi-random pattern. This
procedure gives a random unitary transformation which is
compatible with the Sycamore hardware. The circuit output is
measured many times, producing a set of sampled bitstrings.
The more qubits there are, and the deeper the circuit is, the more difficult
it becomes to simulate and sample this
bitstring distribution classically. By comparing run-times for the
classical simulations and the Sycamore chip
on smaller circuits, and then extrapolating classical run-times for larger
circuits, the team concluded that simulating larger circuits on Sycamore
was intractable classically—i.e., the Sycamore chips had demonstrated
what is called “quantum supremacy”.</p>
<p>In this demonstration, we will walk you through how their random quantum
circuits were constructed, how the performance was measured via
cross-entropy benchmarks, and provide reusable examples of their classical
simulations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We will be using PennyLane along with the aformentioned
<code class="docutils literal notranslate"><span class="pre">qsim</span></code> simulator running via our <a class="reference external" href="https://pennylane-cirq.readthedocs.io/en/latest/">PennyLane-Cirq plugin</a>. To use the <code class="docutils literal notranslate"><span class="pre">qsim</span></code>
device you also need to install <code class="docutils literal notranslate"><span class="pre">qsimcirq</span></code>, which is the Python module
interfacing the <code class="docutils literal notranslate"><span class="pre">qsim</span></code> simulator with Cirq.</p>
</div>
<div class="section" id="preparations">
<h2>Preparations<a class="headerlink" href="#preparations" title="Permalink to this headline">¶</a></h2>
<p>As always, we begin by importing the necessary modules. We will use
PennyLane, along with some PennyLane-Cirq specific operations, as well as
Cirq.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane_cirq</span> <span class="kn">import</span> <span class="n">ops</span>

<span class="kn">import</span> <span class="nn">cirq</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>To start, we need to define the qubit grid that we will use for mimicking
Google’s Sycamore chip, although we will only use 12 qubits instead of
the 54 that the actual chip has. This is so that you can run
this demo without having access to a supercomputer!</p>
<p>We define the 12 qubits in a rectangular grid, setting the coordinates for
each qubit following the paper’s suplementary dataset <a class="footnote-reference brackets" href="#martinis2020" id="id1">3</a>. We also create
a mapping between the wire number and the Cirq qubit to more easily reference
specific qubits later. Feel free to play around with different grids and
number of qubits. Just keep in mind that the grid needs to stay
connected. You could, for example, remove the final row (last four qubits
in the list) to simulate an 8-qubit system.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="n">cirq</span><span class="o">.</span><span class="n">GridQubit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
<span class="p">])</span>

<span class="n">wires</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="c1"># create a mapping between wire number and Cirq qubit</span>
<span class="n">qb2wire</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">wires</span><span class="p">))}</span>
</pre></div>
</div>
<p>Now let’s create the <code class="docutils literal notranslate"><span class="pre">qsim</span></code> device, available via the Cirq plugin, making
use of the <code class="docutils literal notranslate"><span class="pre">wires</span></code> and <code class="docutils literal notranslate"><span class="pre">qubits</span></code> keywords that we defined above.
First, we need to define the number of ‘shots’ per circuit instance to
be used—where the number of shots simply corresponds to the number
of times that the circuit is sampled. This will also be needed later when
calculating the cross-entropy benchmarking fidelity. The more shots, the
more accurate the results will be. 500,000 shots will be used here—the same
number of samples used in the paper—but feel free to
change this (depending on your own computational restrictions).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shots</span> <span class="o">=</span> <span class="mi">500000</span>
<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s1">&#39;cirq.qsim&#39;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span><span class="p">,</span> <span class="n">qubits</span><span class="o">=</span><span class="n">qubits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step would be to prepare the necessary gates. Some of these
gates are not natively supported in PennyLane, but are accessible
through the Cirq plugin. We can define the remaining gates by hand.</p>
<p>For the single-qubit gates we need the <span class="math notranslate nohighlight">\(\sqrt{X}\)</span> and
<span class="math notranslate nohighlight">\(\sqrt{Y}\)</span> gates, which can be written as <span class="math notranslate nohighlight">\(RX(\pi/2)\)</span> and
<span class="math notranslate nohighlight">\(RY(\pi/2)\)</span> respectively, as well as the <span class="math notranslate nohighlight">\(\sqrt{W}\)</span> gate,
where <span class="math notranslate nohighlight">\(W = \frac{X + Y}{2}\)</span>. The latter is easiest defined by its
unitary matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{\sqrt{2}}
\begin{bmatrix}
   1 &amp; \sqrt{i}  \\
   \sqrt{-i} &amp; 1 \\
\end{bmatrix}.\end{split}\]</div>
<p>The <span class="math notranslate nohighlight">\(\sqrt{X}\)</span> gate is already implemented in PennyLane, while the
two other gates can be implemented as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sqrtYgate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">wires</span><span class="p">:</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span><span class="p">)</span>

<span class="n">sqrtWgate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">wires</span><span class="p">:</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)],</span>
              <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span>
<span class="p">)</span>

<span class="n">single_qubit_gates</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SX.html#pennylane.SX" title="pennylane.SX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">SX</span></a><span class="p">,</span> <span class="n">sqrtYgate</span><span class="p">,</span> <span class="n">sqrtWgate</span><span class="p">]</span>
</pre></div>
</div>
<p>For the two-qubit gates we need the iSWAP gate</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
   1 &amp; 0 &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; i &amp; 0 \\
   0 &amp; i &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix},\end{split}\]</div>
<p>as well as the CPhase gate</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
   1 &amp; 0 &amp; 0 &amp; 0 \\
   0 &amp; 1 &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; 1 &amp; 0 \\
   0 &amp; 0 &amp; 0 &amp; e^{-i\phi}
\end{bmatrix},\end{split}\]</div>
<p>both accessible via the Cirq plugin.</p>
</div>
<div class="section" id="assembling-the-circuit">
<h2>Assembling the circuit<a class="headerlink" href="#assembling-the-circuit" title="Permalink to this headline">¶</a></h2>
<p>Here comes one of the tricky parts. To decide which qubits the
two-qubit gates should be applied to, we have to look at how they are
connected to each other. In an alternating pattern, each pair of
neighbouring qubits gets labeled with a letter A-D, where A and B
correspond to all horizontally neighbouring qubits (in a row), and C and
D to the vertically neighbouring qubits (in a column). This is depicted
in the figure below, where you can also see how the single-qubit gates
are applied, as well as the cycles, each consisting of a layer of
single-qubit gates and a pair of two-qubit gates. Note that each coloured
two-qubit gate represented in the image is implemented as the two
consecutive gates iSWAP and CPhase in this demo.</p>
<div class="figure align-center" id="id8">
<a class="reference internal image-reference" href="../_images/supremacy_circuit.png"><img alt="../_images/supremacy_circuit.png" src="../_images/supremacy_circuit.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><strong>Image taken from Arute, F., Arya, K., Babbush, R. et al.</strong> <a class="footnote-reference brackets" href="#arute2019" id="id2">1</a></span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>The logic below iterates through all connections and returns a
dictionary, <code class="docutils literal notranslate"><span class="pre">gate_order</span></code>, where the keys are the connection labels
between different qubits and the values are lists of all neighbouring
qubit pairs. We will use this dictionary inside the circuit to iterate
through the different pairs and apply the two two-qubit gates that we
just defined above. The way we iterate through the dictionary will depend
on a gate sequence defined in the next section.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="n">gate_order</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:[],</span> <span class="s2">&quot;B&quot;</span><span class="p">:[],</span> <span class="s2">&quot;C&quot;</span><span class="p">:[],</span> <span class="s2">&quot;D&quot;</span><span class="p">:[]}</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">wire_1</span> <span class="o">=</span> <span class="n">qb2wire</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">wire_2</span> <span class="o">=</span> <span class="n">qb2wire</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">j</span><span class="o">.</span><span class="n">neighbors</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">row</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">col</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gate_order</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wire_1</span><span class="p">,</span> <span class="n">wire_2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">i</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">row</span> <span class="ow">and</span> <span class="n">j</span><span class="o">.</span><span class="n">col</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gate_order</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wire_1</span><span class="p">,</span> <span class="n">wire_2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">i</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">col</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gate_order</span><span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wire_1</span><span class="p">,</span> <span class="n">wire_2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">i</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">col</span> <span class="ow">and</span> <span class="n">j</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gate_order</span><span class="p">[</span><span class="s2">&quot;D&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wire_1</span><span class="p">,</span> <span class="n">wire_2</span><span class="p">))</span>
</pre></div>
</div>
<p>At this point we can define the gate sequence, which is the order the
two-qubit gates are applied to the different qubit pairs. For example,
<code class="docutils literal notranslate"><span class="pre">[&quot;A&quot;,</span> <span class="pre">&quot;B&quot;]</span></code> would mean that the two-qubit gates are first applied to
all qubits connected with label A, and then, during the next full cycle,
the two-qubit gates are applied to all qubits connected with label B.
This would then correspond to a 2-cycle run (or a circuit with a depth of
2).</p>
<p>While we can define any patterns we’d like, the two gate sequences below
are the ones that are used in the paper. The shorter one is
used for their classically verifiable benchmarking. The slightly
longer sequence, which is much harder to simulate classically, is used
for estimating the cross-entropy fidelity in what they call the “supremacy
regime”. We will use the shorter gate sequence for the following
demonstration; feel free to play around with other combinations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="mi">14</span>  <span class="c1"># number of cycles</span>

<span class="n">gate_sequence_longer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
<span class="n">gate_sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>The single-qubit gates are randomly selected and applied to each qubit in
the circuit, while avoiding the same gate being applied to the same wire
twice in a row. We do this by creating a helper function <code class="docutils literal notranslate"><span class="pre">generate_single_qubit_gate_list()</span></code> that
specifies the order in which the single-qubit
gates should be applied. We can use this list within the
circuit to know which gate to apply when.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_single_qubit_gate_list</span><span class="p">():</span>
    <span class="c1"># create the first list by randomly selecting indices</span>
    <span class="c1"># from single_qubit_gates</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_qubit_gates</span><span class="p">)),</span> <span class="n">size</span><span class="o">=</span><span class="n">wires</span><span class="p">))]</span>

    <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gate_sequence</span><span class="p">)):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wires</span><span class="p">):</span>
            <span class="c1"># check which gate was applied to the wire previously</span>
            <span class="n">one_gate_removed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_qubit_gates</span><span class="p">)))</span>
            <span class="n">bool_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">one_gate_removed</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="p">[</span><span class="n">cycle</span><span class="p">][</span><span class="n">w</span><span class="p">]</span>

            <span class="c1"># and remove it from the choices of gates to be applied</span>
            <span class="n">pop_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bool_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">one_gate_removed</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pop_idx</span><span class="p">)</span>
            <span class="n">g</span><span class="p">[</span><span class="n">cycle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">one_gate_removed</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">g</span>
</pre></div>
</div>
<p>Finally, we can define the circuit itself and create a QNode that we will
use for circuit evaluation with the <code class="docutils literal notranslate"><span class="pre">qsim</span></code> device. The two-qubit gates
are applied to the qubits connected by A, B, C, or D as defined above.
The circuit ends with a half-cycle, consisting of only a layer of
single-qubit gates.</p>
<p>From the QNode, we need both the probabilities of the measurement
results, as well as raw samples. To facilitate this, we add a keyword
argument to our circuit allowing us to switch between the two returns. We
take samples from the computational basis state using all wires, which will return bitstrings of
values <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span>, corresponding to the states
<span class="math notranslate nohighlight">\(\left|0\right&gt;\)</span> and <span class="math notranslate nohighlight">\(\left|1\right&gt;\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">gate_idx</span> <span class="o">=</span> <span class="n">generate_single_qubit_gate_list</span><span class="p">()</span>

    <span class="c1"># m full cycles - single-qubit gates &amp; two-qubit gate</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gate_sequence</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wires</span><span class="p">):</span>
            <span class="n">single_qubit_gates</span><span class="p">[</span><span class="n">gate_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">w</span><span class="p">]](</span><span class="n">wires</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qb_1</span><span class="p">,</span> <span class="n">qb_2</span> <span class="ow">in</span> <span class="n">gate_order</span><span class="p">[</span><span class="n">gs</span><span class="p">]:</span>
            <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.ISWAP.html#pennylane.ISWAP" title="pennylane.ISWAP" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">ISWAP</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">(</span><span class="n">qb_1</span><span class="p">,</span> <span class="n">qb_2</span><span class="p">))</span>
            <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CPhase.html#pennylane.CPhase" title="pennylane.CPhase" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">qml</span><span class="o">.</span><span class="n">CPhase</span></a><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">(</span><span class="n">qb_1</span><span class="p">,</span> <span class="n">qb_2</span><span class="p">))</span>

    <span class="c1"># one half-cycle - single-qubit gates only</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wires</span><span class="p">):</span>
        <span class="n">single_qubit_gates</span><span class="p">[</span><span class="n">gate_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">w</span><span class="p">]](</span><span class="n">wires</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_probs</span><span class="p">:</span>
        <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.probs.html#pennylane.probs" title="pennylane.probs" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">probs</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">wires</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.sample.html#pennylane.sample" title="pennylane.sample" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">sample</span></a><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="the-cross-entropy-benchmarking-fidelity">
<h2>The cross-entropy benchmarking fidelity<a class="headerlink" href="#the-cross-entropy-benchmarking-fidelity" title="Permalink to this headline">¶</a></h2>
<p>The performance metric that is used in the experiment, and the one that we
will use in this demo, is called the linear cross-entropy benchmarking
fidelity. It’s defined as</p>
<div class="math notranslate nohighlight">
\[F_{XEB} = 2^{n}\left&lt;P(x_i)\right&gt; - 1,\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of qubits, <span class="math notranslate nohighlight">\(P(x_i)\)</span> is the
probability of bitstring <span class="math notranslate nohighlight">\(x_i\)</span> computed for the ideal quantum
circuit, and the average is over the observed bitstrings.</p>
<p>The idea behind using this fidelity is that it will be close to 1 for
samples obtained from random quantum circuits, such as the one we defined
above, and close to zero for a uniform probability distribution, which
can be effectively sampled from classically. Sampling a bitstring from a
random quantum circuit would follow the distribution</p>
<div class="math notranslate nohighlight">
\[Pr(p) = (N - 1)(1- p)^{N-2},\]</div>
<p>where <span class="math notranslate nohighlight">\(N = 2^n\)</span> is the number of possible bitstrings <a class="footnote-reference brackets" href="#boixo2018" id="id3">4</a>.
This distribution is approximated well by the Porter-Thomas distribution,
given by <span class="math notranslate nohighlight">\(Pr(p) = Ne^{-Np}\)</span>, a characteristic property of chaotic quantum
systems. From this we can then calculate the expectation value
<span class="math notranslate nohighlight">\(\left&lt;P(x_i)\right&gt;\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\left&lt;P(x_i)\right&gt; = \int_0^1 p^2 N (N-1)(1-p)^{N-2}dp = \frac{2}{N+1},\]</div>
<p>which leads to the theoretical fidelity</p>
<div class="math notranslate nohighlight">
\[F_{XEB} = 2^{n}\left&lt;P(x_i)\right&gt; - 1 = \frac{2N}{N+1} - 1.\]</div>
<p>We implement this fidelity as the function below, where <code class="docutils literal notranslate"><span class="pre">samples</span></code> is a
list of sampled bitstrings, and <code class="docutils literal notranslate"><span class="pre">probs</span></code> is a list with corresponding
sampling probabilities for the same noiseless circuit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fidelity_xeb</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">probs</span><span class="p">):</span>
    <span class="n">sampled_probs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">bitstring</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
        <span class="c1"># convert each bitstring into an integer</span>
        <span class="n">bitstring_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bitstring</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># retrieve the corresponding probability for the bitstring</span>
        <span class="n">sampled_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">bitstring_idx</span><span class="p">])</span>

    <span class="k">return</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sampled_probs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We set a random seed and use it to calculate the probability for all the
possible bitstrings. It is then possible to sample from exactly the same
circuit by using the same seed. Before calculating the cross-entropy
benchmarking fidelity, the Pauli-Z samples need to be converted into
their correponding bitstrings, since we need the samples to be in the
computational basis.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Every time the previously defined circuit is run using the <code class="docutils literal notranslate"><span class="pre">qsim</span></code> device, <code class="docutils literal notranslate"><span class="pre">qsimcirq</span></code>
will print a warning message because the circuit has no intermediate measurements.
More information about this warning can be found in the <a class="reference external" href="https://quantumai.google/qsim/tutorials/qsimcirq#measurement_sampling">Measurement sampling
section of the qsimcirq guide</a>.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">42424242</span><span class="p">)</span>
<span class="n">probs</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">circuit_samples</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

<span class="c1"># get bitstrings from the samples</span>
<span class="n">bitstring_samples</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">sam</span> <span class="ow">in</span> <span class="n">circuit_samples</span><span class="p">:</span>
    <span class="n">bitstring_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="n">sam</span><span class="p">))</span>

<span class="n">f_circuit</span> <span class="o">=</span> <span class="n">fidelity_xeb</span><span class="p">(</span><span class="n">bitstring_samples</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, we can sample random bitstrings from a uniform probability
distribution by generating all basis states, along with their
corresponding bitstrings, and sample directly from them using NumPy.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis_states</span> <span class="o">=</span> <span class="n">dev</span><span class="o">.</span><span class="n">generate_basis_states</span><span class="p">(</span><span class="n">wires</span><span class="p">)</span>
<span class="n">random_integers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_states</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">bitstring_samples</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">random_integers</span><span class="p">:</span>
    <span class="n">bitstring_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="n">basis_states</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="n">f_uniform</span> <span class="o">=</span> <span class="n">fidelity_xeb</span><span class="p">(</span><span class="n">bitstring_samples</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, let’s compare the two different values. Sampling from the
circuit’s probability distribution should give a fidelity close to 1,
while sampling from a uniform distribution should give a fidelity
close to 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The cross-entropy benchmarking fidelity may output
values that are negative or that are larger than 1, for any finite
number of samples. This is due to the random nature of the sampling.
For an infinite amount of samples, or circuit runs, the observed
values will tend towards the theoretical ones, and will then always
lie in the 0-to-1 interval.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Circuit&#39;s distribution:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_circuit</span><span class="si">:</span><span class="s2">.7f</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Uniform distribution:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f_uniform</span><span class="si">:</span><span class="s2">.7f</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Circuit&#39;s distribution:    1.0398803
Uniform distribution:      0.0013487
</pre></div>
</div>
<p>To show that the fidelity from the circuit sampling actually tends
towards the theoretical value calculated above we can run several
different random circuits, calculate their respective cross-entropy
benchmarking fidelities and then calculate the mean fidelity of all the
runs. The more evaluations we do, the closer to the theoretical value we
should get.</p>
<p>In the experiment, they typically calculate each of their
presented fidelities over ten circuit instances, which only differ
in the choices of single-qubit gates. In this demo, we use even more
instances to demonstrate a value closer to the theoretically obtained
one.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following mean fidelity calculations can be interesting to play
around with. You can change the qubit grid at the top of this demo
using, e.g., 8 or 4 qubits; change the number of shots used; as well
as the number of circuit evaluations below. Running the following code
snippet, the mean fidelity should still tend towards the theoretical
value (which will be lower for fewer qubits).</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">wires</span>
<span class="n">theoretical_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Theoretical:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">theoretical_value</span><span class="si">:</span><span class="s2">.7f</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">24</span><span class="p">))</span>

<span class="n">f_circuit</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">num_of_evaluations</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_of_evaluations</span><span class="p">):</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">42424242</span><span class="p">)</span>

    <span class="n">probs</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">bitstring_samples</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sam</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
        <span class="n">bitstring_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="n">sam</span><span class="p">))</span>

    <span class="n">f_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fidelity_xeb</span><span class="p">(</span><span class="n">bitstring_samples</span><span class="p">,</span> <span class="n">probs</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\r</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">num_of_evaluations</span><span class="si">:</span><span class="s2">4d</span><span class="si">}{</span><span class="s1">&#39; &#39;</span><span class="si">:</span><span class="s2">17</span><span class="si">}{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f_circuit</span><span class="p">)</span><span class="si">:</span><span class="s2">.7f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">Observed:&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f_circuit</span><span class="p">)</span><span class="si">:</span><span class="s2">.7f</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">27</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Theoretical:                0.9995118
Observed:                   0.9999512
</pre></div>
</div>
</div>
<div class="section" id="classical-hardness">
<h2>Classical hardness<a class="headerlink" href="#classical-hardness" title="Permalink to this headline">¶</a></h2>
<p>Why are we calculating this specific fidelity, and what does it actually
mean if we get a cross-entropy benchmarking fidelity close to 1? This is
an important question, containing one of the main arguments behind why
this experiment is used to demonstrate “quantum supremacy”.</p>
<p>Much is due to the Porter-Thompson probability distribution that the
random quantum circuits follow, which is hard to simulate classically.
On the other hand, a quantum device, running a circuit as the one
constructed above, should be able to sample from such a distribution
without much overhead. Thus, by showing that a quantum device can produce
a high enough fidelity value for a large enough circuit, “quantum
supremacy” can be claimed. This is exactly what Google’s experiment
has done.</p>
<p>There’s still one issue that hasn’t been touched on yet: the addition of
noise in quantum hardware. Simply put, this noise will lower the
cross-entropy benchmarking fidelity—the larger the
circuit, the more noise there will be, and thus the lower the fidelity, with the
fidelity approaching 0 as the noise increases.
By calculating the specific single-qubit, two-qubit, and readout errors
of the Sycamore chip, and using them to simulate a noisy circuit, the Google
AI quantum team was able to compare the run-times with the output from
their actual hardware device. This way, they managed to show that a
significant speedup could be gained from using a quantum computer, and
thus proclaimed “quantum supremacy” (see Fig. 4 in <a class="footnote-reference brackets" href="#arute2019" id="id4">1</a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more reading on this, the original paper <a class="footnote-reference brackets" href="#arute2019" id="id5">1</a> is highly
recommended (along with the suplementary information <a class="footnote-reference brackets" href="#arute2019sup" id="id6">2</a> if you want
to dive deeper into the math and physics of the experiment). The blog
post in <a class="footnote-reference brackets" href="#sohaib2019" id="id7">5</a>, along with the accompanying GitHub repo, also provides
a nice introduction to the cross-entropy benchmarking fidelity, and
includes calculations highlighting the effects of added noise models.</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="arute2019"><span class="brackets">1</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id4">2</a>,<a href="#id5">3</a>)</span></dt>
<dd><p>Arute, F., Arya, K., Babbush, R. et al. “Quantum supremacy using a programmable
superconducting processor”
<a class="reference external" href="https://doi.org/10.1038/s41586-019-1666-5">Nature 574, 505-510 (2019)</a>.</p>
</dd>
<dt class="label" id="arute2019sup"><span class="brackets"><a class="fn-backref" href="#id6">2</a></span></dt>
<dd><p>Arute, F., Arya, K., Babbush, R. et al. Supplementary information for “Quantum
supremacy using a programmable superconducting processor”
<a class="reference external" href="https://arxiv.org/abs/1910.11333">arXiv:1910.11333 (2019)</a></p>
</dd>
<dt class="label" id="martinis2020"><span class="brackets"><a class="fn-backref" href="#id1">3</a></span></dt>
<dd><p>Martinis, John M. et al. (2020), <a class="reference external" href="https://doi.org/10.5061/dryad.k6t1rj8">Quantum supremacy using a programmable
superconducting processor, Dryad, Dataset</a></p>
</dd>
<dt class="label" id="boixo2018"><span class="brackets"><a class="fn-backref" href="#id3">4</a></span></dt>
<dd><p>Boixo, S., Isakov, S.V., Smelyanskiy, V.N. et al. Characterizing quantum supremacy
in near-term devices.
<a class="reference external" href="https://doi.org/10.1038/s41567-018-0124-x">Nature Phys 14, 595-600 (2018)</a></p>
</dd>
<dt class="label" id="sohaib2019"><span class="brackets"><a class="fn-backref" href="#id7">5</a></span></dt>
<dd><p>Sohaib, Alam M. and Zeng, W., <a class="reference external" href="https://medium.com/&#64;sohaib.alam/unpacking-the-quantum-supremacy-benchmark-with-python-67a46709d">Unpacking the Quantum Supremacy Benchmark with Python</a></p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/theodor_isacsson.jpg" alt="Theodor Isacsson" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Theodor Isacsson</h4>
        <p class="bio-text__author-description">Theodor is a quantum software engineer based in Vancouver. He's currently at D-Wave Systems, having previously worked on the quantum software stack at Xanadu, where he contributed to packages such as Strawberry Fields, The Walrus and PennyLane.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-qsim-beyond-classical-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/da2cdc7da561da4afe4f8198a7da0e5a/qsim_beyond_classical.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">qsim_beyond_classical.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/84e0724463747d43c331749ffefa6885/qsim_beyond_classical.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">qsim_beyond_classical.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/qsim_beyond_classical</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Beyond classical computing with qsim</a><ul class='current'>
<li class='current'><a class="reference internal" href="#preparations">Preparations</a></li>
<li class='current'><a class="reference internal" href="#assembling-the-circuit">Assembling the circuit</a></li>
<li class='current'><a class="reference internal" href="#the-cross-entropy-benchmarking-fidelity">The cross-entropy benchmarking fidelity</a></li>
<li class='current'><a class="reference internal" href="#classical-hardness">Classical hardness</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/qsim_beyond_classical</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_quantum-computing.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="gbs.html" title="Quantum advantage with Gaussian Boson Sampling"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_pasqal.html" title="Quantum computation with neutral atoms"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" >Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Beyond classical computing with qsim</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>