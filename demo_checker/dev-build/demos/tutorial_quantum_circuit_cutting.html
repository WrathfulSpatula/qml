
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="We dive into two algorithms for splitting a large quantum circuit into smaller ones." property="og:description" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Quantum Circuit Cutting &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_quantum_circuit_cutting.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="We dive into two algorithms for splitting a large quantum circuit into smaller ones." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Quantum Circuit Cutting &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_quantum_circuit_cutting.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Testing for symmetry with quantum computers" href="tutorial_testing_symmetry.html" />
    <link rel="prev" title="Modeling the toric code on a quantum computer" href="tutorial_toric_code.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_testing_symmetry.html" title="Testing for symmetry with quantum computers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_toric_code.html" title="Modeling the toric code on a quantum computer"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_quantum-computing.html" accesskey="U">Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Quantum Circuit Cutting</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#sphx-glr-download-demos-tutorial-quantum-circuit-cutting-py"><span class="std std-ref">Go to the end</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="id1">
<h1>Quantum Circuit Cutting<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_qaoa_intro.html", "tutorial_qaoa_maxcut.html", "tutorial_haar_measure.html", "tutorial_unitary_designs.html"];
    var related_tutorials_titles = ['Intro to QAOA', 'QAOA for MaxCut', 'Understanding the Haar measure', 'Unitary designs'];
</script></p>
<p><em>Authors: Gideon Uchehara, Matija Medvidović, Anuj Apte — Posted: 02 September 2022. Last updated: 02 September 2022.</em></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Quantum circuits with a large number of qubits are difficult to simulate.
They cannot be programmed on actual hardware due to size constraints
(insufficient qubits), and they are also error-prone. What if we “cut”
a large circuit into smaller, more manageable pieces? This is the main
idea behind the algorithm that allows you to simulate large quantum
circuits on a small quantum computer called <em>quantum circuit cutting</em>.</p>
<p>In this demo, we will first introduce the theory behind quantum circuit
cutting based on Pauli measurements and see how it is implemented in
PennyLane. This method was first introduced in <a class="footnote-reference brackets" href="#peng2019" id="id2">1</a>.
Thereafter, we discuss the theoretical basis on randomized circuit
cutting with two-designs and demonstrate the resulting improvement in
performance compared to Pauli measurement based circuit cutting for an
instance of Quantum Approximate Optimization Algorithm (QAOA).</p>
</div>
<div class="section" id="background-understanding-the-pauli-cutting-method">
<h2>Background: Understanding the Pauli cutting method<a class="headerlink" href="#background-understanding-the-pauli-cutting-method" title="Permalink to this headline">¶</a></h2>
<p>Consider a two-level quantum system in an arbitrary state, described by
density matrix <span class="math notranslate nohighlight">\(\rho\)</span>. The quantum state <span class="math notranslate nohighlight">\(\rho\)</span> can be expressed
as a linear combination of the Pauli matrices:</p>
<div class="math notranslate nohighlight">
\[\rho = \frac{1}{2}\sum_{i=1}^{8} c_i Tr(\rho O_i)\rho_i.\]</div>
<p>Here, we have denoted Pauli matrices by <span class="math notranslate nohighlight">\(O_i\)</span>, their
eigenprojectors by <span class="math notranslate nohighlight">\(\rho_i\)</span> and their corresponding eigenvalues by
<span class="math notranslate nohighlight">\(c_i\)</span>. In the above equation,</p>
<div class="math notranslate nohighlight">
\[O_1 = O_2 = I,\]</div>
<div class="math notranslate nohighlight">
\[O_3 = O_4 = X,\]</div>
<div class="math notranslate nohighlight">
\[O_5 = O_6 = Y\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[O_7 = O_8 = Z.\]</div>
<p>Also,</p>
<div class="math notranslate nohighlight">
\[\rho_1 = \rho_7=\left | {0} \right\rangle \left\langle {0} \right |,\]</div>
<div class="math notranslate nohighlight">
\[\rho_2 = \rho_8 = \left | {1} \right\rangle \left\langle {1} \right |,\]</div>
<div class="math notranslate nohighlight">
\[\rho_3 = \left | {+} \right\rangle \left\langle {+} \right |,\]</div>
<div class="math notranslate nohighlight">
\[\rho_4 = \left | {-} \right\rangle \left\langle {-} \right |,\]</div>
<div class="math notranslate nohighlight">
\[\rho_5 = \left | {+i} \right\rangle \left\langle {+i} \right |,\]</div>
<div class="math notranslate nohighlight">
\[\rho_6 = \left | {-i} \right\rangle \left\langle {-i} \right |\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[c_i = \pm 1.\]</div>
<p>The above equation can be implemented as a quantum circuit on a quantum
computer. To do this, each term <span class="math notranslate nohighlight">\(Tr(\rho O_i)\rho_i\)</span> in the equation
is broken into two parts. The first part, <span class="math notranslate nohighlight">\(Tr(\rho O_i)\)</span> is the
expectation  of the observable <span class="math notranslate nohighlight">\(O_i\)</span> when the system is in the state
<span class="math notranslate nohighlight">\(\rho\)</span>. Let’s call this first circuit subcircuit-<span class="math notranslate nohighlight">\(u\)</span>.
The second part, <span class="math notranslate nohighlight">\(\rho_i\)</span> is initialization or preparation of the
eigenstate, <span class="math notranslate nohighlight">\(\rho_i\)</span>. Let’s call this Second circuit subcircuit-<span class="math notranslate nohighlight">\(v\)</span>.
The above equation shows how we can recover a quantum state after a is cut made
on one of its qubits as shown in figure 1. This forms the core of quantum
circuit cutting.</p>
<p>It turns out that we only have to do three measurements
<span class="math notranslate nohighlight">\(\left (Tr(\rho X), Tr(\rho Y), Tr(\rho Z) \right)\)</span> for
subcircuit-<span class="math notranslate nohighlight">\(u\)</span> and initialize subcircuit-<span class="math notranslate nohighlight">\(v\)</span> with only four
states: <span class="math notranslate nohighlight">\(\left | {0} \right\rangle\)</span>,
<span class="math notranslate nohighlight">\(\left | {1} \right\rangle\)</span>, <span class="math notranslate nohighlight">\(\left | {+} \right\rangle\)</span> and
<span class="math notranslate nohighlight">\(\left | {+i} \right\rangle\)</span>. The other two nontrivial expectation
values for states <span class="math notranslate nohighlight">\(\left | {-} \right\rangle\)</span> and
<span class="math notranslate nohighlight">\(\left | {- i} \right\rangle\)</span> can be derived with classical
post-processing.</p>
<p>In general, there is a resolution of the identity along a wire (qubit) that
we can interpret as circuit cutting. In the following section, we will
provide a more clever way of resolving the same identity that leads
to fewer shots needed to estimate observables.</p>
<div class="figure align-center" id="id5">
<a class="reference internal image-reference" href="../_images/1Qubit-Circuit-Cutting.png"><img alt="../_images/1Qubit-Circuit-Cutting.png" src="../_images/1Qubit-Circuit-Cutting.png" style="width: 80%;" /></a>
<p class="caption"><span class="caption-text">Figure 1. The Pauli circuit cutting method for 1-qubit circuit. The
first half of the cut circuit on the left (subcircuit-u) is the part
with <code class="docutils literal notranslate"><span class="pre">MeasureNode</span></code>. The second half of the cut circuit on the right
(subcircuit-v) is the part with <code class="docutils literal notranslate"><span class="pre">PrepareNode</span></code></span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="pennylane-implementation">
<h3>PennyLane implementation<a class="headerlink" href="#pennylane-implementation" title="Permalink to this headline">¶</a></h3>
<p>PennyLane’s built-in  circuit cutting algorithm, <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit</span></code>,
takes a large quantum circuit and decomposes it into smaller subcircuits that
are executed on a small quantum device. The results from executing the
smaller subcircuits are then recombined through some classical post-processing
to obtain the original result of the large quantum circuit.</p>
<p>Let’s simulate a “real-world” scenario with <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit</span></code> using the
circuit below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import the relevant libraries</span>
<span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pauli.string_to_pauli_word.html#pennylane.pauli.string_to_pauli_word" title="pennylane.pauli.string_to_pauli_word" class="sphx-glr-backref-module-pennylane-pauli sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">pauli</span><span class="o">.</span><span class="n">string_to_pauli_word</span></a><span class="p">(</span><span class="s2">&quot;ZZZ&quot;</span><span class="p">))</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.531</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.draw_mpl.html#pennylane.draw_mpl" title="pennylane.draw_mpl" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">draw_mpl</span></a><span class="p">(</span><span class="n">circuit</span><span class="p">)(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_quantum_circuit_cutting_001.png" srcset="../_images/sphx_glr_tutorial_quantum_circuit_cutting_001.png" alt="tutorial quantum circuit cutting" class = "sphx-glr-single-img"/><p>Given the above quantum circuit, our goal is to simulate a 3-qubit quantum
circuit on a 2-qubit quantum computer. This means that we have to cut
the circuit such that the resulting subcircuits have at most 2 qubits.</p>
<p>Apart from ensuring that the number of qubits for each subcircuit does not
exceed the number of qubits on our quantum device, we also have to ensure
that the resulting subcircuits have the most efficient classical
post-processing. This is not quite trivial to determine in most cases, but
for the above circuit, the best cut location turns out to be between
the two <code class="docutils literal notranslate"><span class="pre">CZ</span></code> gates on qubit 1 (more on this later). Hence, we place a
<code class="docutils literal notranslate"><span class="pre">WireCut</span></code> operation at that location as shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Quantum Circuit with QNode</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">WireCut</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Cut location</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pauli.string_to_pauli_word.html#pennylane.pauli.string_to_pauli_word" title="pennylane.pauli.string_to_pauli_word" class="sphx-glr-backref-module-pennylane-pauli sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">pauli</span><span class="o">.</span><span class="n">string_to_pauli_word</span></a><span class="p">(</span><span class="s2">&quot;ZZZ&quot;</span><span class="p">))</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.531</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Defining the parameter x</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.draw_mpl.html#pennylane.draw_mpl" title="pennylane.draw_mpl" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">draw_mpl</span></a><span class="p">(</span><span class="n">circuit</span><span class="p">)(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">)</span>  <span class="c1"># Drawing circuit</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_quantum_circuit_cutting_002.png" srcset="../_images/sphx_glr_tutorial_quantum_circuit_cutting_002.png" alt="tutorial quantum circuit cutting" class = "sphx-glr-single-img"/><p>The double vertical lines between the two <code class="docutils literal notranslate"><span class="pre">CZ</span></code> gates on qubit 1 in the
above figure show where we have chosen to cut. This is where the <code class="docutils literal notranslate"><span class="pre">WireCut</span></code>
operation is inserted. <code class="docutils literal notranslate"><span class="pre">WireCut</span></code> is used to manually mark locations for
wire cuts.</p>
<p>Next, we apply <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit</span></code> operation as a decorator to the
<code class="docutils literal notranslate"><span class="pre">circuit</span></code> function to perform circuit cutting on the quantum circuit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Quantum Circuit with QNode</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">cut_circuit</span><span class="p">()</span>  <span class="c1"># Applying qml.cut_circuit for circuit cut operation</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">WireCut</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Cut location</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pauli.string_to_pauli_word.html#pennylane.pauli.string_to_pauli_word" title="pennylane.pauli.string_to_pauli_word" class="sphx-glr-backref-module-pennylane-pauli sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">pauli</span><span class="o">.</span><span class="n">string_to_pauli_word</span></a><span class="p">(</span><span class="s2">&quot;ZZZ&quot;</span><span class="p">))</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.531</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">circuit</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">)</span>  <span class="c1"># Executing the quantum circuit</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>0.47165198882111165
</pre></div>
</div>
<p>Let’s explore what happens behind the scenes in  <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit</span></code>. When the
<code class="docutils literal notranslate"><span class="pre">circuit</span></code> qnode function is executed, the quantum circuit is converted to
a <a class="reference external" href="https://pennylane.ai/blog/2021/08/how-to-write-quantum-function-transforms-in-pennylane/">quantum tape</a>
and then to a graph. Any <code class="docutils literal notranslate"><span class="pre">WireCut</span></code> in the quantum
circuit graph is replaced with <code class="docutils literal notranslate"><span class="pre">MeasureNode</span></code> and <code class="docutils literal notranslate"><span class="pre">PrepareNode</span></code> pairs as
shown in figure 2. The <code class="docutils literal notranslate"><span class="pre">MeasureNode</span></code> is the point on the cut qubit that
indicates where to measure the observable <span class="math notranslate nohighlight">\(O_i\)</span> after cut. On the other
hand, the <code class="docutils literal notranslate"><span class="pre">PrepareNode</span></code> is the point on the cut qubit that indicates Where
to initialize the state <span class="math notranslate nohighlight">\(\rho\)</span> after cut.
Both <code class="docutils literal notranslate"><span class="pre">MeasureNode</span></code> and <code class="docutils literal notranslate"><span class="pre">PrepareNode</span></code> are placeholder
operations that allow us to cut the quantum circuit graph and then iterate
over measurements of Pauli observables and preparations of their corresponding
eigenstates configurations at cut locations.</p>
<div class="figure align-center" id="id6">
<a class="reference internal image-reference" href="../_images/MeasurePrepareNodes.png"><img alt="../_images/MeasurePrepareNodes.png" src="../_images/MeasurePrepareNodes.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">Figure 2. Replace WireCut with MeasureNode and PrepareNode</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>Cutting at the said location gives two graph fragments with 2 qubits each. To
separate these fragments into different subcircuit graphs, the
<code class="docutils literal notranslate"><span class="pre">fragment_graph()</span></code> function is called to pull apart the quantum circuit
graph as shown in figure 3. The subcircuit graphs are reconverted back to
quantum tapes and <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit</span></code> runs multiple configurations of the
2-qubit subcircuit tapes which are then post-processed to replicate the result
of the uncut circuit.</p>
<div class="figure align-center" id="id7">
<a class="reference internal image-reference" href="../_images/separateMeasurePrepareNodes.png"><img alt="../_images/separateMeasurePrepareNodes.png" src="../_images/separateMeasurePrepareNodes.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">Figure 3. Separate fragments into different subcircuits</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="automatic-cut-placement">
<h3><strong>Automatic cut placement</strong><a class="headerlink" href="#automatic-cut-placement" title="Permalink to this headline">¶</a></h3>
<p>We manually found a good cut position, but what if we didn’t know where it
was in general? Changing cut positions results in different outcomes in terms
of simulation efficiency, so choosing the optimal cut reduces post-processing
overhead and improves simulation efficiency.</p>
<p>Automatic cut placment is a PennyLane functionality that aids us in
finding the optimal cut that fragments a circuit such that
the classical post-processing overhead is minimized. The main algorithm
behind automatic cut placement is <a class="reference external" href="https://kahypar.org/">graph partitioning</a></p>
<p>If <code class="docutils literal notranslate"><span class="pre">auto_cutter</span></code> is enabled in <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit</span></code>, PennyLane makes attempts
to find an optimal cut using graph partitioning. Whenever it is difficult to
manually determine the optimal cut location, this is the recommended
approach to circuit cutting. The following example shows this capability
on the same circuit as above but with the <code class="docutils literal notranslate"><span class="pre">WireCut</span></code> removed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">cut_circuit</span><span class="p">(</span><span class="n">auto_cutter</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># auto_cutter enabled</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.pauli.string_to_pauli_word.html#pennylane.pauli.string_to_pauli_word" title="pennylane.pauli.string_to_pauli_word" class="sphx-glr-backref-module-pennylane-pauli sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">pauli</span><span class="o">.</span><span class="n">string_to_pauli_word</span></a><span class="p">(</span><span class="s2">&quot;ZZZ&quot;</span><span class="p">))</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.531</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">circuit</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>0.47165198882111165
</pre></div>
</div>
</div>
</div>
<div class="section" id="randomized-circuit-cutting">
<h2>Randomized Circuit Cutting<a class="headerlink" href="#randomized-circuit-cutting" title="Permalink to this headline">¶</a></h2>
<p>After reviewing the standard circuit cutting based on Pauli measurements
on single qubits, we are now ready to discuss an improved circuit
cutting protocol that uses randomized measurements to speed up circuit
cutting. Our description of this method will be based on the recently
published work <a class="footnote-reference brackets" href="#lowe2022" id="id3">2</a>.</p>
<p>The key idea behind this approach is to use measurements in an entagled
basis that is based on a unitary 2-design to get more information about
the state with fewer measurements compared to single qubit Pauli
measurements.</p>
<p>The concept of 2-designs is simple — a unitary 2-design is finite
collection of unitaries such that the average of any degree 2 polynomial
function of a linear operator over the design is exactly the same as the
average over Haar random measure. For further explanation of this measure read
the <a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_haar_measure.html">Haar Measure demo</a>.</p>
<p>More precisely, let <span class="math notranslate nohighlight">\(P(U)\)</span> be a polynomial with homogeneous degree at most two in
the entries of a unitary matrix <span class="math notranslate nohighlight">\(U\)</span>, and degree two in the complex
conjugates of those entries. A unitary 2-design is a set of <span class="math notranslate nohighlight">\(L\)</span>
unitaries <span class="math notranslate nohighlight">\(\{U_{L}\}\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\frac{1}{L} \sum_{l=1}^{L} P(U_l) = \int_{\mathcal{U}(d)} P (U) d\mu(U)~.\]</div>
<p>The elemements of the Clifford group over the qubits being cut are an
example of a 2-design. We don’t have a lot of space here to go into too
many details. But fear not - there is an <a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_unitary_designs.html">entire
demo</a>
dedicated to this wonderful topic!</p>
<div class="figure align-center" id="id8">
<a class="reference internal image-reference" href="../_images/flowchart.svg"><img alt="../_images/flowchart.svg" src="../_images/flowchart.svg" width="90%" /></a>
<p class="caption"><span class="caption-text">Figure 4. Illustration of Randomized Circuit Cutting based on Two-Designs. Taken from <a class="footnote-reference brackets" href="#lowe2022" id="id4">2</a>.</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>If <span class="math notranslate nohighlight">\(k\)</span> qubits are being cut, then the dimensionality of the
Hilbert space is <span class="math notranslate nohighlight">\(d=2^{k}\)</span>. The key idea of Randomized Circuit Cutting
is to employ two different quantum channels with probabilities such that together
they comprise a resolution of Identity. In the randomized measurement circuit
cutting procedure, we trace out the <span class="math notranslate nohighlight">\(k\)</span> qubits and prepare a random basis
state with probability <span class="math notranslate nohighlight">\(d/(2d+1)\)</span>. For a linear operator
<span class="math notranslate nohighlight">\(X \in \mathbf{L}(\mathbb{C}^{d})\)</span> acting on the <span class="math notranslate nohighlight">\(k\)</span> qubits,
this operation corresponds to the completely depolarizing channel</p>
<div class="math notranslate nohighlight">
\[\Psi_{1}(X) = \textrm{Tr}(X)\frac{\mathbf{1}}{d}~.\]</div>
<p>Otherwise, we perform measure-and-prepare protocol based on
a unitary 2-design (e.g. a random Clifford) with probability
<span class="math notranslate nohighlight">\((d+1)/(2d+1)\)</span>, corresponding to the channel</p>
<div class="math notranslate nohighlight">
\[\Psi_{0}(X) = \frac{1}{d+1}\left(\textrm{Tr}(X)\mathbf{1} + X\right)~.\]</div>
<p>The sets of Kraus operators for the channels <span class="math notranslate nohighlight">\(\Psi_{1} and \Psi_{0}\)</span> are</p>
<div class="math notranslate nohighlight">
\[\Psi_{1}(X) \xrightarrow{} \left\{ \frac{|i\rangle \langle j|}{\sqrt{d}} \right\} \quad
\Psi_{0}(X) \xrightarrow{} \left\{ \frac{\mathbf{1}}{\sqrt{d+1}} ~,~ \frac{|i\rangle \langle j|}{\sqrt{d+1}} \right\}~,\]</div>
<p>where indices <span class="math notranslate nohighlight">\(i,j\)</span> run over the <span class="math notranslate nohighlight">\(d\)</span> basis elements.</p>
<p>Together, these two channels can be used to obtain a resolution of the
Identity channel on the <span class="math notranslate nohighlight">\(k\)</span>-qubits as follows</p>
<div class="math notranslate nohighlight">
\[X = (d+1)\Psi_0(X)-d\Psi_1(X)~.\]</div>
<p>By employing this procedure, we can estimate the outcome of the original
circuit by using the cut circuits. For an error threshold of
<span class="math notranslate nohighlight">\(\varepsilon\)</span>, the associated overhead is
<span class="math notranslate nohighlight">\(O(4^{k}(n+k^{2})/\varepsilon^{2})\)</span>. When <span class="math notranslate nohighlight">\(k\)</span> is a small
constant and the circuit is cut into roughly two equal halves, this
procedure effectively doubles the number of qubits that can be
simulated given a quantum device, since the overhead is <span class="math notranslate nohighlight">\(O(4^k)\)</span>
which is much lower than the <span class="math notranslate nohighlight">\(O(16^k)\)</span> overhead of cutting with single-qubit
measurements. Note that, although the overhead incurred is smaller, the
average depth of the circuit is greater since a random Clifford unitary
over the <span class="math notranslate nohighlight">\(k\)</span> qubits has to be implemented when randomized measurement
is performed.</p>
</div>
<div class="section" id="comparison">
<h2>Comparison<a class="headerlink" href="#comparison" title="Permalink to this headline">¶</a></h2>
<p>We have seen that looking at circuit cutting through the lens of
2-designs can be a source of considerable speedups. A good test case
where one may care about accurately estimating an observable is the
<a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_qaoa_intro.html">Quantum Approximate Optimization
Algorithm</a>
(QAOA). In its simplest form, QAOA concerns itself with finding a
lowest energy state of a <em>cost hamiltonian</em> <span class="math notranslate nohighlight">\(H_{\mathcal{C}}\)</span>:</p>
<div class="math notranslate nohighlight">
\[H_\mathcal{C} = \frac{1}{|E|} \sum _{(i, j) \in E} Z_i Z_j\]</div>
<p>on a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>, where <span class="math notranslate nohighlight">\(Z_i\)</span> is a Pauli-<span class="math notranslate nohighlight">\(Z\)</span>
operator. The normalization factor is just here so that expectation
values do not lie outside the <span class="math notranslate nohighlight">\([-1,1]\)</span> interval.</p>
<div class="section" id="setup">
<h3>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h3>
<p>Suppose that we have a specific class of graphs we care about and
someone already provided us with optimal angles <span class="math notranslate nohighlight">\(\gamma\)</span> and
<span class="math notranslate nohighlight">\(\beta\)</span> for QAOA of depth <span class="math notranslate nohighlight">\(p=1\)</span>. Here’s how to map the input
graph <span class="math notranslate nohighlight">\(G\)</span> to the QAOA circuit that solves our problem:</p>
<div class="figure align-center" id="id9">
<a class="reference internal image-reference" href="../_images/graph_to_circuit.svg"><img alt="../_images/graph_to_circuit.svg" src="../_images/graph_to_circuit.svg" width="90%" /></a>
<p class="caption"><span class="caption-text">Figure 5. An example of mapping an input interaction graph to a QAOA
circuit. (Note: the “stick” gates represent the ZZ rotation gates, to avoid
overcrowding the diagram.)</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>Let’s generate a similar QAOA graph to the one in the figure this using
<a class="reference external" href="https://networkx.org/">NetworkX</a>!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>

<span class="n">n_side_nodes</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">n_middle_nodes</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">top_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_side_nodes</span><span class="p">)</span>
<span class="n">middle_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_side_nodes</span><span class="p">,</span> <span class="n">n_side_nodes</span> <span class="o">+</span> <span class="n">n_middle_nodes</span><span class="p">)</span>
<span class="n">bottom_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_side_nodes</span> <span class="o">+</span> <span class="n">n_middle_nodes</span><span class="p">,</span> <span class="n">n_middle_nodes</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_side_nodes</span><span class="p">)</span>

<span class="n">top_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="n">top_nodes</span><span class="p">,</span> <span class="n">middle_nodes</span><span class="p">))</span>
<span class="n">bottom_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="n">middle_nodes</span><span class="p">,</span> <span class="n">bottom_nodes</span><span class="p">))</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">top_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">top_edges</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">bottom_edges</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">bottom_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_spring</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_quantum_circuit_cutting_003.png" srcset="../_images/sphx_glr_tutorial_quantum_circuit_cutting_003.png" alt="tutorial quantum circuit cutting" class = "sphx-glr-single-img"/><p>For this graph, optimal QAOA parameters read:</p>
<div class="math notranslate nohighlight">
\[\gamma ^* \approx -0.240 \; ; \qquad \beta ^* \approx 0.327 \quad \Rightarrow \quad \left\langle H_\mathcal{C} \right\rangle ^* \approx -0.248\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">optimal_params</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.240</span><span class="p">,</span> <span class="mf">0.327</span><span class="p">])</span>
<span class="n">optimal_cost</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.248</span>
</pre></div>
</div>
<p>We also define our cost operator <span class="math notranslate nohighlight">\(H_{\mathcal{C}}\)</span> as a function.
Because it is diagonal in the computational basis, we only need to
define its action on computational basis bitstrings.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qaoa_cost</span><span class="p">(</span><span class="n">bitstring</span><span class="p">):</span>

    <span class="n">bitstring</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bitstring</span><span class="p">)</span>
    <span class="c1"># Make sure that we operate correctly on a batch of bitstrings</span>

    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">bitstring</span><span class="p">[:,</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>  <span class="c1"># Filter out pairs of bits correspondimg to graph edges</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">costs</span></a> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Do products and sums</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">costs</span></a><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>  <span class="c1"># Normalize</span>
</pre></div>
</div>
<p>Let’s make a quick and simple QAOA circuit in PennyLane. Before we actually
cut the circuit, we have to briefly think about the cut placement. First, we
want to apply all ZZ rotation gates corresponding to the <code class="docutils literal notranslate"><span class="pre">top_edges</span></code>, place the wire
cut, and then the <code class="docutils literal notranslate"><span class="pre">bottom_edges</span></code>, to ensure that the circuit actually splits
in two after cutting.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qaoa_template</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>

    <span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">params</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)):</span>  <span class="c1"># Apply the Hadamard gates</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">top_edges</span><span class="p">:</span>

        <span class="c1"># Apply the ZZ rotation gates</span>
        <span class="c1"># corresponding to the</span>
        <span class="c1"># green edges in the figure</span>

        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.MultiRZ.html#pennylane.MultiRZ" title="pennylane.MultiRZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">MultiRZ</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">WireCut</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">middle_nodes</span><span class="p">)</span>  <span class="c1"># Place the wire cut</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bottom_edges</span><span class="p">:</span>

        <span class="c1"># Apply the ZZ rotation gates</span>
        <span class="c1"># corresponding to the</span>
        <span class="c1"># purple edges in the figure</span>

        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.MultiRZ.html#pennylane.MultiRZ" title="pennylane.MultiRZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">MultiRZ</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>  <span class="c1"># Finally, apply the RX gates</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s construct the <code class="docutils literal notranslate"><span class="pre">QuantumTape</span></code> corresponding to this template and
draw the circuit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane.tape</span> <span class="kn">import</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class"><span class="n">QuantumTape</span></a>

<span class="n">all_wires</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)))</span>

<span class="k">with</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class"><span class="n">QuantumTape</span></a><span class="p">()</span> <span class="k">as</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape</span></a><span class="p">:</span>
    <span class="n">qaoa_template</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">optimal_params</span></a><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.sample.html#pennylane.sample" title="pennylane.sample" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">sample</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">all_wires</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.drawer.tape_mpl.html#pennylane.drawer.tape_mpl" title="pennylane.drawer.tape_mpl" class="sphx-glr-backref-module-pennylane-drawer sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">drawer</span><span class="o">.</span><span class="n">tape_mpl</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape</span></a><span class="p">,</span> <span class="n">expansion_strategy</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_quantum_circuit_cutting_004.png" srcset="../_images/sphx_glr_tutorial_quantum_circuit_cutting_004.png" alt="tutorial quantum circuit cutting" class = "sphx-glr-single-img"/></div>
<div class="section" id="the-pauli-cutting-method">
<h3>The Pauli cutting method<a class="headerlink" href="#the-pauli-cutting-method" title="Permalink to this headline">¶</a></h3>
<p>To run fragment subcircuits and combine them into a finite-shot estimate
of the optimal cost function using the Pauli cut method, we can use
built-in PennyLane functions. We simply use the <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit_mc</span></code>
transform and everything is taken care of for us.</p>
<p>Note that we have already introduced the <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit</span></code> transform
in the previous section. The <code class="docutils literal notranslate"><span class="pre">_mc</span></code> appendix stands for Monte Carlo and
is used to calculate finite-shot estimates of observables. The
observable itself is passed to the <code class="docutils literal notranslate"><span class="pre">qml.cut_circuit_mc</span></code> transform as a
function mapping a bitstring (circuit sample) to a single number.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">all_wires</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">cut_circuit_mc</span><span class="p">(</span><span class="n">classical_processing_fn</span><span class="o">=</span><span class="n">qaoa_cost</span><span class="p">)</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qaoa</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="n">qaoa_template</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.sample.html#pennylane.sample" title="pennylane.sample" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">sample</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">all_wires</span><span class="p">)</span>
</pre></div>
</div>
<p>We can obtain the cost estimate by simply running <code class="docutils literal notranslate"><span class="pre">qaoa</span></code> like a
“normal” <code class="docutils literal notranslate"><span class="pre">QNode</span></code>. Let’s do just that for a grid of values so we can
study convergence.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_shots</span> <span class="o">=</span> <span class="mi">10000</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_counts</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">pauli_cost_values</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_counts</span></a><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shots</span></a> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_counts</span></a><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">pauli_cost_values</span></a><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">qaoa</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">optimal_params</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shots</span></a><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shots</span></a><span class="p">)</span>
</pre></div>
</div>
<p>We will save these results for later and plot them together with results
of the randomized measurement method.</p>
</div>
<div class="section" id="the-randomized-channel-based-cutting-method">
<h3>The randomized channel-based cutting method<a class="headerlink" href="#the-randomized-channel-based-cutting-method" title="Permalink to this headline">¶</a></h3>
<p>As noted earlier, the easiest way to mathematically represent the
randomized channel-based method is to write down Kraus operators for the
relevant channels, <span class="math notranslate nohighlight">\(\Psi _0\)</span> and <span class="math notranslate nohighlight">\(\Psi _1\)</span>. Once we have
represented them in explicit matrix form, we can simply use <code class="docutils literal notranslate"><span class="pre">qml.QubitChannel</span></code>.</p>
<p>To get our matrices, we represent the computational basis set along the
<span class="math notranslate nohighlight">\(k\)</span> cut wires as a unit vector</p>
<div class="math notranslate nohighlight">
\[\left\vert i \right\rangle \mapsto (0, \ldots, 1,\ldots,0)\]</div>
<p>with the 1 positioned at index <span class="math notranslate nohighlight">\(i\)</span>. Therefore:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\vert i \right\rangle \left\langle j \right\vert \mapsto \begin{pmatrix}
    0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
    0 &amp; \ddots &amp; \cdots &amp; 0 &amp; 0 \\
    \vdots &amp; 0 &amp; 1 &amp; 0 &amp; \vdots \\
    0 &amp; 0 &amp; \cdots &amp; \ddots &amp; 0 \\
    0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
\end{pmatrix}\end{split}\]</div>
<p>where the 1 sits at column <span class="math notranslate nohighlight">\(i\)</span> and row <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>Given this representation, a neat way to get all Kraus operators’ matrix
representations is the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_kraus_ops</span><span class="p">(</span><span class="n">num_wires</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

    <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">num_wires</span>

    <span class="c1"># High level idea: Take the identity operator on d^2 x d^2 and look at each row independently.</span>
    <span class="c1"># When reshaped into a matrix, it gives exactly the matrix representation of |i&gt;&lt;j|:</span>

    <span class="n">kraus0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="n">kraus0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">kraus0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">d</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Add the identity op&#39; to the mix</span>

    <span class="n">kraus0</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Normalize</span>

    <span class="c1"># Same trick for the other Kraus op&#39;</span>
    <span class="n">kraus1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">kraus1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># Finally, return a list of NumPy arrays, as per `qml.QubitChannel` docs.</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">kraus0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="n">kraus1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">))</span>
</pre></div>
</div>
<p>Our next task is to generate two new <code class="docutils literal notranslate"><span class="pre">QuantumTape</span></code> objects from our
existing <code class="docutils literal notranslate"><span class="pre">tape</span></code>, one for <span class="math notranslate nohighlight">\(\Psi _0\)</span> and one for <span class="math notranslate nohighlight">\(\Psi _1\)</span>.
Currently, a <code class="docutils literal notranslate"><span class="pre">qml.WireCut</span></code> dummy gate is used to represent the cut
position and size. So, iterating through gates in <code class="docutils literal notranslate"><span class="pre">tape</span></code>:</p>
<ul class="simple">
<li><p>If the gate is a <code class="docutils literal notranslate"><span class="pre">qml.WireCut</span></code>, we apply the <code class="docutils literal notranslate"><span class="pre">qml.QubitChannel</span></code>
corresponding to <span class="math notranslate nohighlight">\(\Psi _0\)</span> or <span class="math notranslate nohighlight">\(\Psi _1\)</span> to different new
tapes.</p></li>
<li><p>Otherwise, just apply the same existing gate to both new tapes.</p></li>
</ul>
<p>In code, this looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cut_index</span> <span class="o">=</span> <span class="mi">0</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">wire_cut</span></a> <span class="o">=</span> <span class="kc">None</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">op</span></a> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape.operations" title="pennylane.tape.QuantumTape.operations" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-attribute"><span class="n">tape</span><span class="o">.</span><span class="n">operations</span></a><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">op</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">WireCut</span></a><span class="p">):</span>
        <span class="n">cut_index</span> <span class="o">=</span> <span class="n">i</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">wire_cut</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut" title="pennylane.WireCut" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">op</span></a>
        <span class="k">break</span>

<span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut.wires" title="pennylane.WireCut.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">wire_cut</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">k</span>

<span class="n">K0</span><span class="p">,</span> <span class="n">K1</span> <span class="o">=</span> <span class="n">make_kraus_ops</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>  <span class="c1"># Generate Kraus operators on the fly</span>
<span class="n">probs</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">d</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Probabilities of the two channels</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitChannel.html#pennylane.QubitChannel" title="pennylane.QubitChannel" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">psi_0</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitChannel.html#pennylane.QubitChannel" title="pennylane.QubitChannel" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitChannel</span></a><span class="p">(</span><span class="n">K0</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut.wires" title="pennylane.WireCut.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">wire_cut</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitChannel.html#pennylane.QubitChannel" title="pennylane.QubitChannel" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">psi_1</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitChannel.html#pennylane.QubitChannel" title="pennylane.QubitChannel" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitChannel</span></a><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.WireCut.html#pennylane.WireCut.wires" title="pennylane.WireCut.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">wire_cut</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>

<span class="n">ops_0</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape.operations" title="pennylane.tape.QuantumTape.operations" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-attribute"><span class="n">tape</span><span class="o">.</span><span class="n">operations</span></a>
<span class="n">ops_0</span><span class="p">[</span><span class="n">cut_index</span><span class="p">]</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitChannel.html#pennylane.QubitChannel" title="pennylane.QubitChannel" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">psi_0</span></a>
<span class="n">ops_1</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape.operations" title="pennylane.tape.QuantumTape.operations" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-attribute"><span class="n">tape</span><span class="o">.</span><span class="n">operations</span></a>
<span class="n">ops_1</span><span class="p">[</span><span class="n">cut_index</span><span class="p">]</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitChannel.html#pennylane.QubitChannel" title="pennylane.QubitChannel" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">psi_1</span></a>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape0</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class"><span class="n">QuantumTape</span></a><span class="p">(</span><span class="n">ops</span><span class="o">=</span><span class="n">ops_0</span><span class="p">,</span> <span class="n">measurements</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape.measurements" title="pennylane.tape.QuantumTape.measurements" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-attribute"><span class="n">tape</span><span class="o">.</span><span class="n">measurements</span></a><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape1</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class"><span class="n">QuantumTape</span></a><span class="p">(</span><span class="n">ops</span><span class="o">=</span><span class="n">ops_1</span><span class="p">,</span> <span class="n">measurements</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape.measurements" title="pennylane.tape.QuantumTape.measurements" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-attribute"><span class="n">tape</span><span class="o">.</span><span class="n">measurements</span></a><span class="p">)</span>
</pre></div>
</div>
<p>Verify that we get expected values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cut size: k=</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel probabilities: p0=</span><span class="si">{</span><span class="n">probs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">; p1=</span><span class="si">{</span><span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.drawer.tape_mpl.html#pennylane.drawer.tape_mpl" title="pennylane.drawer.tape_mpl" class="sphx-glr-backref-module-pennylane-drawer sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">drawer</span><span class="o">.</span><span class="n">tape_mpl</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape0</span></a><span class="p">,</span> <span class="n">expansion_strategy</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_quantum_circuit_cutting_005.png" srcset="../_images/sphx_glr_tutorial_quantum_circuit_cutting_005.png" alt="tutorial quantum circuit cutting" class = "sphx-glr-single-img"/><div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Cut size: k=3
Channel probabilities: p0=0.53; p1=0.47
</pre></div>
</div>
<p>You may have noticed that both generarated tapes have the same size as
the original <code class="docutils literal notranslate"><span class="pre">tape</span></code>. It may seem that no circuit cutting actually took
place. However, this is just an artifact of the way we chose to
represent <strong>classical communication</strong> between subcircuits.
Measure-and-prepare channels at work here are more naturally implemented
on a mixed-state simulator. On a real quantum device however,
introducing a classical communication step is equivalent to separating
the circuit into two.</p>
<p>Given that we are dealing with quantum channels, we need a mixed-state
simulator. Luckily, PennyLane has just what we need:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.mixed&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires" class="sphx-glr-backref-module-pennylane-wires sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>
</pre></div>
</div>
<p>We only need a single run each of the two generated tapes, <code class="docutils literal notranslate"><span class="pre">tape0</span></code> and
<code class="docutils literal notranslate"><span class="pre">tape1</span></code>, collecting the appropriate number of samples. NumPy can
take care of this for us - we let <code class="docutils literal notranslate"><span class="pre">np.choice</span></code> make our decision on
which tape to run for each shot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">samples</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_shots</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.wires.Wires.html#pennylane.wires.Wires" title="pennylane.wires.Wires" class="sphx-glr-backref-module-pennylane-wires sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1337</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">choices</span></a> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_shots</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">probs</span><span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">channels</span></a><span class="p">,</span> <span class="n">channel_shots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">choices</span></a><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Which channel to run:&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">choices</span></a><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel 0: </span><span class="si">{</span><span class="n">channel_shots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> times&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel 1: </span><span class="si">{</span><span class="n">channel_shots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> times.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Which channel to run: [1 0 1 ... 0 1 0]
Channel 0: 5305 times
Channel 1: 4695 times.
</pre></div>
</div>
<p>Time to run the simulator!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.shots" title="pennylane.QubitDevice.shots" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">device</span><span class="o">.</span><span class="n">shots</span></a> <span class="o">=</span> <span class="n">channel_shots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
<span class="p">(</span><span class="n">shots0</span><span class="p">,)</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.execute.html#pennylane.execute" title="pennylane.execute" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">execute</span></a><span class="p">([</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape0</span></a><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gradient_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">samples</span></a><span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">choices</span></a> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">shots0</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.shots" title="pennylane.QubitDevice.shots" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">device</span><span class="o">.</span><span class="n">shots</span></a> <span class="o">=</span> <span class="n">channel_shots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
<span class="p">(</span><span class="n">shots1</span><span class="p">,)</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.execute.html#pennylane.execute" title="pennylane.execute" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">execute</span></a><span class="p">([</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.tape.QuantumTape.html#pennylane.tape.QuantumTape" title="pennylane.tape.QuantumTape" class="sphx-glr-backref-module-pennylane-tape sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">tape1</span></a><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gradient_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">samples</span></a><span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">choices</span></a> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shots1</span>
</pre></div>
</div>
<p>Now that we have the result stored in <code class="docutils literal notranslate"><span class="pre">samples</span></code>, we still need to do
some post-processing to obtain final estimates of the QAOA cost. In the
case of a single cut, the resolution of the identity discussed earlier
implies</p>
<div class="math notranslate nohighlight">
\[\left\langle H_\mathcal{C} (x) \right\rangle  = (d +1) \left\langle H_\mathcal{C} (x) \right\rangle _{z=0} - d \left\langle H_\mathcal{C} (x) \right\rangle _{z=1},\]</div>
<p>where <span class="math notranslate nohighlight">\(d=2^k\)</span> and <span class="math notranslate nohighlight">\(z=0,1\)</span> corresponds to circuits with inserted
channels <span class="math notranslate nohighlight">\(\Psi _{0,1}\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">k</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">randomized_cost_values</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">pauli_cost_values</span></a><span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">signs</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_signs</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">signs</span></a><span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">choices</span></a><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cutoff</span></a> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_counts</span></a><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">costs</span></a> <span class="o">=</span> <span class="n">qaoa_cost</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">samples</span></a><span class="p">[:</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cutoff</span></a><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">randomized_cost_values</span></a><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_signs</span></a><span class="p">[:</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cutoff</span></a><span class="p">]</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">costs</span></a><span class="p">)</span>
</pre></div>
</div>
<p>Let’s plot the results comparing the two methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_counts</span></a><span class="p">,</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">pauli_cost_values</span></a><span class="p">,</span>
    <span class="s2">&quot;o-&quot;</span><span class="p">,</span>
    <span class="n">c</span><span class="o">=</span><span class="s2">&quot;darkorange&quot;</span><span class="p">,</span>
    <span class="n">ms</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">markeredgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Pauli&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">shot_counts</span></a><span class="p">,</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">randomized_cost_values</span></a><span class="p">,</span>
    <span class="s2">&quot;o-&quot;</span><span class="p">,</span>
    <span class="n">c</span><span class="o">=</span><span class="s2">&quot;steelblue&quot;</span><span class="p">,</span>
    <span class="n">ms</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">markeredgecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Randomized&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">optimal_cost</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Exact value&quot;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;QAOA cost&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Number of shots&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_quantum_circuit_cutting_006.png" srcset="../_images/sphx_glr_tutorial_quantum_circuit_cutting_006.png" alt="tutorial quantum circuit cutting" class = "sphx-glr-single-img"/><p>We see that the randomized method converges faster than the Pauli method
- fewer shots will get us a better estimate of the true cost function.
This is even more apparent when we increase the number of shots and go
to larger graphs and/or QAOA depths <span class="math notranslate nohighlight">\(p\)</span>. For example, here are
some results that include cost variances as well as mean values for a
varying number of shots.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/shots_vs_cost_p1.svg"><img alt="../_images/shots_vs_cost_p1.svg" src="../_images/shots_vs_cost_p1.svg" width="70%" /></a>
</div>
<div class="figure align-center" id="id10">
<a class="reference internal image-reference" href="../_images/shots_vs_cost_p2.svg"><img alt="../_images/shots_vs_cost_p2.svg" src="../_images/shots_vs_cost_p2.svg" width="70%" /></a>
<p class="caption"><span class="caption-text">Figure 6. An example of QAOA cost convergence for a circuit cut both
with the Pauli method and randomized channel method.</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>The randomized method offers a quadratic overhead reduction. In
practice, for larger cuts, we see that it offers a performance that is orders of magnitude
better than that of the Pauli method. For larger circuits, even at
<span class="math notranslate nohighlight">\(10^6\)</span> shots, Pauli estimates still sometimes leave the allowed
interval of <span class="math notranslate nohighlight">\([-1,1]\)</span>.</p>
<p>However, these improvements come at the cost of increased circuit depth
due to inserting random Clifford gates and additional classical
communication required.</p>
</div>
<div class="section" id="multiple-cuts-and-mid-circuit-measurements">
<h3>Multiple cuts and mid-circuit measurements<a class="headerlink" href="#multiple-cuts-and-mid-circuit-measurements" title="Permalink to this headline">¶</a></h3>
<p>Careful readers may have noticed that QAOA at depth <span class="math notranslate nohighlight">\(p=1\)</span> has a
specific structure of a <a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_tn_circuits.html">Matrix Product
State</a>
(MPS) circuit. However, in order to cut a <span class="math notranslate nohighlight">\(p=2\)</span> QAOA circuit, we
would need 2 cuts. This introduces some subtleties within the context of
classical simulation that we point out here.</p>
<p>The measurement performed as a part of the first cut always induces a
reduced state on the remaining wires. If the circuit has an MPS
structure, we can just measure all qubits at once —a part of the
measured bitstring gets passed into the second fragment and the
remaining bits go directly into the output bitstring. However, when we
try the same thing on a non-MPS circuit, additional gates need to be
applied on the wires that now hold a reduced state. This is the other
reason why it is easier to simulate circuit cutting of a non-MPS circuit
with a mixed-state simulator.</p>
<div class="figure align-center" id="id11">
<a class="reference internal image-reference" href="../_images/mid_circuit_measure.svg"><img alt="../_images/mid_circuit_measure.svg" src="../_images/mid_circuit_measure.svg" width="90%" /></a>
<p class="caption"><span class="caption-text">Figure 7. A schematic representation of the mid-circuit measurement
“problem”.</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</div>
<p>Note that, in these cases, memory requirements of classical simulation
are increased from <span class="math notranslate nohighlight">\(O(2^n)\)</span> to <span class="math notranslate nohighlight">\(O(4^n)\)</span>. However, this is
only a constraint for classical simulation where we have to choose
between state-vector and density-matrix approaches. Real quantum
devices don’t have such limitations, of course.</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="peng2019"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>T. Peng, A. Harrow, M. Ozols, and X. Wu (2019) “Simulating Large Quantum Circuits on a Small Quantum Computer”.
(<a class="reference external" href="https://arxiv.org/abs/1904.00102">arXiv</a>)</p>
</dd>
<dt class="label" id="lowe2022"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>A. Lowe et. al. (2022) “Fast quantum circuit cutting with randomized measurements”.
(<a class="reference external" href="https://arxiv.org/abs/2207.14734">arXiv</a>)</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-authors">
<h2>About the authors<a class="headerlink" href="#about-the-authors" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/gideon_uchehara.jpg" alt="Gideon Uchehara" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Gideon Uchehara</h4>
        <p class="bio-text__author-description">Gideon is a PhD student at the University of British Columbia, Canada. His research is in quantum algorithms and quantum machine learning. He works at Xanadu as a Quantum Computing Educator Intern. He recently started the Blacks In Quantum (BIQ) initiative and also serves as the student representative on the International Program Committee for the Quantum Computing NSERC CREATE Program, British Columbia, Canada.</p>
    </div>
</div><div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/matija_medvidovic.jpeg" alt="Matija Medvidović" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Matija Medvidović</h4>
        <p class="bio-text__author-description">Matija is a PhD student at Columbia University and the Flatiron Institute in New York. He works with machine learning methods to study quantum many-body physics and quantum computers. He is currently a part of the Xanadu Residency Program. He is a firm believer in keeping bios short and concise.</p>
    </div>
</div><div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/anuj_apte.jpg" alt="Anuj Apte" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Anuj Apte</h4>
        <p class="bio-text__author-description">Anuj is a PhD student at the University of Chicago. His research interests include quantum field theory with applications to topological phases and quantum computing.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 10 minutes  1.537 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-quantum-circuit-cutting-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/5b8d7876882a29b4e3aee2e0b0cf5aef/tutorial_quantum_circuit_cutting.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_quantum_circuit_cutting.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/de635fa02822d7566783700152d1ddbe/tutorial_quantum_circuit_cutting.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_quantum_circuit_cutting.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_quantum_circuit_cutting</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Quantum Circuit Cutting</a><ul class='current'>
<li class='current'><a class="reference internal" href="#introduction">Introduction</a></li>
<li class='current'><a class="reference internal" href="#background-understanding-the-pauli-cutting-method">Background: Understanding the Pauli cutting method</a><ul class='current'>
<li class='current'><a class="reference internal" href="#pennylane-implementation">PennyLane implementation</a></li>
<li class='current'><a class="reference internal" href="#automatic-cut-placement"><strong>Automatic cut placement</strong></a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#randomized-circuit-cutting">Randomized Circuit Cutting</a></li>
<li class='current'><a class="reference internal" href="#comparison">Comparison</a><ul class='current'>
<li class='current'><a class="reference internal" href="#setup">Setup</a></li>
<li class='current'><a class="reference internal" href="#the-pauli-cutting-method">The Pauli cutting method</a></li>
<li class='current'><a class="reference internal" href="#the-randomized-channel-based-cutting-method">The randomized channel-based cutting method</a></li>
<li class='current'><a class="reference internal" href="#multiple-cuts-and-mid-circuit-measurements">Multiple cuts and mid-circuit measurements</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-authors">About the authors</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_quantum_circuit_cutting</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_quantum-computing.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_testing_symmetry.html" title="Testing for symmetry with quantum computers"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_toric_code.html" title="Modeling the toric code on a quantum computer"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_quantum-computing.html" >Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Quantum Circuit Cutting</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>