
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Finding a QK to approximate the Gaussian kernel." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/toy_qek.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="How to approximate a classical kernel with a quantum computer &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_classical_kernels.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Finding a QK to approximate the Gaussian kernel." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>How to approximate a classical kernel with a quantum computer &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_classical_kernels.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tensor-network quantum circuits" href="tutorial_tn_circuits.html" />
    <link rel="prev" title="Quantum GANs" href="tutorial_quantum_gans.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_tn_circuits.html" title="Tensor-network quantum circuits"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_quantum_gans.html" title="Quantum GANs"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_qml.html" accesskey="U">Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to approximate a classical kernel with a quantum computer</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#sphx-glr-download-demos-tutorial-classical-kernels-py"><span class="std std-ref">Go to the end</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="how-to-approximate-a-classical-kernel-with-a-quantum-computer">
<span id="classical-kernels"></span><span id="sphx-glr-demos-tutorial-classical-kernels-py"></span><h1>How to approximate a classical kernel with a quantum computer<a class="headerlink" href="#how-to-approximate-a-classical-kernel-with-a-quantum-computer" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_kernels_module.html", "tutorial_kernel_based_training.html", "scikit-learn.html", "tutorial_expressivity_fourier_series.html"];
    var related_tutorials_titles = ['Training and evaluating quantum kernels', 'Kernel-based training of quantum models with', '', 'Quantum models as Fourier series'];
</script></p>
<p><em>Author: Elies Gil-Fuster (Xanadu Resident) — Posted: 01 Mar 2022. Last updated: 02 March 2022</em></p>
<p>Forget about advantages, supremacies, or speed-ups.
Let us understand better what we can and cannot do with a quantum computer.
More specifically, in this demo, we want to look into quantum kernels and ask
whether we can replicate classical kernel functions with a quantum computer.
Lots of researchers have lengthily stared at the opposite question, namely that
of classical simulation of quantum algorithms.
Yet, by studying what classes of functions we can realize with quantum kernels,
we can gain some insight into their inner workings.</p>
<p>Usually, in quantum machine learning (QML), we use parametrized quantum circuits
(PQCs) to find good functions, whatever <em>good</em> means here.
Since kernels are just one specific kind of well-defined
functions, the task of finding a quantum kernel (QK) that approximates a given
classical one could be posed as an optimization problem.
One way to attack this task is to define a loss function
quantifying the distance between both functions (the classical kernel function
and the PQC-based hypothesis).
This sort of approach does not help us much to gain theoretical insights about the
structure of kernel-emulating quantum circuits, though.</p>
<p>In order to build intuition, we will instead study the link between classical and quantum kernels through the
lens of the Fourier representation of a kernel, which is a common tool in
classical machine learning.
Two functions can only have the same Fourier spectrum if they are the same
function. It turns out that, for certain classes of quantum circuits, <a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_expressivity_fourier_series.html">we can
theoretically describe the Fourier spectrum rather well</a>.</p>
<p>Using this theory, together with some good old-fashioned convex optimization, we
will derive a quantum circuit that approximates the famous Gaussian kernel.</p>
<p>In order to keep the demo short and sweet, we focus on one simple example. The
same ideas apply to more general scenarios.
Also, Refs. <a class="footnote-reference brackets" href="#qek" id="id1">1</a>, <a class="footnote-reference brackets" href="#fourier" id="id2">2</a>, and <a class="footnote-reference brackets" href="#qkernels" id="id3">3</a> should be helpful for those
who’d like to see the underlying theory of QKs (and also so-called <em>Quantum Embedding
Kernels</em>) and their Fourier representation.
So tag along if you’d like to see how we build a quantum kernel that
approximates the well-known Gaussian kernel function!</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center" id="id4">
<a class="reference external image-reference" href="javascript:void(0)"><img alt="../_images/classical_kernels_flow_chart.png" src="../_images/classical_kernels_flow_chart.png" style="width: 60%;" /></a>
<p class="caption"><span class="caption-text">Schematic of the steps covered in this demo.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="kernel-based-machine-learning">
<h2>Kernel-based Machine Learning<a class="headerlink" href="#kernel-based-machine-learning" title="Permalink to this headline">¶</a></h2>
<p>We will not be reviewing all the notions of kernels in-depth here.
Instead, we only need to know that an entire branch of machine learning
revolves around some functions we call kernels.
If you’d like to learn more about where these functions
come from, why they’re important, and how we can use them (e.g. with
PennyLane), check out the following demos, which cover different
aspects extensively:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_kernels_module.html">Training and evaluating quantum kernels</a></p></li>
<li><p><a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_kernel_based_training.html">Kernel-based training of quantum models with scikit-learn</a></p></li>
</ol>
<p>For the purposes of this demo, a <em>kernel</em> is a real-valued function of two
variables <span class="math notranslate nohighlight">\(k(x_1,x_2)\)</span> from a given data domain <span class="math notranslate nohighlight">\(x_1,
x_2\in\mathcal{X}\)</span>.
In this demo, we’ll deal with real vector spaces as the data
domain <span class="math notranslate nohighlight">\(\mathcal{X}\subseteq\mathbb{R}^d\)</span>, of some dimension <span class="math notranslate nohighlight">\(d\)</span>.
A kernel has to be symmetric with respect to exchanging both variables
<span class="math notranslate nohighlight">\(k(x_1,x_2) = k(x_2,x_1)\)</span>.
We also enforce kernels to be positive semi-definite, but let’s avoid getting
lost in mathematical lingo. You can trust that all kernels featured in this
demo are positive semi-definite.</p>
</div>
<div class="section" id="shift-invariant-kernels">
<h2>Shift-invariant kernels<a class="headerlink" href="#shift-invariant-kernels" title="Permalink to this headline">¶</a></h2>
<p>Some kernels fulfill another important restriction, called <em>shift-invariance</em>.
Shift-invariant kernels are those whose value doesn’t change if we add a shift
to both inputs.
Explicitly, for any suitable shift vector <span class="math notranslate nohighlight">\(\zeta\in\mathcal{X}\)</span>,
shift-invariant kernels are those for which
<span class="math notranslate nohighlight">\(k(x_1+\zeta,x_2+\zeta)=k(x_1,x_2)\)</span> holds.
Having this property means the function can be written in
terms of only one variable, which we call the <em>lag vector</em>
<span class="math notranslate nohighlight">\(\delta:=x_1-x_2\in\mathcal{X}\)</span>. Abusing notation a bit:</p>
<div class="math notranslate nohighlight">
\[k(x_1,x_2)=k(x_1-x_2,0) = k(\delta).\]</div>
<p>For shift-invariant kernels, the exchange symmetry property
<span class="math notranslate nohighlight">\(k(x_1,x_2)=k(x_2,x_1)\)</span> translates into reflection symmetry
<span class="math notranslate nohighlight">\(k(\delta)=k(-\delta)\)</span>.
Accordingly, we say <span class="math notranslate nohighlight">\(k\)</span> is an <em>even function</em>.</p>
</div>
<div class="section" id="warm-up-implementing-the-gaussian-kernel">
<h2>Warm up: Implementing the Gaussian kernel<a class="headerlink" href="#warm-up-implementing-the-gaussian-kernel" title="Permalink to this headline">¶</a></h2>
<p>First, let’s introduce a simple classical kernel that we will
approximate on the quantum computer.
Start importing the usual suspects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">53173</span><span class="p">)</span>
</pre></div>
</div>
<p>We’ll look at the Gaussian kernel:
<span class="math notranslate nohighlight">\(k_\sigma(x_1,x_2):=e^{-\lVert x_1-x_2\rVert^2/2\sigma^2}\)</span>.
This function is clearly shift-invariant:</p>
<div class="math notranslate nohighlight">
\[\begin{split}k_\sigma(x_1+\zeta,x_2+\zeta) &amp;= e^{-\lVert(x_1+\zeta)-(x_2+\zeta)\rVert^2/2\sigma^2} \\
&amp; = e^{-\lVert x_1-x_2\rVert^2/2\sigma^2} \\
&amp; = k_\sigma(x_1,x_2).\end{split}\]</div>
<p>The object of our study will be a simple version of the Gaussian kernel,
where we consider <span class="math notranslate nohighlight">\(1\)</span>-dimensional data, so <span class="math notranslate nohighlight">\(\lVert
x_1-x_2\rVert^2=(x_1-x_2)^2\)</span>.
Also, we take <span class="math notranslate nohighlight">\(\sigma=1/\sqrt{2}\)</span> so that we further simplify the
exponent.
We can always re-introduce it later by rescaling the data.
Again, we can write the function in terms of the lag vector only:</p>
<div class="math notranslate nohighlight">
\[k(\delta)=e^{-\delta^2}.\]</div>
<p>Now let’s write a few lines to plot the Gaussian kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gaussian_kernel</span><span class="p">(</span><span class="n">delta</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make_data</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">lower</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">higher</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">higher</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">gaussian_kernel</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Y_gaussian</span></a> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Y_gaussian</span></a><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;The Gaussian kernel with $\sigma=1/\sqrt</span><span class="si">{2}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$\delta$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;$k(\delta)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_001.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_001.png" alt="The Gaussian kernel with $\sigma=1/\sqrt{2}$" class = "sphx-glr-single-img"/><p>In this demo, we will consider only this one example. However, the arguments we
make and the code we use are also amenable to any kernel with the following
mild restrictions:</p>
<ol class="arabic simple">
<li><p>Shift-invariance</p></li>
<li><p>Normalization <span class="math notranslate nohighlight">\(k(0)=1\)</span>.</p></li>
<li><p>Smoothness (in the sense of a quickly decaying Fourier spectrum).</p></li>
</ol>
<p>Note that is a very large class of kernels!
And also an important one for practical applications.</p>
</div>
<div class="section" id="fourier-analysis-of-the-gaussian-kernel">
<h2>Fourier analysis of the Gaussian kernel<a class="headerlink" href="#fourier-analysis-of-the-gaussian-kernel" title="Permalink to this headline">¶</a></h2>
<p>The next step will be to find the Fourier spectrum of the Gaussian
kernel, which is an easy problem for classical computers.
Once we’ve found it, we’ll build a QK that produces a finite Fourier series
approximation to that spectrum.</p>
<p>Let’s briefly recall that a Fourier series is the representation of a
periodic function using the sine and cosine functions.
Fourier analysis tells us that we can write any given periodic function as</p>
<div class="math notranslate nohighlight">
\[f(x) = a_0 + \sum_{n=1}^\infty a_n\cos(n\omega_0x) + b_n\sin(n\omega_0x).\]</div>
<p>For that, we only need to find the suitable base frequency <span class="math notranslate nohighlight">\(\omega_0\)</span>
and coefficients <span class="math notranslate nohighlight">\(a_0, a_1, \ldots, b_0, b_1,\ldots\)</span>.</p>
<p>But the Gaussian kernel is an aperiodic function, whereas the Fourier series
only makes sense for periodic functions!</p>
<p><em>What can we do?!</em></p>
<p>We can cook up a periodic extension to the Gaussian kernel, for a given
period <span class="math notranslate nohighlight">\(2L\)</span> (we take <span class="math notranslate nohighlight">\(L=\pi\)</span> as default):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Gauss_p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="c1"># Send x to x_mod in the period around 0</span>
    <span class="n">x_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span>
    <span class="k">return</span> <span class="n">gaussian_kernel</span><span class="p">(</span><span class="n">x_mod</span><span class="p">)</span>
</pre></div>
</div>
<p>which we can now plot</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x_func</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">321</span><span class="p">)</span>
<span class="n">y_func</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gauss_p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x_func</span></a><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x_func</span></a><span class="p">,</span> <span class="n">y_func</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$\delta$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Periodic extension to the Gaussian kernel&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_002.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_002.png" alt="Periodic extension to the Gaussian kernel" class = "sphx-glr-single-img"/><p>In practice, we would construct several periodic extensions of the aperiodic
function, with increasing periods.
This way, we can study the behaviour when the period approaches
infinity, i.e. the regime where the function stops being periodic.</p>
<p>Next up, how does the Fourier spectrum of such an object look like?
We can find out using PennyLane’s <code class="docutils literal notranslate"><span class="pre">fourier</span></code> module!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane.fourier</span> <span class="kn">import</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.coefficients.html#pennylane.fourier.coefficients" title="pennylane.fourier.coefficients" class="sphx-glr-backref-module-pennylane-fourier sphx-glr-backref-type-py-function"><span class="n">coefficients</span></a>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">coefficients</span></code> computes for us the coefficients of the Fourier
series up to a fixed term.
One tiny detail here: <code class="docutils literal notranslate"><span class="pre">coefficients</span></code> returns one complex number <span class="math notranslate nohighlight">\(c_n\)</span>
for each frequency <span class="math notranslate nohighlight">\(n\)</span>.
The real part corresponds to the <span class="math notranslate nohighlight">\(a_n\)</span> coefficient, and the imaginary
part to the <span class="math notranslate nohighlight">\(b_n\)</span> coefficient: <span class="math notranslate nohighlight">\(c_n=a_n+ib_n\)</span>.
Because the Gaussian kernel is an even function, we know that the imaginary part
of every coefficient will be zero, so <span class="math notranslate nohighlight">\(c_n=a_n\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fourier_p</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We only take the first d coefficients [:d]</span>
<span class="sd">    because coefficients() treats the negative frequencies</span>
<span class="sd">    as different from the positive ones.</span>
<span class="sd">    For real functions, they are the same.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.coefficients.html#pennylane.fourier.coefficients" title="pennylane.fourier.coefficients" class="sphx-glr-backref-module-pennylane-fourier sphx-glr-backref-type-py-function"><span class="n">coefficients</span></a><span class="p">(</span><span class="n">Gauss_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:</span><span class="n">d</span><span class="p">])</span>
</pre></div>
</div>
<p>We are restricted to considering only a finite number of Fourier
terms.
But isn’t that problematic, one may say?
Well, maybe.
Since we know the Gaussian kernel is a smooth function, we expect that the
coefficients converge to <span class="math notranslate nohighlight">\(0\)</span> at some point, and we will only need to
consider terms up to this point.
Let’s look at the coefficients we obtain by setting a low value for the
number of coefficients and then slowly letting it grow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">):</span>
    <span class="n">N</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">fourier_p</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;frequency $n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fourier coefficient $c_n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_003.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_003.png" alt="tutorial classical kernels" class = "sphx-glr-single-img"/><p>What do we see?
For very small coefficient counts, like <span class="math notranslate nohighlight">\(2\)</span> and <span class="math notranslate nohighlight">\(3\)</span>, we see that
the last allowed coefficient is still far from <span class="math notranslate nohighlight">\(0\)</span>.
That’s a very clear indicator that we need to consider more frequencies.
At the same time, it seems like starting at <span class="math notranslate nohighlight">\(5\)</span> or <span class="math notranslate nohighlight">\(6\)</span> all the
non-zero contributions have already been well captured.
This is important for us, since it tells us the minimum number of qubits we should use.
One can see that every new qubit doubles the number of frequencies we can
use, so for <span class="math notranslate nohighlight">\(n\)</span> qubits, we will have <span class="math notranslate nohighlight">\(2^n\)</span>.
At minimum of <span class="math notranslate nohighlight">\(6\)</span> frequencies means at least <span class="math notranslate nohighlight">\(3\)</span> qubits, corresponding
to <span class="math notranslate nohighlight">\(2^3=8\)</span> frequencies.
As we’ll see later, we’ll work with <span class="math notranslate nohighlight">\(5\)</span> qubits, so <span class="math notranslate nohighlight">\(32\)</span>
frequencies.
That means the spectrum we will be trying to replicate will be the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">fourier_p</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;frequency $n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fourier coefficient $c_n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Fourier spectrum of the Gaussian kernel&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_004.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_004.png" alt="Fourier spectrum of the Gaussian kernel" class = "sphx-glr-single-img"/><p>We just need a QK with the same Fourier spectrum!</p>
</div>
<div class="section" id="designing-a-suitable-qk">
<h2>Designing a suitable QK<a class="headerlink" href="#designing-a-suitable-qk" title="Permalink to this headline">¶</a></h2>
<p>Designing a suitable QK amounts to designing a suitable parametrized quantum
circuit.
Let’s take a moment to refresh the big scheme of things with the following
picture:</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center" id="id5">
<a class="reference external image-reference" href="javascript:void(0)"><img alt="../_images/QEK.jpg" src="../_images/QEK.jpg" style="width: 70%;" /></a>
<p class="caption"><span class="caption-text">The quantum kernel considered in this demo.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p>We construct the quantum kernel from a quantum embedding (see the demo on
<a class="reference external" href="pennylane.ai/qml/demos/tutorial_kernels_module.html">Quantum Embedding Kernels</a>).
The quantum embedding circuit will consist of two parts.
The first one, trainable, will be a parametrized general state preparation
scheme <span class="math notranslate nohighlight">\(W_a\)</span>, with parameters <span class="math notranslate nohighlight">\(a\)</span>.
In the second one, we input the data, denoted by <span class="math notranslate nohighlight">\(S(x)\)</span>.</p>
<p>Start with the non-trainable gate we’ll use to encode the data <span class="math notranslate nohighlight">\(S(x)\)</span>.
It consists of applying one Pauli-<span class="math notranslate nohighlight">\(Z\)</span> rotation to each qubit with
rotation parameter <span class="math notranslate nohighlight">\(x\)</span> times some constant <span class="math notranslate nohighlight">\(\vartheta_i\)</span>, for
the <span class="math notranslate nohighlight">\(i^\text{th}\)</span> qubit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <span class="n">wires</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">wire</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wires</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">thetas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">wires</span> <span class="o">=</span> <span class="p">[</span><span class="n">wire</span><span class="p">])</span>
</pre></div>
</div>
<p>By setting the <code class="docutils literal notranslate"><span class="pre">thetas</span></code> properly, we achieve the integer-valued spectrum,
as required by the Fourier series expansion of a function of period
<span class="math notranslate nohighlight">\(2\pi\)</span>:
<span class="math notranslate nohighlight">\(\{0, 1, \ldots, 2^n-2, 2^n-1\}\)</span>, for <span class="math notranslate nohighlight">\(n\)</span> qubits.
Some math shows that setting <span class="math notranslate nohighlight">\(\vartheta_i=2^{n-i}\)</span>, for
<span class="math notranslate nohighlight">\(\{1,\ldots,n\}\)</span> produces the desired outcome.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_thetas</span><span class="p">(</span><span class="n">n_wires</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_wires</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>Next, we introduce the only trainable gate we need to make use of.
Contrary to the usual Ansätze used in supervised and unsupervised learning,
we use a state preparation template called <code class="docutils literal notranslate"><span class="pre">MottonenStatePreparation</span></code>.
This is one option for amplitude encoding already implemented in PennyLane,
so we don’t need to code it ourselves.
Amplitude encoding is a common way of embedding classical data into a quantum
system in QML.
The unitary associated to this template transforms the <span class="math notranslate nohighlight">\(\lvert0\rangle\)</span>
state into a state with amplitudes <span class="math notranslate nohighlight">\(a=(a_0,a_1,\ldots,a_{2^n-1})\)</span>,
namely <span class="math notranslate nohighlight">\(\lvert a\rangle=\sum_j a_j\lvert j\rangle\)</span>, provided
<span class="math notranslate nohighlight">\(\lVert a\rVert^2=1\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">W</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">wires</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.MottonenStatePreparation.html#pennylane.MottonenStatePreparation" title="pennylane.MottonenStatePreparation" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">state_preparations</span><span class="o">.</span><span class="n">MottonenStatePreparation</span></a><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">wires</span><span class="p">)</span>
</pre></div>
</div>
<p>With that, we have the feature map onto the Hilbert space of the quantum
computer:</p>
<div class="math notranslate nohighlight">
\[\lvert x_a\rangle = S(x)W_a\lvert0\rangle,\]</div>
<p>for a given <span class="math notranslate nohighlight">\(a\)</span>, which we will specify later.</p>
<p>Accordingly, we can build the QK corresponding to this feature map as</p>
<div class="math notranslate nohighlight">
\[\begin{split}k_a(x_1,x_2) &amp;= \lvert\langle0\rvert W_a^\dagger S^\dagger(x_1)
S(x_2)W_a\lvert0\rangle\rvert^2 \\
&amp;= \lvert\langle0\rvert W_a^\dagger S(x_2-x_1) W_a\lvert0\rangle\rvert^2.\end{split}\]</div>
<p>In the code below, the variable <code class="docutils literal notranslate"><span class="pre">amplitudes</span></code> corresponds to our set  <span class="math notranslate nohighlight">\(a\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ansatz</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">,</span> <span class="n">wires</span><span class="p">):</span>
    <span class="n">W</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">,</span> <span class="n">wires</span><span class="p">)</span>
    <span class="n">S</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <span class="n">wires</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.adjoint.html#pennylane.adjoint" title="pennylane.adjoint" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">adjoint</span></a><span class="p">(</span><span class="n">W</span><span class="p">)(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">,</span> <span class="n">wires</span><span class="p">)</span>
</pre></div>
</div>
<p>Since this kernel is by construction real-valued, we also have</p>
<div class="math notranslate nohighlight">
\[\begin{split}(k_a(x_1,x_2))^\ast &amp;= k_a(x_1,x_2) \\
&amp;= \lvert\langle0\rvert W_a^\dagger S(x_1-x_2) W_a\lvert0\rangle\rvert^2 \\
&amp;= k_a(x_2,x_1).\end{split}\]</div>
<p>Further, this QK is also shift-invariant <span class="math notranslate nohighlight">\(k_a(x_1,x_2) = k_a(x_1+\zeta,
x_2+\zeta)\)</span> for any <span class="math notranslate nohighlight">\(\zeta\in\mathbb{R}\)</span>.
So we can also write it in terms of the lag <span class="math notranslate nohighlight">\(\delta=x_1-x_2\)</span>:</p>
<div class="math notranslate nohighlight">
\[k_a(\delta) = \lvert\langle0\rvert W_a^\dagger
S(\delta)W_a\lvert0\rangle\rvert^2.\]</div>
<p>So far, we only wrote the gate layout for the quantum circuit, no measurement!
We need a few more functions for that!</p>
</div>
<div class="section" id="computing-the-qk-function-on-a-quantum-device">
<h2>Computing the QK function on a quantum device<a class="headerlink" href="#computing-the-qk-function-on-a-quantum-device" title="Permalink to this headline">¶</a></h2>
<p>Also, at this point, we need to set the number of qubits of our computer.
For this example, we’ll use the variable <code class="docutils literal notranslate"><span class="pre">n_wires</span></code>, and set it to <span class="math notranslate nohighlight">\(5\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_wires</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>We initialize the quantum simulator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;lightning.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span> <span class="o">=</span> <span class="n">n_wires</span><span class="p">,</span> <span class="n">shots</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we construct the quantum node:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">QK_circuit</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">):</span>
    <span class="n">ansatz</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">,</span> <span class="n">wires</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_wires</span><span class="p">))</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.probs.html#pennylane.probs" title="pennylane.probs" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">probs</span></a><span class="p">(</span><span class="n">wires</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_wires</span><span class="p">))</span>
</pre></div>
</div>
<p>Recall that the output of a QK is defined as the probability of obtaining
the outcome <span class="math notranslate nohighlight">\(\lvert0\rangle\)</span> when measuring in the computational basis.
That corresponds to the <span class="math notranslate nohighlight">\(0^\text{th}\)</span> entry of <code class="docutils literal notranslate"><span class="pre">qml.probs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">QK_2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">):</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">QK_circuit</span></a><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>As a couple of quality-of-life improvements, we write a function that implements
the QK with the lag <span class="math notranslate nohighlight">\(\delta\)</span> as its argument, and one that implements it
on a given set of data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">QK</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">):</span>
    <span class="k">return</span> <span class="n">QK_2</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">)</span>

<span class="k">def</span> <span class="nf">QK_on_dataset</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">QK</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">)</span> <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="n">deltas</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
<p>This is also a good place to fix the <code class="docutils literal notranslate"><span class="pre">thetas</span></code> array, so that we don’t forget
later.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">thetas</span> <span class="o">=</span> <span class="n">make_thetas</span><span class="p">(</span><span class="n">n_wires</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s see how this looks like for one particular choice of <code class="docutils literal notranslate"><span class="pre">amplitudes</span></code>.
We need to make sure the array fulfills the normalization conditions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">test_features</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n_wires</span><span class="p">)])</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">test_amplitudes</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">test_features</span></a> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">test_features</span></a> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Y_test</span></a> <span class="o">=</span> <span class="n">QK_on_dataset</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">test_amplitudes</span></a><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Y_test</span></a><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$\delta$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;QK with test amplitudes&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_005.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_005.png" alt="QK with test amplitudes" class = "sphx-glr-single-img"/><p>One can see that the stationary kernel with this particular initial state has
a decaying spectrum that looks similar to <span class="math notranslate nohighlight">\(1/\lvert x\rvert\)</span> — but not
yet like a Gaussian.</p>
<div class="section" id="how-to-find-the-amplitudes-emulating-a-gaussian-kernel">
<h3>How to find the amplitudes emulating a Gaussian kernel<a class="headerlink" href="#how-to-find-the-amplitudes-emulating-a-gaussian-kernel" title="Permalink to this headline">¶</a></h3>
<p>If we knew exactly which amplitudes to choose in order to build a given
Fourier spectrum, our job would be done here.
However, the equations derived in the literature are not trivial to solve.</p>
<p>As mentioned in the introduction, one could just “learn” this relation, that
is, tune the parameters of the quantum kernel in a gradient-based manner
until it matches the classical one.</p>
<p>We want to take an intermediate route between analytical solution and
black-box optimization.
For that, we derive an equation that links the amplitudes to the spectrum we
want to construct and then use old-fashioned convex optimization to find the
solution.
If you are not interested in the details, you can just jump to the last plots
of this demo and confirm that we can to emulate the Gaussian kernel
using the ansatz for our QK constructed above.</p>
<p>In order to simplify the formulas, we introduce new variables, which we call
<code class="docutils literal notranslate"><span class="pre">probabilities</span></code> <span class="math notranslate nohighlight">\((p_0, p_1, p_2, \ldots, p_{2^n-1})\)</span>, and we define as
<span class="math notranslate nohighlight">\(p_j=\lvert a_j\rvert^2\)</span>.
Following the normalization property above, we have <span class="math notranslate nohighlight">\(\sum_j p_j=1\)</span>.
Don’t get too fond of them, we only need them for this step!
Remember we introduced the vector <span class="math notranslate nohighlight">\(a\)</span> for the
<code class="docutils literal notranslate"><span class="pre">MottonenStatePreparation</span></code> as the <em>amplitudes</em> of a quantum state?
Then it makes sense that we call its squares <em>probabilities</em>, doesn’t it?</p>
<p>There is a crazy formula that matches the entries of <em>probabilities</em> with the
Fourier series of the resulting QK function:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{probabilities} &amp;\longrightarrow \text{Fourier coefficients} \\
\begin{pmatrix} p_0 \\ p_1 \\ p_2 \\ \vdots \\ p_{2^n-1} \end{pmatrix}
&amp;\longmapsto \begin{pmatrix} \sum_{j=0}^{2^n-1} p_j^2 \\ \sum_{j=1}^{2^n-1}
p_j p_{j-1} \\ \sum_{j=2}^{2^n-1} p_j p_{j-2} \\ \vdots \\ p_{2^n-1} p_0
\end{pmatrix}\end{split}\]</div>
<p>This looks a bit scary, it follows from expanding the matrix product
<span class="math notranslate nohighlight">\(W_a^\dagger S(\delta)W_a\)</span>, and then collecting terms according to
Fourier basis monomials.
In this sense, the formula is general and it applies to any shift-invariant
kernel we might want to approximate, not only the Gaussian kernel.</p>
<p>Our goal is to find the set of <span class="math notranslate nohighlight">\(p_j\)</span>’s that produces the Fourier
coefficients of a given kernel function (in our case, the Gaussian kernel),
namely its spectrum <span class="math notranslate nohighlight">\((s_0, s_1, s_2, \ldots, s_{2^n-1})\)</span>.
We consider now a slightly different map <span class="math notranslate nohighlight">\(F_s\)</span>, for a given spectrum
<span class="math notranslate nohighlight">\((s_0, s_1, \ldots, s_{2^n-1})\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}F_s: \text{probabilities} &amp;\longrightarrow \text{Difference between Fourier
coefficients} \\
\begin{pmatrix} p_0 \\ p_1 \\ p_2 \\ \vdots \\ p_{2^n-1} \end{pmatrix}
&amp;\longmapsto \begin{pmatrix} \sum_{j=0}^{2^n-1} p_j^2 - s_0 \\
\sum_{j=1}^{2^n-1} p_j p_{j-1} - s_1 \\ \sum_{j=2}^{2^n-1} p_j
p_{j-2} - s_2 \\ \vdots \\ p_{2^n-1}p_0 - s_{2^n-1} \end{pmatrix}.\end{split}\]</div>
<p>If you look at it again, you’ll see that the zero (or solution) of this
second map <span class="math notranslate nohighlight">\(F_s\)</span> is precisely the array of <em>probabilities</em> we are
looking for.
We can write down the first map as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">predict_spectrum</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">s_</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">s_</span> <span class="o">+=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">s</span><span class="p">]</span>

        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span><span class="o">.</span><span class="n">append</span></a><span class="p">(</span><span class="n">s_</span><span class="p">)</span>

    <span class="c1"># This is to make the output have the same format as</span>
    <span class="c1"># the output of pennylane.fourier.coefficients</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span><span class="o">.</span><span class="n">append</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a><span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="n">s</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a>
</pre></div>
</div>
<p>And then <span class="math notranslate nohighlight">\(F_s\)</span> is just <code class="docutils literal notranslate"><span class="pre">predict_spectrum</span></code> minus the spectrum we want to
predict:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">F</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)</span>
    <span class="k">return</span> <span class="n">predict_spectrum</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)[:</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a><span class="p">[:</span><span class="n">d</span><span class="p">]</span>
</pre></div>
</div>
<p>These closed-form equations allow us to find the solution numerically, using
Newton’s method!
Newton’s method is a classical one from convex optimization theory.
For our case, since the formula is quadratic, we rest assured that we are
within the realm of convex functions.</p>
</div>
</div>
<div class="section" id="finding-the-solution">
<h2>Finding the solution<a class="headerlink" href="#finding-the-solution" title="Permalink to this headline">¶</a></h2>
<p>In order to use Newton’s method we need the Jacobian of <span class="math notranslate nohighlight">\(F_s\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">J_F</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">):</span>
                <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">J</span>
</pre></div>
</div>
<p>Showing that this is indeed <span class="math notranslate nohighlight">\(\nabla F_s\)</span> is left as an exercise for the
reader.
For Newton’s method, we also need an initial guess.
Finding a good initial guess requires some tinkering; different problems will
benefit from different ones.
Here is a tame one that works for the Gaussian kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_initial_probabilities</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a> <span class="o">/</span> <span class="n">deg</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a> <span class="o">=</span> <span class="n">make_initial_probabilities</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n_wires</span><span class="p">)</span>
</pre></div>
</div>
<p>Recall the <code class="docutils literal notranslate"><span class="pre">spectrum</span></code> we want to match is that of the periodic extension of
the Gaussian kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a> <span class="o">=</span> <span class="n">fourier_p</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n_wires</span><span class="p">)</span>
</pre></div>
</div>
<p>We fix the hyperparameters for Newton’s method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_wires</span>
<span class="n">max_steps</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.e-20</span>
</pre></div>
</div>
<p>And we’re good to go!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_steps</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">inc</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">J_F</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">),</span> <span class="o">-</span><span class="n">F</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a><span class="p">))</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a> <span class="o">+</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">inc</span></a>
    <span class="k">if</span> <span class="p">(</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error norm at step </span><span class="si">{0:3}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">,</span>
                                                                <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a><span class="p">))))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">spectrum</span></a><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Tolerance trespassed! This is the end.&quot;</span><span class="p">)</span>
            <span class="k">break</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Error norm at step  10: 7.232364210931579e-14
Error norm at step  20: 3.471143367379474e-18
Error norm at step  30: 5.56263347695335e-17
Error norm at step  40: 3.127392492141697e-17
Error norm at step  50: 1.3878213524237504e-17
Error norm at step  60: 3.1237255619435047e-17
Error norm at step  70: 7.742031576522774e-21
Tolerance trespassed! This is the end.
</pre></div>
</div>
<p>The tolerance we set was fairly low, one should expect good things to come
out of this.
Let’s have a look at the solution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;array entry $j$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;probabilities $p_j$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_006.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_006.png" alt="tutorial classical kernels" class = "sphx-glr-single-img"/><p>Would you be able to tell whether this is correct?
Me neither!
But all those probabilities being close to <span class="math notranslate nohighlight">\(0\)</span> should make us fear some
of them must’ve turned negative.
That would be fatal for us.
For <code class="docutils literal notranslate"><span class="pre">MottonenStatePreparation</span></code>, we’ll need to give <code class="docutils literal notranslate"><span class="pre">amplitudes</span></code> as one of the
arguments, which is the component-wise square root of <code class="docutils literal notranslate"><span class="pre">probabilities</span></code>.
And hence the problem!
Even if they are very small values, if any entry of <code class="docutils literal notranslate"><span class="pre">probabilities</span></code> is
negative, the square root will give <code class="docutils literal notranslate"><span class="pre">nan</span></code>.
In order to avoid that, we use a simple thresholding where we replace very
small entries by <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">probabilities_threshold_normalize</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">,</span> <span class="n">thresh</span> <span class="o">=</span> <span class="mf">1.e-10</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)</span>
    <span class="n">p_t</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">):</span>
            <span class="n">p_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">p_t</span> <span class="o">=</span> <span class="n">p_t</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p_t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p_t</span>
</pre></div>
</div>
<p>Then, we need to take the square root:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a> <span class="o">=</span> <span class="n">probabilities_threshold_normalize</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)</span>
</pre></div>
</div>
<p>A little plotting never killed nobody</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;probability $p_j = |a_j|^2$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;amplitude $a_j$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;array entry $j$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_007.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_007.png" alt="tutorial classical kernels" class = "sphx-glr-single-img"/></div>
<div class="section" id="visualizing-the-solution">
<h2>Visualizing the solution<a class="headerlink" href="#visualizing-the-solution" title="Permalink to this headline">¶</a></h2>
<p>And the moment of truth!
Does the solution really match the spectrum?
We try it first using <code class="docutils literal notranslate"><span class="pre">predict_spectrum</span></code> only</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">fourier_p</span><span class="p">(</span><span class="n">d</span><span class="p">)[:</span><span class="n">d</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Gaussian kernel&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">predict_spectrum</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)[:</span><span class="n">d</span><span class="p">],</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;QK predicted&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;frequency $n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fourier coefficient&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Fourier spectrum of the Gaussian kernel&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_008.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_008.png" alt="Fourier spectrum of the Gaussian kernel" class = "sphx-glr-single-img"/><p>It seems like it does!
But as we just said, this is still only the predicted spectrum.
We haven’t called the quantum computer at all yet!</p>
<p>Let’s see what happens when we call the function <code class="docutils literal notranslate"><span class="pre">coefficients</span></code> on the QK
function we defined earlier.
Good coding practice tells us we should probably turn this step into a function
itself, in case it is of use later:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fourier_q</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">):</span>
    <span class="k">def</span> <span class="nf">QK_partial</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">squeezed_x</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">QK</span><span class="p">(</span><span class="n">squeezed_x</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.coefficients.html#pennylane.fourier.coefficients" title="pennylane.fourier.coefficients" class="sphx-glr-backref-module-pennylane-fourier sphx-glr-backref-type-py-function"><span class="n">coefficients</span></a><span class="p">(</span><span class="n">QK_partial</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>And with this, we can finally visualize how the Fourier spectrum of the
QK function compares to that of the Gaussian kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">fourier_p</span><span class="p">(</span><span class="n">d</span><span class="p">)[:</span><span class="n">d</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Gaussian kernel&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">predict_spectrum</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probabilities</span></a><span class="p">)[:</span><span class="n">d</span><span class="p">],</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;QK predicted&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">fourier_q</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">)[:</span><span class="n">d</span><span class="p">],</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;QK computer&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;frequency $n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fourier coefficient&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Fourier spectrum of the Gaussian kernel&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_009.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_009.png" alt="Fourier spectrum of the Gaussian kernel" class = "sphx-glr-single-img"/><p>It seems it went well!
Matching spectra should mean matching kernel functions, right?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Y_learned</span></a> <span class="o">=</span> <span class="n">QK_on_dataset</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">amplitudes</span></a><span class="p">)</span>
<span class="n">Y_truth</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gauss_p</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Y_learned</span></a><span class="p">,</span> <span class="s1">&#39;-.&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;QK&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <span class="n">Y_truth</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Gaussian kernel&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;$\delta$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;$k(\delta)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_classical_kernels_010.png" srcset="../_images/sphx_glr_tutorial_classical_kernels_010.png" alt="tutorial classical kernels" class = "sphx-glr-single-img"/><p>Yeah!
We did it!</p>
<div class="figure align-center">
<a class="reference external image-reference" href="javascript:void(0)"><img alt="../_images/salesman.PNG" src="../_images/salesman.PNG" style="width: 70%;" /></a>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="qek"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Thomas Hubregtsen, David Wierichs, Elies Gil-Fuster, Peter-Jan HS
Derks, Paul K Faehrmann, Johannes Jakob Meyer.
“Training Quantum Embedding Kernels on Near-Term Quantum Computers”.
<a class="reference external" href="https://arxiv.org/abs/2105.02276">arXiv preprint arXiv:2105.02276</a>.</p>
</dd>
<dt class="label" id="fourier"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Maria Schuld, Ryan Sweke, Johannes Jakob Meyer.
“The effect of data encoding on the expressive power of variational
quantum machine learning models”.
<a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.032430">Phys. Rev. A 103, 032430</a>,
<a class="reference external" href="https://arxiv.org/abs/2008.08605">arXiv preprint arXiv:2008.08605</a>.</p>
</dd>
<dt class="label" id="qkernels"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Maria Schuld.
“Supervised quantum machine learning models are kernel methods”.
<a class="reference external" href="https://arxiv.org/abs/2101.11020">arXiv preprint arXiv:2101.11020</a>.</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/elies_gil-fuster.jpg" alt="Elies Gil-Fuster" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Elies Gil-Fuster</h4>
        <p class="bio-text__author-description">Elies is a QML researcher in Berlin interested in board games and the maths of data re-uploading PQCs. He was a Xanadu Summer Resident of the first cohort, and you can find more about him at https://eliesgilfuster.eu.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  10.269 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-classical-kernels-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/01e1537ac0ccc424ac75b36a65046e93/tutorial_classical_kernels.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_classical_kernels.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/09b2c90a01f7c6c4e1fdf672c3f37bc5/tutorial_classical_kernels.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_classical_kernels.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_classical_kernels</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">How to approximate a classical kernel with a quantum computer</a><ul class='current'>
<li class='current'><a class="reference internal" href="#kernel-based-machine-learning">Kernel-based Machine Learning</a></li>
<li class='current'><a class="reference internal" href="#shift-invariant-kernels">Shift-invariant kernels</a></li>
<li class='current'><a class="reference internal" href="#warm-up-implementing-the-gaussian-kernel">Warm up: Implementing the Gaussian kernel</a></li>
<li class='current'><a class="reference internal" href="#fourier-analysis-of-the-gaussian-kernel">Fourier analysis of the Gaussian kernel</a></li>
<li class='current'><a class="reference internal" href="#designing-a-suitable-qk">Designing a suitable QK</a></li>
<li class='current'><a class="reference internal" href="#computing-the-qk-function-on-a-quantum-device">Computing the QK function on a quantum device</a><ul class='current'>
<li class='current'><a class="reference internal" href="#how-to-find-the-amplitudes-emulating-a-gaussian-kernel">How to find the amplitudes emulating a Gaussian kernel</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#finding-the-solution">Finding the solution</a></li>
<li class='current'><a class="reference internal" href="#visualizing-the-solution">Visualizing the solution</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_classical_kernels</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_qml.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_tn_circuits.html" title="Tensor-network quantum circuits"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_quantum_gans.html" title="Quantum GANs"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_qml.html" >Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">How to approximate a classical kernel with a quantum computer</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>