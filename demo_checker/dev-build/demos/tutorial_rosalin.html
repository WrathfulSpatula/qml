
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="The Rosalin optimizer uses a measurement-frugal optimization strategy to minimize the number of times a quantum computer is accessed." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/sphx_glr_tutorial_rosalin_002.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Frugal shot optimization with Rosalin &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_rosalin.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="The Rosalin optimizer uses a measurement-frugal optimization strategy to minimize the number of times a quantum computer is accessed." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Frugal shot optimization with Rosalin &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_rosalin.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Feedback-Based Quantum Optimization (FALQON)" href="tutorial_falqon.html" />
    <link rel="prev" title="Quantum circuit structure learning" href="tutorial_rotoselect.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_falqon.html" title="Feedback-Based Quantum Optimization (FALQON)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_rotoselect.html" title="Quantum circuit structure learning"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" accesskey="U">Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Frugal shot optimization with Rosalin</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-rosalin-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="frugal-shot-optimization-with-rosalin">
<span id="sphx-glr-demos-tutorial-rosalin-py"></span><h1>Frugal shot optimization with Rosalin<a class="headerlink" href="#frugal-shot-optimization-with-rosalin" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_vqe.html", "tutorial_quantum_natural_gradient.html", "tutorial_doubly_stochastic.html", "tutorial_rotoselect.html"];
    var related_tutorials_titles = ['A brief overview of VQE', 'Quantum natural gradient', 'Doubly stochastic gradient descent', 'Quantum circuit structure learning'];
</script></p>
<p><em>Author: Josh Izaac — Posted: 19 May 2020. Last updated: 30 January 2023.</em></p>
<p>In this tutorial we investigate and implement the Rosalin (Random Operator Sampling for
Adaptive Learning with Individual Number of shots) from
Arrasmith et al. <a class="footnote-reference brackets" href="#arrasmith2020" id="id1">1</a>. In this paper, a strategy
is introduced for reducing the number of shots required when optimizing variational quantum
algorithms, by both:</p>
<ul class="simple">
<li><p>Frugally adapting the number of shots used per parameter update, and</p></li>
<li><p>Performing a weighted sampling of operators from the cost Hamiltonian.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Rosalin optimizer is available in PennyLane via the
<a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.ShotAdaptiveOptimizer.html#pennylane.ShotAdaptiveOptimizer" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShotAdaptiveOptimizer</span></code></a>.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>While a large number of papers in variational quantum algorithms focus on the
choice of circuit ansatz, cost function, gradient computation, or initialization method,
the optimization strategy—an important component affecting both convergence time and
quantum resource dependence—is not as frequently considered. Instead, common
‘out-of-the-box’ classical optimization techniques, such as gradient-free
methods (COBLYA, Nelder-Mead), gradient-descent, and Hessian-free methods (L-BFGS) tend to be used.</p>
<p>However, for variational algorithms such as <a class="reference internal" href="tutorial_vqe.html"><span class="doc">VQE</span></a>, which involve evaluating
a large number of non-commuting operators in the cost function, decreasing the number of
quantum evaluations required for convergence, while still minimizing statistical noise, can
be a delicate balance.</p>
<p>Recent work has highlighted that ‘quantum-aware’ optimization techniques
can lead to marked improvements when training variational quantum algorithms:</p>
<ul class="simple">
<li><p><a class="reference internal" href="tutorial_quantum_natural_gradient.html"><span class="doc">Quantum natural gradient</span></a> descent by Stokes et al. <a class="footnote-reference brackets" href="#stokes2019" id="id2">2</a>, which
takes into account the quantum geometry during the gradient-descent update step.</p></li>
<li><p>The work of Sweke et al. <a class="footnote-reference brackets" href="#sweke2019" id="id3">3</a>, which shows
that quantum gradient descent with a finite number of shots is equivalent to
<a class="reference external" href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">stochastic gradient descent</a>,
and has guaranteed convergence. Furthermore, combining a finite number of shots with
weighted sampling of the cost function terms leads to <a class="reference internal" href="tutorial_doubly_stochastic.html"><span class="doc">Doubly stochastic gradient descent</span></a>.</p></li>
<li><p>The iCANS (individual Coupled Adaptive Number of Shots) optimization technique by
Jonas Kuebler et al. <a class="footnote-reference brackets" href="#kubler2020" id="id4">4</a> adapts the number
of shots measurements during training, by maximizing the expected gain per shot.</p></li>
</ul>
<p>In this latest result by Arrasmith et al. <a class="footnote-reference brackets" href="#arrasmith2020" id="id5">1</a>, the
idea of doubly stochastic gradient descent has been used to extend the iCANS optimizer,
resulting in faster convergence.</p>
<p>Over the course of this tutorial, we will explore their results; beginning first with a
demonstration of <em>weighted random sampling</em> of the cost Hamiltonian operators, before
combining this with the shot-frugal iCANS optimizer to perform doubly stochastic
Rosalin optimization.</p>
</div>
<div class="section" id="weighted-random-sampling">
<h2>Weighted random sampling<a class="headerlink" href="#weighted-random-sampling" title="Permalink to this headline">¶</a></h2>
<p>Consider a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> expanded as a weighted sum of operators <span class="math notranslate nohighlight">\(h_i\)</span> that can
be directly measured:</p>
<div class="math notranslate nohighlight">
\[H = \sum_{i=1}^N c_i h_i.\]</div>
<p>Due to the linearity of expectation values, the expectation value of this Hamiltonian
can be expressed as the weighted sum of each individual term:</p>
<div class="math notranslate nohighlight">
\[\langle H\rangle = \sum_{i=1}^N c_i \langle h_i\rangle.\]</div>
<p>In the <a class="reference internal" href="tutorial_doubly_stochastic.html"><span class="doc">doubly stochastic gradient descent demonstration</span></a>,
we estimated this expectation value by <strong>uniformly sampling</strong> a subset of the terms
at each optimization step, and evaluating each term by using the same finite number of shots
<span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>However, what happens if we use a weighted approach to determine how to distribute
our samples across the terms of the Hamiltonian? In <strong>weighted random sampling</strong> (WRS),
the number of shots used to determine the expectation value <span class="math notranslate nohighlight">\(\langle h_i\rangle\)</span>
is a discrete random variable distributed according to a
<a class="reference external" href="https://en.wikipedia.org/wiki/Multinomial_distribution">multinomial distribution</a>,</p>
<div class="math notranslate nohighlight">
\[S \sim \text{Multinomial}(p_i),\]</div>
<p>with event probabilities</p>
<div class="math notranslate nohighlight">
\[p_i = \frac{|c_i|}{\sum_i |c_i|}.\]</div>
<p>That is, the number of shots assigned to the measurement of the expectation value of the
<span class="math notranslate nohighlight">\(i\text{th}\)</span> term of the Hamiltonian is drawn from a probability distribution
<em>proportional to the magnitude of its coefficient</em> <span class="math notranslate nohighlight">\(c_i\)</span>.</p>
<p>To see this strategy in action, consider the Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = 2I\otimes X + 4 I\otimes Z  - X\otimes X + 5Y\otimes Y + 2 Z\otimes X.\]</div>
<p>We can solve for the ground state energy using the variational quantum eigensolver (VQE) algorithm.</p>
<p>First, let’s import NumPy and PennyLane, and define our Hamiltonian.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># set the random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="n">obs</span> <span class="o">=</span> <span class="p">[</span>
  <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
  <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
  <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
  <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
  <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p>We can now create our quantum device (let’s use the <code class="docutils literal notranslate"><span class="pre">default.qubit</span></code> simulator).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_layers</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">num_wires</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># create a device that estimates expectation values using a finite number of shots</span>
<span class="n">non_analytic_dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_wires</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="c1"># create a device that calculates exact expectation values</span>
<span class="n">analytic_dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_wires</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, let’s set the total number of shots, and determine the probability
for sampling each Hamiltonian term.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">total_shots</span> <span class="o">=</span> <span class="mi">8000</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">prob_shots</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">prob_shots</span></a><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[0.14285714 0.28571429 0.07142857 0.35714286 0.14285714]
</pre></div>
</div>
<p>We can now use SciPy to create our multinomial distributed random variable
<span class="math notranslate nohighlight">\(S\)</span>, using the number of trials (total shot number) and probability values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">multinomial</span>

<span class="n">si</span> <span class="o">=</span> <span class="n">multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">total_shots</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">prob_shots</span></a><span class="p">)</span>
</pre></div>
</div>
<p>Sampling from this distribution will provide the number of shots used to
sample each term in the Hamiltonian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">samples</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">rvs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[1191 2262  552 2876 1119]
8000
</pre></div>
</div>
<p>As expected, if we sum the sampled shots per term, we recover the total number of shots.</p>
<p>Let’s now create our cost function. Recall that the cost function must do the
following:</p>
<ol class="arabic simple">
<li><p>It must sample from the multinomial distribution we created above,
to determine the number of shots <span class="math notranslate nohighlight">\(s_i\)</span> to use to estimate the expectation
value of the ith Hamiltonian term.</p></li>
<li><p>It then must estimate the expectation value <span class="math notranslate nohighlight">\(\langle h_i\rangle\)</span>
by creating the required QNode. For our ansatz, we’ll use the
<code class="xref py py-class docutils literal notranslate"><span class="pre">StronglyEntanglingLayers</span></code>.</p></li>
<li><p>And, last but not least, estimate the expectation value
<span class="math notranslate nohighlight">\(\langle H\rangle = \sum_i c_i\langle h_i\rangle\)</span>.</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane.templates.layers</span> <span class="kn">import</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html#pennylane.StronglyEntanglingLayers" title="pennylane.StronglyEntanglingLayers" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">StronglyEntanglingLayers</span></a>


<span class="nd">@qml</span><span class="o">.</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><span class="n">non_analytic_dev</span><span class="p">,</span> <span class="n">diff_method</span><span class="o">=</span><span class="s2">&quot;parameter-shift&quot;</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qnode</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">observable</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html#pennylane.StronglyEntanglingLayers" title="pennylane.StronglyEntanglingLayers" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">StronglyEntanglingLayers</span></a><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">non_analytic_dev</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><span class="n">observable</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">):</span>
    <span class="c1"># sample from the multinomial distribution</span>
    <span class="n">shots_per_term</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">rvs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">shots_per_term</span><span class="p">):</span>
        <span class="c1"># evaluate the QNode corresponding to</span>
        <span class="c1"># the Hamiltonian term, and add it on to our running sum</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Evaluating our cost function with some initial parameters, we can test out
that our cost function evaluates correctly.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">param_shape</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html#pennylane.StronglyEntanglingLayers" title="pennylane.StronglyEntanglingLayers" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">StronglyEntanglingLayers</span></a><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n_layers</span><span class="o">=</span><span class="n">num_layers</span><span class="p">,</span> <span class="n">n_wires</span><span class="o">=</span><span class="n">num_wires</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_params</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">param_shape</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_params</span></a><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>-0.8395887630997874
</pre></div>
</div>
<p>Performing the optimization, with the number of shots randomly
determined at each optimization step:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">opt</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">AdamOptimizer</span></a><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_params</span></a>

<span class="n">cost_wrs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">shots_wrs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">_cost</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer.step_and_cost" title="pennylane.AdamOptimizer.step_and_cost" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">opt</span><span class="o">.</span><span class="n">step_and_cost</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">)</span>
    <span class="n">cost_wrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_cost</span><span class="p">)</span>
    <span class="n">shots_wrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_shots</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">{}</span><span class="s2">: cost = </span><span class="si">{}</span><span class="s2"> shots used = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cost_wrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shots_wrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Step 0: cost = -0.47971271815214855 shots used = 0
Step 1: cost = -1.9358195375281395 shots used = 8000
Step 2: cost = -2.429697191348172 shots used = 16000
Step 3: cost = -3.6308900629353356 shots used = 24000
Step 4: cost = -4.275894772648205 shots used = 32000
Step 5: cost = -5.2697645839743705 shots used = 40000
Step 6: cost = -5.414011202290673 shots used = 48000
Step 7: cost = -5.958619200612785 shots used = 56000
Step 8: cost = -6.589890076928924 shots used = 64000
Step 9: cost = -6.879689304585086 shots used = 72000
Step 10: cost = -7.11044038351491 shots used = 80000
Step 11: cost = -7.441618274754085 shots used = 88000
Step 12: cost = -7.343694305020567 shots used = 96000
Step 13: cost = -7.531129303076952 shots used = 104000
Step 14: cost = -7.3929094864194465 shots used = 112000
Step 15: cost = -7.41913469502728 shots used = 120000
Step 16: cost = -7.484772628807 shots used = 128000
Step 17: cost = -7.2470111788679805 shots used = 136000
Step 18: cost = -7.278243959604719 shots used = 144000
Step 19: cost = -7.21024168219871 shots used = 152000
Step 20: cost = -7.497562843426365 shots used = 160000
Step 21: cost = -7.300503461549561 shots used = 168000
Step 22: cost = -7.502226318725064 shots used = 176000
Step 23: cost = -7.683018234663317 shots used = 184000
Step 24: cost = -7.7122067730786 shots used = 192000
Step 25: cost = -7.502924268040441 shots used = 200000
Step 26: cost = -7.655288657867658 shots used = 208000
Step 27: cost = -7.606898557639433 shots used = 216000
Step 28: cost = -7.625269501080646 shots used = 224000
Step 29: cost = -7.669368776362655 shots used = 232000
Step 30: cost = -7.810865011077598 shots used = 240000
Step 31: cost = -7.679683881569233 shots used = 248000
Step 32: cost = -7.654476847955421 shots used = 256000
Step 33: cost = -7.5211521050495636 shots used = 264000
Step 34: cost = -7.751101012112956 shots used = 272000
Step 35: cost = -7.687077255130304 shots used = 280000
Step 36: cost = -7.736266201334557 shots used = 288000
Step 37: cost = -7.680984283808025 shots used = 296000
Step 38: cost = -7.718561744208679 shots used = 304000
Step 39: cost = -7.67028103083904 shots used = 312000
Step 40: cost = -7.710347919579339 shots used = 320000
Step 41: cost = -7.593136197480478 shots used = 328000
Step 42: cost = -7.810359527538487 shots used = 336000
Step 43: cost = -7.737769438457732 shots used = 344000
Step 44: cost = -7.853027575362733 shots used = 352000
Step 45: cost = -7.87316397259127 shots used = 360000
Step 46: cost = -7.918883946761729 shots used = 368000
Step 47: cost = -7.921546467893382 shots used = 376000
Step 48: cost = -7.71980941701694 shots used = 384000
Step 49: cost = -7.8308057919156155 shots used = 392000
Step 50: cost = -7.8469319373986925 shots used = 400000
Step 51: cost = -7.814094417970937 shots used = 408000
Step 52: cost = -7.805577964490593 shots used = 416000
Step 53: cost = -7.792672651319024 shots used = 424000
Step 54: cost = -7.859279576823298 shots used = 432000
Step 55: cost = -7.920898395551514 shots used = 440000
Step 56: cost = -8.109172247437503 shots used = 448000
Step 57: cost = -7.954949088064669 shots used = 456000
Step 58: cost = -7.840000679159047 shots used = 464000
Step 59: cost = -8.073897469157906 shots used = 472000
Step 60: cost = -8.016380156819022 shots used = 480000
Step 61: cost = -7.749354818376889 shots used = 488000
Step 62: cost = -7.9084244778219634 shots used = 496000
Step 63: cost = -7.911403066159991 shots used = 504000
Step 64: cost = -7.694258154002229 shots used = 512000
Step 65: cost = -8.135637132372215 shots used = 520000
Step 66: cost = -7.880710119461283 shots used = 528000
Step 67: cost = -7.958115647880543 shots used = 536000
Step 68: cost = -7.949005635306886 shots used = 544000
Step 69: cost = -7.815469675932031 shots used = 552000
Step 70: cost = -7.824093391711489 shots used = 560000
Step 71: cost = -7.867760065578605 shots used = 568000
Step 72: cost = -7.931110498889814 shots used = 576000
Step 73: cost = -7.879521348618871 shots used = 584000
Step 74: cost = -7.840075562849998 shots used = 592000
Step 75: cost = -7.866075581377627 shots used = 600000
Step 76: cost = -7.923529733995367 shots used = 608000
Step 77: cost = -7.934656834108851 shots used = 616000
Step 78: cost = -7.894211944790477 shots used = 624000
Step 79: cost = -7.8338507678458065 shots used = 632000
Step 80: cost = -7.7936236744612 shots used = 640000
Step 81: cost = -7.9924846833802 shots used = 648000
Step 82: cost = -7.767589081568244 shots used = 656000
Step 83: cost = -8.036426061542748 shots used = 664000
Step 84: cost = -8.085968623696424 shots used = 672000
Step 85: cost = -7.798674831445482 shots used = 680000
Step 86: cost = -7.771240866851645 shots used = 688000
Step 87: cost = -7.805259795070319 shots used = 696000
Step 88: cost = -7.892488048336198 shots used = 704000
Step 89: cost = -7.894970226892511 shots used = 712000
Step 90: cost = -7.881326529610687 shots used = 720000
Step 91: cost = -8.108673203429863 shots used = 728000
Step 92: cost = -7.907973083754514 shots used = 736000
Step 93: cost = -7.801569622806004 shots used = 744000
Step 94: cost = -7.933400493853428 shots used = 752000
Step 95: cost = -7.8470947907663415 shots used = 760000
Step 96: cost = -7.943261293748337 shots used = 768000
Step 97: cost = -7.818450593894962 shots used = 776000
Step 98: cost = -7.9210182454846425 shots used = 784000
Step 99: cost = -8.111046662059286 shots used = 792000
</pre></div>
</div>
<p>Let’s compare this against an optimization not using weighted random sampling.
Here, we will split the 8000 total shots evenly across all Hamiltonian terms,
also known as <em>uniform deterministic sampling</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><span class="n">non_analytic_dev</span><span class="p">,</span> <span class="n">diff_method</span><span class="o">=</span><span class="s2">&quot;parameter-shift&quot;</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qnode</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">obs</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html#pennylane.StronglyEntanglingLayers" title="pennylane.StronglyEntanglingLayers" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">StronglyEntanglingLayers</span></a><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">non_analytic_dev</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><span class="n">obs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">):</span>
    <span class="n">shots_per_term</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_shots</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">):</span>

        <span class="c1"># evaluate the QNode corresponding to</span>
        <span class="c1"># the Hamiltonian term, and add it on to our running sum</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots_per_term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">opt</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">AdamOptimizer</span></a><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_params</span></a>

<span class="n">cost_adam</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">shots_adam</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">_cost</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer.step_and_cost" title="pennylane.AdamOptimizer.step_and_cost" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">opt</span><span class="o">.</span><span class="n">step_and_cost</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">)</span>
    <span class="n">cost_adam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_cost</span><span class="p">)</span>
    <span class="n">shots_adam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_shots</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">{}</span><span class="s2">: cost = </span><span class="si">{}</span><span class="s2"> shots used = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cost_adam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shots_adam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Step 0: cost = -0.6424999999999998 shots used = 0
Step 1: cost = -1.7650000000000001 shots used = 8000
Step 2: cost = -3.0875 shots used = 16000
Step 3: cost = -3.47875 shots used = 24000
Step 4: cost = -4.405 shots used = 32000
Step 5: cost = -5.126250000000001 shots used = 40000
Step 6: cost = -5.6625 shots used = 48000
Step 7: cost = -5.9837500000000015 shots used = 56000
Step 8: cost = -6.50375 shots used = 64000
Step 9: cost = -6.775 shots used = 72000
Step 10: cost = -6.90625 shots used = 80000
Step 11: cost = -7.165 shots used = 88000
Step 12: cost = -7.39375 shots used = 96000
Step 13: cost = -7.52 shots used = 104000
Step 14: cost = -7.547499999999999 shots used = 112000
Step 15: cost = -7.512499999999999 shots used = 120000
Step 16: cost = -7.155 shots used = 128000
Step 17: cost = -7.534999999999999 shots used = 136000
Step 18: cost = -7.350000000000001 shots used = 144000
Step 19: cost = -7.25625 shots used = 152000
Step 20: cost = -7.3987500000000015 shots used = 160000
Step 21: cost = -7.50875 shots used = 168000
Step 22: cost = -7.50375 shots used = 176000
Step 23: cost = -7.55625 shots used = 184000
Step 24: cost = -7.3374999999999995 shots used = 192000
Step 25: cost = -7.7524999999999995 shots used = 200000
Step 26: cost = -7.6499999999999995 shots used = 208000
Step 27: cost = -7.7524999999999995 shots used = 216000
Step 28: cost = -7.637500000000001 shots used = 224000
Step 29: cost = -7.5512500000000005 shots used = 232000
Step 30: cost = -7.7175 shots used = 240000
Step 31: cost = -7.65625 shots used = 248000
Step 32: cost = -7.998749999999999 shots used = 256000
Step 33: cost = -7.67375 shots used = 264000
Step 34: cost = -7.2962500000000015 shots used = 272000
Step 35: cost = -7.5874999999999995 shots used = 280000
Step 36: cost = -7.74875 shots used = 288000
Step 37: cost = -7.713749999999999 shots used = 296000
Step 38: cost = -7.735 shots used = 304000
Step 39: cost = -7.893750000000001 shots used = 312000
Step 40: cost = -7.57 shots used = 320000
Step 41: cost = -7.7787500000000005 shots used = 328000
Step 42: cost = -7.83 shots used = 336000
Step 43: cost = -7.8475 shots used = 344000
Step 44: cost = -7.82875 shots used = 352000
Step 45: cost = -7.819999999999999 shots used = 360000
Step 46: cost = -7.836250000000001 shots used = 368000
Step 47: cost = -7.786250000000001 shots used = 376000
Step 48: cost = -7.8625 shots used = 384000
Step 49: cost = -7.951250000000001 shots used = 392000
Step 50: cost = -7.958749999999999 shots used = 400000
Step 51: cost = -8.20375 shots used = 408000
Step 52: cost = -7.692500000000001 shots used = 416000
Step 53: cost = -7.8375 shots used = 424000
Step 54: cost = -7.6312500000000005 shots used = 432000
Step 55: cost = -7.828749999999999 shots used = 440000
Step 56: cost = -7.8625 shots used = 448000
Step 57: cost = -8.09125 shots used = 456000
Step 58: cost = -7.70625 shots used = 464000
Step 59: cost = -7.8237499999999995 shots used = 472000
Step 60: cost = -8.03625 shots used = 480000
Step 61: cost = -7.972499999999999 shots used = 488000
Step 62: cost = -7.81 shots used = 496000
Step 63: cost = -7.86375 shots used = 504000
Step 64: cost = -8.045 shots used = 512000
Step 65: cost = -7.80375 shots used = 520000
Step 66: cost = -7.90375 shots used = 528000
Step 67: cost = -7.9025 shots used = 536000
Step 68: cost = -8.01875 shots used = 544000
Step 69: cost = -7.9725 shots used = 552000
Step 70: cost = -8.03625 shots used = 560000
Step 71: cost = -8.09875 shots used = 568000
Step 72: cost = -7.7925 shots used = 576000
Step 73: cost = -7.68 shots used = 584000
Step 74: cost = -7.995 shots used = 592000
Step 75: cost = -7.93625 shots used = 600000
Step 76: cost = -7.74125 shots used = 608000
Step 77: cost = -7.72 shots used = 616000
Step 78: cost = -7.710000000000001 shots used = 624000
Step 79: cost = -7.7125 shots used = 632000
Step 80: cost = -7.7325 shots used = 640000
Step 81: cost = -7.93125 shots used = 648000
Step 82: cost = -7.785 shots used = 656000
Step 83: cost = -7.7625 shots used = 664000
Step 84: cost = -7.6937500000000005 shots used = 672000
Step 85: cost = -8.0525 shots used = 680000
Step 86: cost = -8.06125 shots used = 688000
Step 87: cost = -7.8812500000000005 shots used = 696000
Step 88: cost = -7.973750000000001 shots used = 704000
Step 89: cost = -7.89875 shots used = 712000
Step 90: cost = -7.88 shots used = 720000
Step 91: cost = -7.99875 shots used = 728000
Step 92: cost = -7.86375 shots used = 736000
Step 93: cost = -7.911250000000001 shots used = 744000
Step 94: cost = -7.842500000000001 shots used = 752000
Step 95: cost = -8.00875 shots used = 760000
Step 96: cost = -7.859999999999999 shots used = 768000
Step 97: cost = -7.96375 shots used = 776000
Step 98: cost = -7.772499999999999 shots used = 784000
Step 99: cost = -7.9475 shots used = 792000
</pre></div>
</div>
<p>Comparing these two techniques:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;seaborn&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">shots_wrs</span><span class="p">,</span> <span class="n">cost_wrs</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Adam WRS&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">shots_adam</span><span class="p">,</span> <span class="n">cost_adam</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Adam&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Cost function value&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of shots&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_rosalin_001.png" srcset="../_images/sphx_glr_tutorial_rosalin_001.png" alt="tutorial rosalin" class = "sphx-glr-single-img"/><p>We can see that weighted random sampling performs just as well as the uniform
deterministic sampling. However, weighted random sampling begins to show a
non-negligible improvement over deterministic sampling for large Hamiltonians
with highly non-uniform coefficients. For example, see Fig (3) and (4) of
Arrasmith et al. <a class="footnote-reference brackets" href="#arrasmith2020" id="id6">1</a>, comparing weighted random sampling VQE optimization
for both <span class="math notranslate nohighlight">\(\text{H}_2\)</span> and <span class="math notranslate nohighlight">\(\text{LiH}\)</span> molecules.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While not covered here, another approach that could be taken is
<em>weighted deterministic sampling</em>. Here, the number of shots is distributed
across terms as per</p>
<div class="math notranslate nohighlight">
\[s_i = \left\lfloor N \frac{|c_i|}{\sum_i |c_i|}\right\rfloor,\]</div>
<p>where <span class="math notranslate nohighlight">\(N\)</span> is the total number of shots.</p>
</div>
</div>
<div class="section" id="rosalin-frugal-shot-optimization">
<h2>Rosalin: Frugal shot optimization<a class="headerlink" href="#rosalin-frugal-shot-optimization" title="Permalink to this headline">¶</a></h2>
<p>We can see above that both methods optimize fairly well; weighted random
sampling converges just as well as evenly distributing the shots across
all Hamiltonian terms. However, deterministic shot distribution approaches
will always have a minimum shot value required per expectation value, as below
this threshold they become biased estimators. This is not the case with random
sampling; as we saw in the
<a class="reference internal" href="tutorial_doubly_stochastic.html"><span class="doc">doubly stochastic gradient descent demonstration</span></a>,
the introduction of randomness allows for as little
as a single shot per expectation term, while still remaining an unbiased estimator.</p>
<p>Using this insight, Arrasmith et al. <a class="footnote-reference brackets" href="#arrasmith2020" id="id7">1</a> modified the iCANS frugal
shot-optimization technique <a class="footnote-reference brackets" href="#kubler2020" id="id8">4</a> to include weighted random sampling, making it
‘doubly stochastic’.</p>
<div class="section" id="icans-optimizer">
<h3>iCANS optimizer<a class="headerlink" href="#icans-optimizer" title="Permalink to this headline">¶</a></h3>
<p>Two variants of the iCANS optimizer were introduced in Kübler et al., iCANS1 and iCANS2.
The iCANS1 optimizer, on which Rosalin is based, frugally distributes a shot budget
across the partial derivatives of each parameter, which are computed using the
<a class="reference internal" href="../glossary/quantum_gradient.html"><span class="doc">parameter-shift rule</span></a>. It works roughly as follows:</p>
<ol class="arabic">
<li><p>The initial step of the optimizer is performed with some specified minimum
number of shots, <span class="math notranslate nohighlight">\(s_{min}\)</span>, for all partial derivatives.</p></li>
<li><p>The parameter-shift rule is then used to estimate the gradient <span class="math notranslate nohighlight">\(g_i\)</span>
for each parameter <span class="math notranslate nohighlight">\(\theta_i\)</span>, parameters, as well as the <em>variances</em>
<span class="math notranslate nohighlight">\(v_i\)</span> of the estimated gradients.</p></li>
<li><p>Gradient descent is performed for each parameter <span class="math notranslate nohighlight">\(\theta_i\)</span>, using
the pre-defined learning rate <span class="math notranslate nohighlight">\(\alpha\)</span> and the gradient information <span class="math notranslate nohighlight">\(g_i\)</span>:</p>
<div class="math notranslate nohighlight">
\[\theta_i = \theta_i - \alpha g_i.\]</div>
</li>
<li><p>The improvement in the cost function per shot, for a specific parameter value,
is then calculated via</p>
<div class="math notranslate nohighlight">
\[\gamma_i = \frac{1}{s_i} \left[ \left(\alpha - \frac{1}{2} L\alpha^2\right)
            g_i^2 - \frac{L\alpha^2}{2s_i}v_i \right],\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(L \leq \sum_i|c_i|\)</span> is the bound on the <a class="reference external" href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz constant</a> of the variational quantum algorithm objective function,</p></li>
<li><p><span class="math notranslate nohighlight">\(c_i\)</span> are the coefficients of the Hamiltonian, and</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is the learning rate, and <em>must</em> be bound such that <span class="math notranslate nohighlight">\(\alpha &lt; 2/L\)</span>
for the above expression to hold.</p></li>
</ul>
</li>
<li><p>Finally, the new values of <span class="math notranslate nohighlight">\(s_i\)</span> (shots for partial derivative of parameter
<span class="math notranslate nohighlight">\(\theta_i\)</span>) is given by:</p>
<div class="math notranslate nohighlight">
\[s_i = \frac{2L\alpha}{2-L\alpha}\left(\frac{v_i}{g_i^2}\right)\propto
      \frac{v_i}{g_i^2}.\]</div>
</li>
</ol>
<p>In addition to the above, to counteract the presence of noise in the system, a
running average of <span class="math notranslate nohighlight">\(g_i\)</span> and <span class="math notranslate nohighlight">\(s_i\)</span> (<span class="math notranslate nohighlight">\(\chi_i\)</span> and <span class="math notranslate nohighlight">\(\xi_i\)</span> respectively)
are used when computing <span class="math notranslate nohighlight">\(\gamma_i\)</span> and <span class="math notranslate nohighlight">\(s_i\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In classical machine learning, the Lipschitz constant of the cost function is generally
unknown. However, for a variational quantum algorithm with cost of the form
<span class="math notranslate nohighlight">\(f(x) = \langle \psi(x) | \hat{H} |\psi(x)\rangle\)</span>,
an upper bound on the Lipschitz constant is given by <span class="math notranslate nohighlight">\(L &lt; \sum_i|c_i|\)</span>,
where <span class="math notranslate nohighlight">\(c_i\)</span> are the coefficients of <span class="math notranslate nohighlight">\(\hat{H}\)</span> when decomposed
into a linear combination of Pauli-operator tensor products.</p>
</div>
</div>
<div class="section" id="rosalin-implementation">
<h3>Rosalin implementation<a class="headerlink" href="#rosalin-implementation" title="Permalink to this headline">¶</a></h3>
<p>Let’s now modify iCANS above to incorporate weighted random sampling of Hamiltonian
terms — the Rosalin frugal shot optimizer.</p>
<p>Rosalin takes several hyper-parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">min_shots</span></code>: the minimum number of shots used to estimate the expectations
of each term in the Hamiltonian. Note that this must be larger than 2 for the variance
of the gradients to be computed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu</span></code>: The running average constant <span class="math notranslate nohighlight">\(\mu\in[0, 1]\)</span>. Used to control how quickly the
number of shots recommended for each gradient component changes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code>: Regularization bias. The bias should be kept small, but non-zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lr</span></code>: The learning rate. Recall from above that the learning rate <em>must</em> be such
that <span class="math notranslate nohighlight">\(\alpha &lt; 2/L = 2/\sum_i|c_i|\)</span>.</p></li>
</ul>
<p>Since the Rosalin optimizer has a state that must be preserved between optimization steps,
let’s use a class to create our optimizer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rosalin</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">min_shots</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.07</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lipschitz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">lr</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The learning rate must be less than &quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">)</span>

        <span class="c1"># hyperparameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_shots</span> <span class="o">=</span> <span class="n">min_shots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>  <span class="c1"># running average constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>    <span class="c1"># regularization bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">=</span> <span class="n">lr</span>  <span class="c1"># learning rate</span>

        <span class="c1"># keep track of the total number of shots used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots_used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># total number of iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Number of shots per parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">+</span> <span class="n">min_shots</span>

        <span class="c1"># Running average of the parameter gradients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Running average of the variance of the parameter gradients</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">estimate_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an array containing length ``shots`` single-shot estimates</span>
<span class="sd">        of the Hamiltonian. The shots are distributed randomly over</span>
<span class="sd">        the terms in the Hamiltonian, as per a Multinomial distribution.</span>

<span class="sd">        Since we are performing single-shot estimates, the QNodes must be</span>
<span class="sd">        set to &#39;sample&#39; mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rosalin_device</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_wires</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

        <span class="c1"># determine the shot probability per term</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">prob_shots</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>

        <span class="c1"># construct the multinomial distribution, and sample</span>
        <span class="c1"># from it to determine how many shots to apply per term</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">prob_shots</span></a><span class="p">)</span>
        <span class="n">shots_per_term</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">rvs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="nd">@qml</span><span class="o">.</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><span class="n">rosalin_device</span><span class="p">,</span> <span class="n">diff_method</span><span class="o">=</span><span class="s2">&quot;parameter-shift&quot;</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">qnode</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">observable</span><span class="p">):</span>
            <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html#pennylane.StronglyEntanglingLayers" title="pennylane.StronglyEntanglingLayers" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">StronglyEntanglingLayers</span></a><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">rosalin_device</span><span class="o">.</span><span class="n">wires</span><span class="p">)</span>
            <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.sample.html#pennylane.sample" title="pennylane.sample" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">sample</span></a><span class="p">(</span><span class="n">observable</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">prob_shots</span></a><span class="p">,</span> <span class="n">shots_per_term</span><span class="p">):</span>

            <span class="c1"># if the number of shots is 0, do nothing</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># evaluate the QNode corresponding to</span>
            <span class="c1"># the Hamiltonian term</span>
            <span class="n">res</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">res</span><span class="p">])</span>

            <span class="c1"># Note that, unlike above, we divide each term by the</span>
            <span class="c1"># probability per shot. This is because we are sampling one at a time.</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">res</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_grad_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the gradient, as well as the variance in the gradient,</span>
<span class="sd">        for the ith parameter in params, using the parameter-shift rule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">)</span>
        <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">shift_forward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_hamiltonian</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">+</span> <span class="n">shift</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
        <span class="n">shift_backward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_hamiltonian</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">-</span> <span class="n">shift</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shift_forward</span> <span class="o">-</span> <span class="n">shift_backward</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">((</span><span class="n">shift_forward</span> <span class="o">-</span> <span class="n">shift_backward</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a single step of the Rosalin optimizer.&quot;&quot;&quot;</span>
        <span class="c1"># keep track of the number of shots run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shots_used</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">))</span>

        <span class="c1"># compute the gradient, as well as the variance in the gradient,</span>
        <span class="c1"># using the number of shots determined by the array s.</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">p_ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">p_ind</span><span class="p">:</span>
            <span class="c1"># loop through each parameter, performing</span>
            <span class="c1"># the parameter-shift rule</span>
            <span class="n">g_</span><span class="p">,</span> <span class="n">s_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_grad_var</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="n">grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g_</span><span class="p">)</span>
            <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_</span><span class="p">)</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">grad</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># gradient descent update</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">*</span> <span class="n">grad</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># running average of the gradient variance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">S</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># running average of the gradient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chi</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># determine the new optimum shots distribution for the next</span>
        <span class="c1"># iteration of the optimizer</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipschitz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">*</span> <span class="n">xi</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipschitz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)))</span>
        <span class="p">)</span>

        <span class="c1"># apply an upper and lower bound on the new shot distributions,</span>
        <span class="c1"># to avoid the number of shots reducing below min(2, min_shots),</span>
        <span class="c1"># or growing too significantly.</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipschitz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">-</span> <span class="n">xi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lipschitz</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">s</span>

        <span class="n">argmax_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">smax</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">argmax_gamma</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_shots</span><span class="p">),</span> <span class="n">smax</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a>
</pre></div>
</div>
</div>
<div class="section" id="rosalin-optimization">
<h3>Rosalin optimization<a class="headerlink" href="#rosalin-optimization" title="Permalink to this headline">¶</a></h3>
<p>We are now ready to use our Rosalin optimizer to optimize the initial VQE problem. But first let’s
also create a separate cost function using an ‘exact’ quantum device, so that we can keep track of the
<em>exact</em> cost function value at each iteration.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><span class="n">analytic_dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cost_analytic</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html#pennylane.StronglyEntanglingLayers" title="pennylane.StronglyEntanglingLayers" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">StronglyEntanglingLayers</span></a><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">analytic_dev</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hamiltonian.html#pennylane.Hamiltonian" title="pennylane.Hamiltonian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hamiltonian</span></a><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">obs</span><span class="p">))</span>
</pre></div>
</div>
<p>Creating the optimizer and beginning the optimization:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">opt</span></a> <span class="o">=</span> <span class="n">Rosalin</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">min_shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_params</span></a>

<span class="n">cost_rosalin</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_analytic</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">)]</span>
<span class="n">shots_rosalin</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer.step" title="pennylane.AdamOptimizer.step" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">opt</span><span class="o">.</span><span class="n">step</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">)</span>
    <span class="n">cost_rosalin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_analytic</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">))</span>
    <span class="n">shots_rosalin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">opt</span><span class="o">.</span><span class="n">shots_used</span></a><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Step </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: cost = </span><span class="si">{</span><span class="n">cost_rosalin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, shots_used = </span><span class="si">{</span><span class="n">shots_rosalin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Step 0: cost = -4.820380999693456, shots_used = 240
Step 1: cost = -4.937944875992973, shots_used = 336
Step 2: cost = -5.477016391676938, shots_used = 456
Step 3: cost = -5.878302378912975, shots_used = 624
Step 4: cost = -5.7409832352988746, shots_used = 768
Step 5: cost = -5.868499507174452, shots_used = 960
Step 6: cost = -5.572597618754926, shots_used = 1200
Step 7: cost = -6.038511127131683, shots_used = 1512
Step 8: cost = -7.187839850746339, shots_used = 1944
Step 9: cost = -7.244742040043007, shots_used = 2472
Step 10: cost = -6.955119947427082, shots_used = 3144
Step 11: cost = -7.3242803317884215, shots_used = 4176
Step 12: cost = -7.305099179560387, shots_used = 5400
Step 13: cost = -7.241339003277951, shots_used = 6528
Step 14: cost = -7.529075219255001, shots_used = 7632
Step 15: cost = -7.095276433317588, shots_used = 9048
Step 16: cost = -7.607336707435149, shots_used = 10584
Step 17: cost = -7.738585612241668, shots_used = 12624
Step 18: cost = -7.792700472104302, shots_used = 15288
Step 19: cost = -7.802640154411868, shots_used = 18048
Step 20: cost = -7.7651962845268105, shots_used = 20976
Step 21: cost = -7.77937999521944, shots_used = 24264
Step 22: cost = -7.851415989752516, shots_used = 27576
Step 23: cost = -7.829808564028129, shots_used = 31728
Step 24: cost = -7.813743545091881, shots_used = 36264
Step 25: cost = -7.790635224170298, shots_used = 42024
Step 26: cost = -7.887177094048006, shots_used = 48096
Step 27: cost = -7.877872495361856, shots_used = 54744
Step 28: cost = -7.875679215329844, shots_used = 62448
Step 29: cost = -7.855902055330614, shots_used = 71352
Step 30: cost = -7.8844348641017685, shots_used = 80832
Step 31: cost = -7.891637364212711, shots_used = 90336
Step 32: cost = -7.854723497132758, shots_used = 100680
Step 33: cost = -7.860436984930216, shots_used = 111984
Step 34: cost = -7.885736157831497, shots_used = 123312
Step 35: cost = -7.85171406923208, shots_used = 136632
Step 36: cost = -7.8648485293671975, shots_used = 150744
Step 37: cost = -7.875581235645933, shots_used = 166152
Step 38: cost = -7.809686333605921, shots_used = 183240
Step 39: cost = -7.884245542198441, shots_used = 202752
Step 40: cost = -7.889534749964768, shots_used = 221448
Step 41: cost = -7.89494822096451, shots_used = 240192
Step 42: cost = -7.897425239891586, shots_used = 262368
Step 43: cost = -7.879902900295499, shots_used = 285024
Step 44: cost = -7.8731225968466045, shots_used = 307704
Step 45: cost = -7.889285563108288, shots_used = 331272
Step 46: cost = -7.893112373227318, shots_used = 357552
Step 47: cost = -7.878308602523568, shots_used = 385320
Step 48: cost = -7.899236702757057, shots_used = 416208
Step 49: cost = -7.894296334408785, shots_used = 446808
Step 50: cost = -7.890494435194311, shots_used = 479976
Step 51: cost = -7.89229873961093, shots_used = 512928
Step 52: cost = -7.893708744149611, shots_used = 547176
Step 53: cost = -7.898823452831049, shots_used = 582960
Step 54: cost = -7.898889229118193, shots_used = 621072
Step 55: cost = -7.881052733782685, shots_used = 661488
Step 56: cost = -7.8913643791351875, shots_used = 703032
Step 57: cost = -7.897425674574112, shots_used = 747480
Step 58: cost = -7.89322196381792, shots_used = 794808
Step 59: cost = -7.896438792204625, shots_used = 842570
</pre></div>
</div>
<p>Let’s compare this to a standard Adam optimization. Using 100 shots per quantum
evaluation, for each update step there are 2 quantum evaluations per parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">adam_shots_per_eval</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">adam_shots_per_step</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">adam_shots_per_eval</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">adam_shots_per_step</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>2400
</pre></div>
</div>
<p>Thus, Adam is using 2400 shots per update step.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_params</span></a>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">opt</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">AdamOptimizer</span></a><span class="p">(</span><span class="mf">0.07</span><span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.shots" title="pennylane.QubitDevice.shots" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">non_analytic_dev</span><span class="o">.</span><span class="n">shots</span></a> <span class="o">=</span> <span class="n">adam_shots_per_eval</span>

<span class="nd">@qml</span><span class="o">.</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qnode</span></a><span class="p">(</span><span class="n">non_analytic_dev</span><span class="p">,</span> <span class="n">diff_method</span><span class="o">=</span><span class="s2">&quot;parameter-shift&quot;</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html#pennylane.StronglyEntanglingLayers" title="pennylane.StronglyEntanglingLayers" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">StronglyEntanglingLayers</span></a><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitDevice.html#pennylane.QubitDevice.wires" title="pennylane.QubitDevice.wires" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-attribute"><span class="n">non_analytic_dev</span><span class="o">.</span><span class="n">wires</span></a><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hamiltonian.html#pennylane.Hamiltonian" title="pennylane.Hamiltonian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hamiltonian</span></a><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">obs</span><span class="p">))</span>

<span class="n">cost_adam</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_analytic</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">)]</span>
<span class="n">shots_adam</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer.step" title="pennylane.AdamOptimizer.step" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">opt</span><span class="o">.</span><span class="n">step</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">)</span>
    <span class="n">cost_adam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_analytic</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">params</span></a><span class="p">))</span>
    <span class="n">shots_adam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adam_shots_per_step</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">{}</span><span class="s2">: cost = </span><span class="si">{}</span><span class="s2"> shots_used = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cost_adam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shots_adam</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Step 0: cost = -2.1215080393431585 shots_used = 2400
Step 1: cost = -3.4623876308433905 shots_used = 4800
Step 2: cost = -4.537203297341581 shots_used = 7200
Step 3: cost = -5.353118326528817 shots_used = 9600
Step 4: cost = -6.001801191119725 shots_used = 12000
Step 5: cost = -6.532083538539223 shots_used = 14400
Step 6: cost = -6.942441153376089 shots_used = 16800
Step 7: cost = -7.244737855902823 shots_used = 19200
Step 8: cost = -7.423627847268886 shots_used = 21600
Step 9: cost = -7.479757577491732 shots_used = 24000
Step 10: cost = -7.449813011010468 shots_used = 26400
Step 11: cost = -7.367541255853565 shots_used = 28800
Step 12: cost = -7.279683666101239 shots_used = 31200
Step 13: cost = -7.224730110890854 shots_used = 33600
Step 14: cost = -7.2148910339087955 shots_used = 36000
Step 15: cost = -7.245991183740552 shots_used = 38400
Step 16: cost = -7.306598002757761 shots_used = 40800
Step 17: cost = -7.38181477993802 shots_used = 43200
Step 18: cost = -7.45726333906283 shots_used = 45600
Step 19: cost = -7.5316389080470785 shots_used = 48000
Step 20: cost = -7.57910469345541 shots_used = 50400
Step 21: cost = -7.598334003525704 shots_used = 52800
Step 22: cost = -7.59971421973124 shots_used = 55200
Step 23: cost = -7.5928043955247295 shots_used = 57600
Step 24: cost = -7.583268134473892 shots_used = 60000
Step 25: cost = -7.577027079291158 shots_used = 62400
Step 26: cost = -7.576438791508551 shots_used = 64800
Step 27: cost = -7.586852063278766 shots_used = 67200
Step 28: cost = -7.605654132014295 shots_used = 69600
Step 29: cost = -7.626278144590118 shots_used = 72000
Step 30: cost = -7.650125962117969 shots_used = 74400
Step 31: cost = -7.683201477089145 shots_used = 76800
Step 32: cost = -7.7183740051132785 shots_used = 79200
Step 33: cost = -7.749858777925535 shots_used = 81600
Step 34: cost = -7.772109353442856 shots_used = 84000
Step 35: cost = -7.790213661265655 shots_used = 86400
Step 36: cost = -7.804024081800593 shots_used = 88800
Step 37: cost = -7.812888444107607 shots_used = 91200
Step 38: cost = -7.815303805021323 shots_used = 93600
Step 39: cost = -7.81559110336898 shots_used = 96000
Step 40: cost = -7.8190070298990335 shots_used = 98400
Step 41: cost = -7.820024515595161 shots_used = 100800
Step 42: cost = -7.8226820903757 shots_used = 103200
Step 43: cost = -7.835942908706416 shots_used = 105600
Step 44: cost = -7.846673061876044 shots_used = 108000
Step 45: cost = -7.85687645156377 shots_used = 110400
Step 46: cost = -7.867432268927422 shots_used = 112800
Step 47: cost = -7.872101683168518 shots_used = 115200
Step 48: cost = -7.874828365447865 shots_used = 117600
Step 49: cost = -7.8738362518061535 shots_used = 120000
Step 50: cost = -7.870653941040022 shots_used = 122400
Step 51: cost = -7.865659454419253 shots_used = 124800
Step 52: cost = -7.863415873131753 shots_used = 127200
Step 53: cost = -7.865732908433207 shots_used = 129600
Step 54: cost = -7.869710166077575 shots_used = 132000
Step 55: cost = -7.869933769692912 shots_used = 134400
Step 56: cost = -7.867626808358155 shots_used = 136800
Step 57: cost = -7.8672654374403965 shots_used = 139200
Step 58: cost = -7.866106032024279 shots_used = 141600
Step 59: cost = -7.86467552365777 shots_used = 144000
Step 60: cost = -7.865463349755135 shots_used = 146400
Step 61: cost = -7.869105447555635 shots_used = 148800
Step 62: cost = -7.874377661172734 shots_used = 151200
Step 63: cost = -7.879041999728493 shots_used = 153600
Step 64: cost = -7.883055053162936 shots_used = 156000
Step 65: cost = -7.883423475236572 shots_used = 158400
Step 66: cost = -7.878423033519141 shots_used = 160800
Step 67: cost = -7.871288462243791 shots_used = 163200
Step 68: cost = -7.866639137185702 shots_used = 165600
Step 69: cost = -7.865505392008527 shots_used = 168000
Step 70: cost = -7.868415515051664 shots_used = 170400
Step 71: cost = -7.872074131801975 shots_used = 172800
Step 72: cost = -7.878831104741045 shots_used = 175200
Step 73: cost = -7.884287581386944 shots_used = 177600
Step 74: cost = -7.884749717113527 shots_used = 180000
Step 75: cost = -7.882749897975346 shots_used = 182400
Step 76: cost = -7.876945325985559 shots_used = 184800
Step 77: cost = -7.868581989227958 shots_used = 187200
Step 78: cost = -7.861678374964601 shots_used = 189600
Step 79: cost = -7.853281709396774 shots_used = 192000
Step 80: cost = -7.850252907704906 shots_used = 194400
Step 81: cost = -7.858860862416596 shots_used = 196800
Step 82: cost = -7.868967998411967 shots_used = 199200
Step 83: cost = -7.877511593961299 shots_used = 201600
Step 84: cost = -7.8847851842267405 shots_used = 204000
Step 85: cost = -7.883670968481783 shots_used = 206400
Step 86: cost = -7.878049101350298 shots_used = 208800
Step 87: cost = -7.874649635646179 shots_used = 211200
Step 88: cost = -7.874729902637037 shots_used = 213600
Step 89: cost = -7.880261318183024 shots_used = 216000
Step 90: cost = -7.887977964131153 shots_used = 218400
Step 91: cost = -7.889672751805973 shots_used = 220800
Step 92: cost = -7.88187334079144 shots_used = 223200
Step 93: cost = -7.8714284955094245 shots_used = 225600
Step 94: cost = -7.862935048938819 shots_used = 228000
Step 95: cost = -7.855236207158368 shots_used = 230400
Step 96: cost = -7.856834624664483 shots_used = 232800
Step 97: cost = -7.869312555157773 shots_used = 235200
Step 98: cost = -7.880165967260662 shots_used = 237600
Step 99: cost = -7.886545349645061 shots_used = 240000
</pre></div>
</div>
<p>Plotting both experiments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;seaborn&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">shots_rosalin</span><span class="p">,</span> <span class="n">cost_rosalin</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Rosalin&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">shots_adam</span><span class="p">,</span> <span class="n">cost_adam</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Adam&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Cost function value&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of shots&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300000</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_rosalin_002.png" srcset="../_images/sphx_glr_tutorial_rosalin_002.png" alt="tutorial rosalin" class = "sphx-glr-single-img"/><p>The Rosalin optimizer performs significantly better than the Adam optimizer,
approaching the ground state energy of the Hamiltonian with strikingly
fewer shots.</p>
<p>While beyond the scope of this demonstration, the Rosalin optimizer can be
modified in various other ways; for instance, by incorporating <em>weighted hybrid
sampling</em> (which distributes some shots deterministically, with the remainder
done randomly), or by adapting the variant iCANS2 optimizer. Download
this demonstration from the sidebar 👉 and give it a go! ⚛️</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="arrasmith2020"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id5">2</a>,<a href="#id6">3</a>,<a href="#id7">4</a>)</span></dt>
<dd><p>Andrew Arrasmith, Lukasz Cincio, Rolando D. Somma, and Patrick J. Coles. “Operator Sampling
for Shot-frugal Optimization in Variational Algorithms.” <a class="reference external" href="https://arxiv.org/abs/2004.06252">arXiv:2004.06252</a> (2020).</p>
</dd>
<dt class="label" id="stokes2019"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>James Stokes, Josh Izaac, Nathan Killoran, and Giuseppe Carleo. “Quantum Natural Gradient.”
<a class="reference external" href="https://arxiv.org/abs/1909.02108">arXiv:1909.02108</a> (2019).</p>
</dd>
<dt class="label" id="sweke2019"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Ryan Sweke, Frederik Wilde, Johannes Jakob Meyer, Maria Schuld, Paul K. Fährmann, Barthélémy
Meynard-Piganeau, and Jens Eisert. “Stochastic gradient descent for hybrid quantum-classical
optimization.” <a class="reference external" href="https://arxiv.org/abs/1910.01155">arXiv:1910.01155</a> (2019).</p>
</dd>
<dt class="label" id="kubler2020"><span class="brackets">4</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id8">2</a>)</span></dt>
<dd><p>Jonas M. Kübler, Andrew Arrasmith, Lukasz Cincio, and Patrick J. Coles. “An Adaptive Optimizer
for Measurement-Frugal Variational Algorithms.” <a class="reference external" href="https://quantum-journal.org/papers/q-2020-05-11-263/">Quantum 4, 263</a> (2020).</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/josh_izaac.png" alt="Josh Izaac" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Josh Izaac</h4>
        <p class="bio-text__author-description">Josh is a theoretical physicist, software tinkerer, and occasional baker. At Xanadu, he contributes to the development and growth of Xanadu’s open-source quantum software products.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 3 minutes  7.377 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-rosalin-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/be5d18c3f861d447bd25da306edb5e81/tutorial_rosalin.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_rosalin.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/4fbb3623bfe9f105522f46629a99410c/tutorial_rosalin.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_rosalin.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_rosalin</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Frugal shot optimization with Rosalin</a><ul class='current'>
<li class='current'><a class="reference internal" href="#background">Background</a></li>
<li class='current'><a class="reference internal" href="#weighted-random-sampling">Weighted random sampling</a></li>
<li class='current'><a class="reference internal" href="#rosalin-frugal-shot-optimization">Rosalin: Frugal shot optimization</a><ul class='current'>
<li class='current'><a class="reference internal" href="#icans-optimizer">iCANS optimizer</a></li>
<li class='current'><a class="reference internal" href="#rosalin-implementation">Rosalin implementation</a></li>
<li class='current'><a class="reference internal" href="#rosalin-optimization">Rosalin optimization</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_rosalin</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_optimization.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_falqon.html" title="Feedback-Based Quantum Optimization (FALQON)"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_rotoselect.html" title="Quantum circuit structure learning"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" >Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Frugal shot optimization with Rosalin</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>