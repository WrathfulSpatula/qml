
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Learn about multivariate quantum gates for optimization" property="og:description" />
<meta content="https://pennylane.ai/qml/_images/thumbnail_tutorial_here_comes_the_sun.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Here comes the SU(N): multivariate quantum gates and gradients &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_here_comes_the_sun.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Learn about multivariate quantum gates for optimization" property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Here comes the SU(N): multivariate quantum gates and gradients &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_here_comes_the_sun.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Videos" href="../videos.html" />
    <link rel="prev" title="Perturbative Gadgets for Variational Quantum Algorithms" href="tutorial_barren_gadgets.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../videos.html" title="Videos"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_barren_gadgets.html" title="Perturbative Gadgets for Variational Quantum Algorithms"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" accesskey="U">Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Here comes the SU(N): multivariate quantum gates and gradients</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-here-comes-the-sun-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="here-comes-the-su-n-multivariate-quantum-gates-and-gradients">
<span id="sphx-glr-demos-tutorial-here-comes-the-sun-py"></span><h1>Here comes the SU(N): multivariate quantum gates and gradients<a class="headerlink" href="#here-comes-the-su-n-multivariate-quantum-gates-and-gradients" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_vqe.html", "tutorial_general_parshift.html", "tutorial_unitary_designs.html"];
    var related_tutorials_titles = ['A brief overview of VQE', 'General parameter-shift rules for quantum gradients', 'Unitary designs and their uses in quantum computing'];
</script></p>
<p><em>Author: David Wierichs — Posted: 03 April 2023.</em></p>
<p>How do we choose an ansatz when designing a quantum circuit for a variational
quantum algorithm? And what happens if we do not start with elementary hardware-friendly
gates and compose them, but we instead use a more complex building block for local qubit
interactions and allow for multi-parameter gates from the start?
Can we differentiate such circuits, and how do they perform in optimization tasks?</p>
<p>Let’s find out!</p>
<p>In this tutorial, you will learn about the <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> gate
<a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpecialUnitary</span></code></a>, a particular quantum gate which
can act like <em>any</em> gate on its qubits by choosing the parameters accordingly.
We will look at a custom derivative rule <a class="footnote-reference brackets" href="#wiersema" id="id1">2</a> for this gate and compare it to two
alternative differentiation strategies, namely finite differences and the <a class="reference external" href="https://pennylane.ai/qml/demos/tutorial_stochastic_parameter_shift.html">stochastic
parameter-shift rule</a>.
Finally, we will compare the performance of
<code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> for a toy minimization problem to that of two other general
local gates. That is, we compare the trainability of equally expressive ansätze.</p>
<div class="section" id="ansatze-so-many-ansatze">
<h2>Ansätze, so many ansätze<a class="headerlink" href="#ansatze-so-many-ansatze" title="Permalink to this headline">¶</a></h2>
<p>Variational quantum algorithms have been promoted to be useful for many applications.
When designing these algorithms, a central task is to choose the quantum circuit ansatz,
which provides a parameterization of quantum states. In the course of a variational algorithm,
the circuit parameters are then optimized in order to minimize some cost function.
The choice of the ansatz can have a big impact on the quantum states that can be found
by the algorithm (expressivity) and on the optimization’s behaviour (trainability).</p>
<p>Typically, it also affects the
computational cost of executing the algorithm on quantum hardware and the strength of the noise
that enters the computation. Finally, the application itself influences, or
even fixes, the choice of ansatz for some variational quantum algorithms,
which can lead to constraints in the ansatz design.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/SUN_demo_Ansatz.png"><img alt="../_images/SUN_demo_Ansatz.png" src="../_images/SUN_demo_Ansatz.png" style="width: 90%;" /></a>
</div>
<p>While a number of best practices for ansatz design have been developed,
a lot is still unknown about the connection between circuit structures and the
resulting properties. Therefore, circuit design is often also based on intuition or heuristics;
an ansatz reported in the literature might just have turned out
to work particularly well for a given problem or might fall into a “standard”
category of circuits.</p>
<p>If the application does not constrain the choice of ansatz, we may want to avoid choosing
somewhat arbitrary circuit ansätze that may introduce undesirable biases.
Instead, we will want to reflect the generic structure of the problem by performing a
fully general operation on the qubit register.
However, if we were to do so, the number of parameters required to produce such a general
operation would grow much too quickly. Instead, we want to consider fully general operations
<em>on a few qubits</em> and compose them into a fabric of local gates. For two-qubit operations,
the fabric could look like this:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/SUN_demo_SU4.png"><img alt="../_images/SUN_demo_SU4.png" src="../_images/SUN_demo_SU4.png" style="width: 60%;" /></a>
</div>
<p>The general local operation can be implemented by composing a suitable combination
of elementary gates, like single-qubit rotations and CNOT gates. Alternatively, we may
choose a canonical parameterization of the group that contains all local operations, and we will
see that this is an advantageous approach for the trainability of the ansatz.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/SUN_demo_optimization.png"><img alt="../_images/SUN_demo_optimization.png" src="../_images/SUN_demo_optimization.png" style="width: 60%;" /></a>
</div>
<p>Before we can use the <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> gate in training, we will need to
learn how to differentiate it in a quantum circuit. But first things first:
let’s start with a brief math intro — no really, just a <em>Liettle</em> bit.</p>
</div>
<div class="section" id="the-special-unitary-group-su-n-and-its-lie-algebra">
<h2>The special unitary group SU(N) and its Lie algebra<a class="headerlink" href="#the-special-unitary-group-su-n-and-its-lie-algebra" title="Permalink to this headline">¶</a></h2>
<p>The gate we will look at is given by a specific parameterization of the
<a class="reference external" href="https://en.wikipedia.org/wiki/Special_unitary_group">special unitary group</a>
<span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span>, where <span class="math notranslate nohighlight">\(N=2^n\)</span> is the Hilbert space dimension of the gate
for <span class="math notranslate nohighlight">\(n\)</span> qubits. Mathematically, the group can be defined as the set of operators
(or matrices) that can be inverted by taking their adjoint and that have
determinant <span class="math notranslate nohighlight">\(1\)</span>. In general, all quantum gates acting on <span class="math notranslate nohighlight">\(n\)</span> qubits are
elements of <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> up to a global phase.</p>
<p>The group <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> is a <a class="reference external" href="https://en.wikipedia.org/wiki/Lie_group">Lie group</a>,
and its associated <a class="reference external" href="https://en.wikipedia.org/wiki/Lie_algebra">Lie algebra</a>
is <span class="math notranslate nohighlight">\(\mathfrak{su}(N)\)</span>. For our purposes, it will be sufficient to look at a matrix
representation of the algebra and we may define it as</p>
<div class="math notranslate nohighlight">
\[\mathfrak{su}(N) =
\{\Omega \in \mathbb{C}^{N\times N}: \Omega^\dagger=-\Omega, \operatorname{Tr}[\Omega]=0\}.\]</div>
<p>The conditions are that the elements <span class="math notranslate nohighlight">\(\Omega\)</span> are <em>skew-Hermitian</em> and that their trace vanishes.
We will use so-called canonical coordinates for the algebra which are simply the coefficients
in the Pauli basis. That is, we consider the Pauli basis elements multiplied with the
imaginary unit <span class="math notranslate nohighlight">\(i\)</span>, except for the identity:</p>
<div class="math notranslate nohighlight">
\[G_m \in \mathcal{P}^{(n)} = i \left\{I,X,Y,Z\right\}^n \setminus \{i I^n\}.\]</div>
<p>A Lie algebra element <span class="math notranslate nohighlight">\(\Omega\)</span> can be written as</p>
<div class="math notranslate nohighlight">
\[\Omega = \sum_{m=1}^d \theta_m G_m,\quad \theta_m \in \mathbb{R}\]</div>
<p>and those coefficients <span class="math notranslate nohighlight">\(\theta\)</span> are precisely the canonical coordinates.
You may ask why we included the prefactor <span class="math notranslate nohighlight">\(i\)</span> in the definition of <span class="math notranslate nohighlight">\(G_m\)</span> and why we excluded
the identity (times <span class="math notranslate nohighlight">\(i\)</span>). This was done to match the properties of <span class="math notranslate nohighlight">\(\mathfrak{su}(N)\)</span>;
the prefactor makes the basis elements skew-Hermitian and the identity would not have a
vanishing trace. Indeed, one can check that the dimension of <span class="math notranslate nohighlight">\(\mathfrak{su}(N)\)</span> is
<span class="math notranslate nohighlight">\(4^n-1\)</span> and that there are <span class="math notranslate nohighlight">\(4^n\)</span> Pauli words, so that one Pauli word — the identity — had to go
in any case… We can use the canonical coordinates of the algebra to express a <em>group element</em> in
<span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> as well, and the <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> gate we will use is defined as</p>
<div class="math notranslate nohighlight">
\[U(\boldsymbol{\theta}) = \exp\left\{\sum_{m=1}^d \theta_m G_m \right\}.\]</div>
<p>The number of coordinates and Pauli words in <span class="math notranslate nohighlight">\(\mathcal{P}^{(n)}\)</span> is <span class="math notranslate nohighlight">\(d=4^n-1\)</span>.
Therefore, this will be the number of parameters that a single <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> gate acting on
<span class="math notranslate nohighlight">\(n\)</span> qubits will take. For example, it takes just three parameters for a single qubit, which
is why <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rot</span></code></a> and <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.U3.html#pennylane.U3" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">U3</span></code></a> take three parameters and may
produce <em>any</em> single-qubit rotation. It takes a modest 15 parameters for two qubits,
but it already requires 63 parameters for three qubits.</p>
<p>For unitaries generated by a single operator, i.e. of the form <span class="math notranslate nohighlight">\(\exp(i\theta G)\)</span>,
there is a plethora of differentiation techniques that allow us to compute its derivative.
However, a standard parameter-shift rule, for example, will not do the job if there are
non-commuting terms <span class="math notranslate nohighlight">\(G_m\)</span> in the multi-parameter gate <span class="math notranslate nohighlight">\(U(\boldsymbol{\theta})\)</span> above.
So how <em>do</em> we compute the derivative?</p>
</div>
<div class="section" id="obtaining-the-gradient">
<h2>Obtaining the gradient<a class="headerlink" href="#obtaining-the-gradient" title="Permalink to this headline">¶</a></h2>
<p>In variational quantum algorithms, we typically use the circuit to prepare a quantum state and
then we measure some observable <span class="math notranslate nohighlight">\(H\)</span>. The resulting real-valued output is considered to be the
cost function <span class="math notranslate nohighlight">\(C\)</span> that should be minimized. If we want to use gradient-based optimization for
this task, we need a method to compute the gradient <span class="math notranslate nohighlight">\(\nabla C\)</span> in addition to the cost
function itself. As derived in the publication <a class="footnote-reference brackets" href="#wiersema" id="id2">2</a>, this is possible on quantum hardware
for <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> gates as long as the gates themselves can be implemented.
The implementation in PennyLane follows the decomposition idea described in App. F3, but the
main text of <a class="footnote-reference brackets" href="#wiersema" id="id3">2</a> proposes an additional method that scales better in some scenarios
(the caveat being that this method requires additional gates to be available on the quantum hardware).
Here, we will focus on the former method.
We will not go through the entire derivation, but note the following key points:</p>
<ul class="simple">
<li><p>The gradient with respect to all <span class="math notranslate nohighlight">\(d\)</span> parameters of an <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> gate can be
computed using <span class="math notranslate nohighlight">\(2d\)</span> auxiliary circuits. Each of the circuits contains one additional
operation compared to the original circuit, namely a <code class="docutils literal notranslate"><span class="pre">qml.PauliRot</span></code> gate with rotation
angles of <span class="math notranslate nohighlight">\(\pm\frac{\pi}{2}\)</span>. Note that these Pauli rotations act on up to <span class="math notranslate nohighlight">\(n\)</span>
qubits.</p></li>
<li><p>This differentiation method uses automatic differentiation during compilation and
classical coprocessing steps, but is compatible with quantum hardware. For large <span class="math notranslate nohighlight">\(n\)</span>,
the classical processing steps can quickly become prohibitively expensive.</p></li>
<li><p>The computed gradient is not an approximative technique but allows for an exact computation
of the gradient on simulators. On quantum hardware, this leads to unbiased gradient
estimators.</p></li>
</ul>
<p>The implementation in PennyLane takes care of creating the additional circuits and evaluating
them, and with adequate post-processing we get the gradient <span class="math notranslate nohighlight">\(\nabla C\)</span>.</p>
</div>
<div class="section" id="comparing-gradient-methods">
<h2>Comparing gradient methods<a class="headerlink" href="#comparing-gradient-methods" title="Permalink to this headline">¶</a></h2>
<p>Before we dive into using <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> in an optimization task, let’s compare
a few methods to compute the gradient with respect to the parameters of such a gate.
In particular, we will look at a finite difference (FD) approach, the stochastic parameter-shift
rule, and the custom gradient method we described above.</p>
<p>For the first approach, we will use the standard central difference recipe given by</p>
<div class="math notranslate nohighlight">
\[\partial_{\text{FD},\theta_j}C(\boldsymbol{\theta})
=\left[C\left(\boldsymbol{\theta}+\frac{\delta}{2}\boldsymbol{e}_j\right)
-C\left(\boldsymbol{\theta}-\frac{\delta}{2}\boldsymbol{e}_j\right)\right] / \delta.\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\delta\)</span> is a shift parameter that we need to choose and <span class="math notranslate nohighlight">\(\boldsymbol{e}_j\)</span> is the
<span class="math notranslate nohighlight">\(j\)</span>-th canonical basis vector, i.e. the all-zeros vector with a one in the
<span class="math notranslate nohighlight">\(j\)</span>-th entry. This approach is agnostic to the differentiated function and does
not exploit its structure.</p>
<p>In contrast, the stochastic parameter-shift rule is a differentiation recipe developed particularly
for multi-parameter gates like the <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> gates <a class="footnote-reference brackets" href="#banchi" id="id4">3</a>. It involves the
approximate evaluation of an integral by sampling <em>splitting times</em> <span class="math notranslate nohighlight">\(\tau\)</span> and
evaluating an expression close to the non-stochastic parameter-shift rule for each sample.
For more details, also consider the
<a class="reference internal" href="tutorial_stochastic_parameter_shift.html"><span class="doc">demo on the stochastic parameter-shift rule</span></a>.</p>
<p>So, let’s dive into a toy example and explore the three gradient methods!
We start by defining a simple one-qubit circuit that contains a single <span class="math notranslate nohighlight">\(\mathrm{SU}(2)\)</span>
gate and measures the expectation value of <span class="math notranslate nohighlight">\(H=\frac{3}{5} Z - \frac{4}{5} Y\)</span>.
As <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> requires automatic differentiation subroutines even for the
hardware-ready derivative recipe, we will make use of JAX.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">jax</span>

<span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_enable_x64&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_platform_name&quot;</span><span class="p">,</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
<span class="n">jnp</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span>

<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.8</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliY.html#pennylane.PauliY" title="pennylane.PauliY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliY</span></a><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">qfunc</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">SpecialUnitary</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">)</span>


<span class="n">circuit</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QNode</span></a><span class="p">(</span><span class="n">qfunc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">,</span> <span class="n">diff_method</span><span class="o">=</span><span class="s2">&quot;parameter-shift&quot;</span><span class="p">)</span>

<span class="n">theta</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
</pre></div>
</div>
<p>Now we need to set up the differentiation methods. For this demonstration, we will
keep the first and last entry of <code class="docutils literal notranslate"><span class="pre">theta</span></code> fixed and only compute the gradient for the
second parameter. This allows us to visualize the results easily and keeps the
computational effort to a minimum.</p>
<p>We start with the finite-difference
recipe, using a shift scale of <span class="math notranslate nohighlight">\(\delta=0.75\)</span>. This choice of <span class="math notranslate nohighlight">\(\delta\)</span>,
which is much larger than usual for numerical differentiation on classical computers,
is adapted to the scenario of shot-based gradients (see App. F2 of <a class="footnote-reference brackets" href="#wiersema" id="id5">2</a>).
We compute the derivative with respect to the second entry of theta, so we will use
the unit vector <span class="math notranslate nohighlight">\(e_2\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unit_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">central_diff_grad</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
    <span class="n">plus_eval</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">theta</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit_vector</span><span class="p">)</span>
    <span class="n">minus_eval</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit_vector</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">plus_eval</span> <span class="o">-</span> <span class="n">minus_eval</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span>


<span class="n">delta</span> <span class="o">=</span> <span class="mf">0.75</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Central difference: </span><span class="si">{</span><span class="n">central_diff_grad</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span><span class="w"> </span><span class="n">delta</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Central difference: 0.42398
</pre></div>
</div>
<p>Next up, we implement the stochastic parameter-shift rule. Of course we do not do
so in full generality, but for the particular circuit in this example. We will
sample ten splitting times to obtain the gradient entry. For each splitting time,
we need to insert a Pauli-<span class="math notranslate nohighlight">\(Y\)</span> rotation because <span class="math notranslate nohighlight">\(\theta_2\)</span> belongs to
the Pauli-<span class="math notranslate nohighlight">\(Y\)</span> component of <span class="math notranslate nohighlight">\(A(\boldsymbol{\theta})\)</span>. For this, we define
an auxiliary circuit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">aux_circuit</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sign</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">SpecialUnitary</span></a><span class="p">(</span><span class="n">tau</span> <span class="o">*</span> <span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># This corresponds to the parameter-shift evaluations of RY at 0</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="o">-</span><span class="n">sign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">SpecialUnitary</span></a><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">)</span>


<span class="k">def</span> <span class="nf">stochastic_parshift_grad</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">):</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">splitting_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">splitting_times</span><span class="p">:</span>
        <span class="c1"># Evaluate the two-term parameter-shift rule of the auxiliar circuit</span>
        <span class="n">grad</span> <span class="o">+=</span> <span class="n">aux_circuit</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">aux_circuit</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grad</span> <span class="o">/</span> <span class="n">num_samples</span>


<span class="n">num_samples</span> <span class="o">=</span> <span class="mi">10</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stochastic parameter-shift: </span><span class="si">{</span><span class="n">stochastic_parshift_grad</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span><span class="w"> </span><span class="n">num_samples</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Stochastic parameter-shift: 0.82560
</pre></div>
</div>
<p>Finally, we can make use of the custom parameter-shift rule introduced in
<a class="footnote-reference brackets" href="#wiersema" id="id6">2</a>, which is readily available in PennyLane. Due to the implementation
chosen internally, the full gradient is returned; we need to pick the second
gradient entry manually. For this small toy problem, this is
not an issue.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sun_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Custom SU(N) gradient: </span><span class="si">{</span><span class="n">sun_grad</span><span class="p">(</span><span class="n">theta</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Custom SU(N) gradient: 0.42609
</pre></div>
</div>
<p>We obtained three values for the gradient of interest, and they do not agree.
So what is going on here? First, let’s use automatic differentiation to compute
the exact value and see which method agrees with it (we again need to extract the
corresponding entry from the full gradient).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">autodiff_circuit</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QNode</span></a><span class="p">(</span><span class="n">qfunc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">,</span> <span class="n">diff_method</span><span class="o">=</span><span class="s2">&quot;parameter-shift&quot;</span><span class="p">)</span>
<span class="n">exact_grad</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">autodiff_circuit</span></a><span class="p">)(</span><span class="n">theta</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exact gradient: </span><span class="si">{</span><span class="n">exact_grad</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Exact gradient: 0.42609
</pre></div>
</div>
<p>As we can see, automatic differentiation confirmed that the custom differentiation method
gave us the correct result. Why do the other methods disagree?
This is because the finite difference recipe is an <em>approximate</em> gradient
method. This means it has an error even if all circuit evaluations are
made exact (up to numerical precision) like in the example above.
As for the stochastic parameter-shift rule, you may already guess why there is
a deviation: indeed, the <em>stochastic</em> nature of this method leads to derivative
values that are scattered around the true value. It is an unbiased estimator,
so the average will approach the exact value with increasingly many evaluations.
To demonstrate this, let’s compute the same derivative many times and plot
a histogram of what we get. We’ll do so for <code class="docutils literal notranslate"><span class="pre">num_samples=2</span></code>, <code class="docutils literal notranslate"><span class="pre">10</span></code> and <code class="docutils literal notranslate"><span class="pre">100</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;font.size&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;#ACE3FF&quot;</span><span class="p">,</span> <span class="s2">&quot;#FF87EB&quot;</span><span class="p">,</span> <span class="s2">&quot;#FFE096&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">colors</span><span class="p">):</span>
    <span class="n">grads</span> <span class="o">=</span> <span class="p">[</span><span class="n">stochastic_parshift_grad</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_samples</span><span class="si">}</span><span class="s2"> samples&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
<span class="n">ylim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">exact_grad</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Exact&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\partial_{SPS,\theta_2}C(\theta)$&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper left&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_here_comes_the_sun_001.png" srcset="../_images/sphx_glr_tutorial_here_comes_the_sun_001.png" alt="tutorial here comes the sun" class = "sphx-glr-single-img"/><p>As we can see, the stochastic parameter-shift rule comes with a variance
that can be reduced at the additional cost of evaluating the auxiliary circuit
for more splitting times.</p>
<p>On quantum hardware, all measurement results are statistical in nature anyway.
So how does this stochasticity combine with the
three differentiation methods? We will not go into detail here, but refer
to <a class="footnote-reference brackets" href="#wiersema" id="id7">2</a> to see how the custom differentiation rule proposed in the
main text leads to the lowest mean squared error. For a single-qubit circuit
similar to the one above, but with the single gate <span class="math notranslate nohighlight">\(U(\boldsymbol{\theta})=\exp(iaX+ibY)\)</span>,
the derivative and its expected variance are shown in the following
(recoloured) plot from the manuscript:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/sampled_grad.png"><img alt="../_images/sampled_grad.png" src="../_images/sampled_grad.png" style="width: 70%;" /></a>
</div>
<p>As we can see, the custom <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> parameter-shift rule produces the
gradient estimates with the smallest variance. For small values of the parameter
<span class="math notranslate nohighlight">\(b\)</span>, which is fixed for each panel, the custom shift rule and the stochastic
shift rule approach the standard two-term parameter-shift rule, which would be exact
for <span class="math notranslate nohighlight">\(b=0\)</span>.
The finite difference gradient shown here was obtained using the shift
scale <span class="math notranslate nohighlight">\(\delta=0.75\)</span>, as well. As we can see, this suppresses the variance down to
a level comparable to those of the shift rule derivatives and this shift scale is a
reasonable trade-off between the variance and the systematic error we observed earlier.
As shown in App. F3 of <a class="footnote-reference brackets" href="#wiersema" id="id8">2</a>, this scale is indeed close to the optimal choice
if we were to compute the gradient with 100 shots per circuit.</p>
</div>
<div class="section" id="comparing-ansatz-structures">
<h2>Comparing ansatz structures<a class="headerlink" href="#comparing-ansatz-structures" title="Permalink to this headline">¶</a></h2>
<p>We discussed above that there are many circuit architectures available and that choosing
a suitable ansatz is important but can be difficult. Here, we will compare a simple ansatz
based on the <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> gate discussed above to other approaches that fully
parametrize the special unitary group for the respective number of qubits.
In particular, we will compare <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> to standard decompositions from the
literature that parametrize <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> with elementary gates, as well as to a
sequence of Pauli rotation gates that also allows us to create any special unitary.
Let us start by defining the decomposition of a two-qubit unitary.
We choose the decomposition, which is optimal but not unique, from <a class="footnote-reference brackets" href="#vatan" id="id9">1</a>.
The Pauli rotation sequence is available in PennyLane
via <code class="docutils literal notranslate"><span class="pre">qml.ArbitraryUnitary</span></code> and we will not need to implement it ourselves.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">two_qubit_decomp</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">wires</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implement an arbitrary SU(4) gate on two qubits</span>
<span class="sd">    using the decomposition from Theorem 5 in</span>
<span class="sd">    https://arxiv.org/pdf/quant-ph/0308006.pdf&quot;&quot;&quot;</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">wires</span>
    <span class="c1"># Single U(2) parameterization on both qubits separately</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="pennylane.Rot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Rot</span></a><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="pennylane.Rot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Rot</span></a><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>  <span class="c1"># First CNOT</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>  <span class="c1"># Second CNOT</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>  <span class="c1"># Third CNOT</span>
    <span class="c1"># Single U(2) parameterization on both qubits separately</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="pennylane.Rot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Rot</span></a><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">12</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="pennylane.Rot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Rot</span></a><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">12</span><span class="p">:</span><span class="mi">15</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>


<span class="c1"># The three building blocks on two qubits we will compare are:</span>
<span class="n">operations</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="s2">&quot;Decomposition&quot;</span><span class="p">,</span> <span class="s2">&quot;decomposition&quot;</span><span class="p">):</span> <span class="n">two_qubit_decomp</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;PauliRot sequence&quot;</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.ArbitraryUnitary.html#pennylane.ArbitraryUnitary" title="pennylane.ArbitraryUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">ArbitraryUnitary</span></a><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;$\mathrm</span><span class="si">{SU}</span><span class="s2">(N)$ gate&quot;</span><span class="p">,</span> <span class="s2">&quot;SU(N) gate&quot;</span><span class="p">):</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">SpecialUnitary</span></a><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that we have the template for the composition approach in place, we construct a toy
problem to solve using the ansätze. We will sample a random Hamiltonian in the Pauli basis
(this time without the prefactor <span class="math notranslate nohighlight">\(i\)</span>, as we want to construct a Hermitian operator)
with independent coefficients that follow a normal distribution:</p>
<div class="math notranslate nohighlight">
\[H = \sum_{m=1}^d h_m G_m,\quad h_m\sim \mathcal{N}(0,1).\]</div>
<p>We will work with six qubits.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">num_wires</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">wires</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_wires</span><span class="p">))</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">62213</span><span class="p">)</span>

<span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="n">num_wires</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># Create the matrices for the entire Pauli basis</span>
<span class="n">basis</span> <span class="o">=</span> <span class="n">qml</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">qubit</span><span class="o">.</span><span class="n">special_unitary</span><span class="o">.</span><span class="n">pauli_basis_matrices</span><span class="p">(</span><span class="n">num_wires</span><span class="p">)</span>
<span class="c1"># Construct the Hamiltonian from the normal random coefficients and the basis</span>
<span class="n">H_matrix</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.math.tensordot.html#pennylane.math.tensordot" title="pennylane.math.tensordot" class="sphx-glr-backref-module-pennylane-math sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">tensordot</span></a><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hermitian</span></a><span class="p">(</span><span class="n">H_matrix</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span><span class="p">)</span>
<span class="c1"># Compute the ground state energy</span>
<span class="n">E_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">eigvals</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ground state energy: </span><span class="si">{</span><span class="n">E_min</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Ground state energy: -119.70320
</pre></div>
</div>
<p>Using the toy problem Hamiltonian and the three ansätze for <span class="math notranslate nohighlight">\(\mathrm{SU}(N)\)</span> operations
from above, we create a circuit template that applies these operations in a brick-layer
architecture with two blocks and each operation acting on <code class="docutils literal notranslate"><span class="pre">loc=2</span></code> qubits.
For this we define a <code class="docutils literal notranslate"><span class="pre">QNode</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">loc</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">loc</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># d = 15 for two-qubit operations</span>
<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">num_wires</span><span class="p">)</span>
<span class="c1"># two blocks with two layers. Each layer contains three operations with d parameters</span>
<span class="n">param_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="n">init_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param_shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">operation</span></a><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply an operation in a brickwall-like pattern to a qubit register and measure H.</span>
<span class="sd">    Parameters are assumed to have the dimensions (number of blocks, number of</span>
<span class="sd">    wires per operation, number of operations per layer, and number of parameters</span>
<span class="sd">    per operation), in that order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">params_block</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">params_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params_block</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">params_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params_layer</span><span class="p">):</span>
                <span class="n">wires_op</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">%</span> <span class="n">num_wires</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loc</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)]</span>
                <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">operation</span></a><span class="p">(</span><span class="n">params_op</span><span class="p">,</span> <span class="n">wires_op</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">)</span>


<span class="n">qnode</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QNode</span></a><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.draw.html#pennylane.draw" title="pennylane.draw" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">draw</span></a><span class="p">(</span><span class="n">qnode</span><span class="p">)(</span><span class="n">init_params</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">SpecialUnitary</span></a><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>0: ─╭SpecialUnitary(M0)─────────────────────╭SpecialUnitary(M0)─╭SpecialUnitary(M0)
1: ─╰SpecialUnitary(M0)─╭SpecialUnitary(M0)─│───────────────────╰SpecialUnitary(M0)
2: ─╭SpecialUnitary(M0)─╰SpecialUnitary(M0)─│───────────────────╭SpecialUnitary(M0)
3: ─╰SpecialUnitary(M0)─╭SpecialUnitary(M0)─│───────────────────╰SpecialUnitary(M0)
4: ─╭SpecialUnitary(M0)─╰SpecialUnitary(M0)─│───────────────────╭SpecialUnitary(M0)
5: ─╰SpecialUnitary(M0)─────────────────────╰SpecialUnitary(M0)─╰SpecialUnitary(M0)

──────────────────────╭SpecialUnitary(M0)─┤ ╭&lt;𝓗(M1)&gt;
──╭SpecialUnitary(M0)─│───────────────────┤ ├&lt;𝓗(M1)&gt;
──╰SpecialUnitary(M0)─│───────────────────┤ ├&lt;𝓗(M1)&gt;
──╭SpecialUnitary(M0)─│───────────────────┤ ├&lt;𝓗(M1)&gt;
──╰SpecialUnitary(M0)─│───────────────────┤ ├&lt;𝓗(M1)&gt;
──────────────────────╰SpecialUnitary(M0)─┤ ╰&lt;𝓗(M1)&gt;
</pre></div>
</div>
<p>We can now proceed to prepare the optimization task using this circuit
and an optimization routine of our choice. For simplicity, we run a vanilla gradient
descent optimization with a fixed learning rate for 500 steps. Again, we use JAX</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># for auto-differentiation.</span>

<span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">5e-4</span>
<span class="n">num_steps</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">init_params</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_params</span><span class="p">)</span>
<span class="n">grad_fn</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">qnode</span><span class="p">),</span> <span class="n">static_argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qnode</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">qnode</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>With this configuration, let’s run the optimization!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">energies</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">print_name</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">operation</span></a> <span class="ow">in</span> <span class="n">operations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running the optimization for the </span><span class="si">{</span><span class="n">print_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">init_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">energy</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">qnode</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">operation</span></a><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad_fn</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">operation</span></a><span class="p">)</span>
        <span class="n">energy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>  <span class="c1"># Store energy value</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Report current energy</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">step</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> Steps: </span><span class="si">{</span><span class="n">cost</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">energy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qnode</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="pennylane.SpecialUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">operation</span></a><span class="p">))</span>  <span class="c1"># Final energy value</span>
    <span class="n">energies</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Running the optimization for the decomposition
  0 Steps: 0.108347
 50 Steps: -20.304280
100 Steps: -46.639755
150 Steps: -62.803368
200 Steps: -70.680297
250 Steps: -74.809580
300 Steps: -77.212092
350 Steps: -78.814361
400 Steps: -80.016451
450 Steps: -81.025807
Running the optimization for the PauliRot sequence
  0 Steps: 0.108347
 50 Steps: -39.877320
100 Steps: -54.140646
150 Steps: -59.806581
200 Steps: -64.677694
250 Steps: -69.808084
300 Steps: -75.313238
350 Steps: -80.848057
400 Steps: -85.016118
450 Steps: -87.853931
Running the optimization for the SU(N) gate
  0 Steps: 0.108347
 50 Steps: -63.548081
100 Steps: -84.956818
150 Steps: -94.176547
200 Steps: -100.707290
250 Steps: -104.434910
300 Steps: -106.567958
350 Steps: -108.110054
400 Steps: -109.453172
450 Steps: -110.748710
</pre></div>
</div>
<p>So, did it work? Judging from the intermediate energy values, it seems that the optimization
outcomes differ notably. But let’s take a look at the relative error in energy across the
optimization process.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">styles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;#70CEFF&quot;</span><span class="p">,</span> <span class="s2">&quot;#C756B2&quot;</span><span class="p">,</span> <span class="s2">&quot;#FFE096&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">energy</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">ls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">colors</span><span class="p">,</span> <span class="n">styles</span><span class="p">):</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="n">E_min</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">E_min</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">error</span><span class="p">))),</span> <span class="n">error</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="n">ls</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Iteration&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Relative error&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_here_comes_the_sun_002.png" srcset="../_images/sphx_glr_tutorial_here_comes_the_sun_002.png" alt="tutorial here comes the sun" class = "sphx-glr-single-img"/><p>We find that the optimization indeed performs significantly better for <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code>
than for the other two general unitaries, while using the same number of parameters and
preserving the expressibility of the circuit ansatz. This
means that we found a particularly well-trainable parameterization of the local unitaries which
allows us to reduce the energy of the prepared quantum state more easily while maintaining the
number of parameters.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>To summarize, in this tutorial we introduced <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code>, a multi-parameter
gate that can act like <em>any</em> gate on the qubits it is applied to and that is constructed
with Lie theory in mind. We discussed three methods of differentiating quantum circuits
that use this gate, showing that a new custom parameter-shift rule presented in
<a class="footnote-reference brackets" href="#wiersema" id="id10">2</a> is particularly suitable to produce unbiased gradient estimates with the
lowest variance. Afterwards, we used this differentiation technique when comparing
the performance of <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> to that of other gates that can act
like <em>any</em> gate locally. For this, we ran a gradient-based optimization for a toy model
Hamiltonian and found that <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> is particularly well-trainable, achieving
lower energies significantly quicker than the other tested gates.</p>
<p>There are still exciting questions to answer about <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code>: How can the
custom parameter-shift rule be used for other gates, and what does the so-called
<em>Dynamical Lie algebra</em> of these gates have to do with it? How can we implement
the <code class="docutils literal notranslate"><span class="pre">qml.SpecialUnitary</span></code> gate on hardware? Is the unitary time evolution implemented
by this gate special in a physical sense?</p>
<p>The answers to some, but not all, of these questions can be found in <a class="footnote-reference brackets" href="#wiersema" id="id11">2</a>.
We are certain that there are many more interesting aspects of this gate to be uncovered!
If you want to learn more, consider the other literature references below,
as well as the documentation of <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SpecialUnitary.html#pennylane.SpecialUnitary" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpecialUnitary</span></code></a>.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="vatan"><span class="brackets"><a class="fn-backref" href="#id9">1</a></span></dt>
<dd><p>Farrokh Vatan and Colin Williams,
“Optimal Quantum Circuits for General Two-Qubit Gates”,
<a class="reference external" href="https://arxiv.org/abs/quant-ph/0308006">arXiv:quant-ph/0308006</a> (2003).</p>
</dd>
<dt class="label" id="wiersema"><span class="brackets">2</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>,<a href="#id5">4</a>,<a href="#id6">5</a>,<a href="#id7">6</a>,<a href="#id8">7</a>,<a href="#id10">8</a>,<a href="#id11">9</a>)</span></dt>
<dd><p>R. Wiersema, D. Lewis, D. Wierichs, J. F. Carrasquilla, and N. Killoran.
“Here comes the SU(N): multivariate quantum gates and gradients”
<a class="reference external" href="https://arxiv.org/abs/2303.11355">arXiv:2303.11355</a> (2023).</p>
</dd>
<dt class="label" id="banchi"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Leonardo Banchi and Gavin E. Crooks. “Measuring Analytic Gradients of
General Quantum Evolution with the Stochastic Parameter Shift Rule.”
<a class="reference external" href="https://quantum-journal.org/papers/q-2021-01-25-386/">Quantum 5, 386</a> (2021).</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/david_wierichs.jpg" alt="David Wierichs" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">David Wierichs</h4>
        <p class="bio-text__author-description">David is a researcher and quantum software developer at Xanadu, who likes to think about quantum gradients and how to use them in variational quantum algorithms. He enjoys sharing ideas in science and open source software and likes implementing cool stuff in PennyLane.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 2 minutes  47.112 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-here-comes-the-sun-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/0f7e54c016909079d96d7462c240d575/tutorial_here_comes_the_sun.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_here_comes_the_sun.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/9ccfa264e6533f98abd3ac3964c3dc15/tutorial_here_comes_the_sun.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_here_comes_the_sun.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_here_comes_the_sun</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Here comes the SU(N): multivariate quantum gates and gradients</a><ul class='current'>
<li class='current'><a class="reference internal" href="#ansatze-so-many-ansatze">Ansätze, so many ansätze</a></li>
<li class='current'><a class="reference internal" href="#the-special-unitary-group-su-n-and-its-lie-algebra">The special unitary group SU(N) and its Lie algebra</a></li>
<li class='current'><a class="reference internal" href="#obtaining-the-gradient">Obtaining the gradient</a></li>
<li class='current'><a class="reference internal" href="#comparing-gradient-methods">Comparing gradient methods</a></li>
<li class='current'><a class="reference internal" href="#comparing-ansatz-structures">Comparing ansatz structures</a></li>
<li class='current'><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_here_comes_the_sun</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_optimization.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../videos.html" title="Videos"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_barren_gadgets.html" title="Perturbative Gadgets for Variational Quantum Algorithms"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" >Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Here comes the SU(N): multivariate quantum gates and gradients</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>