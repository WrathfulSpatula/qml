
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_gaussian_transformation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_gaussian_transformation.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_gaussian_transformation.py:


.. _gaussian_transformation:

Gaussian transformation
=======================

.. meta::
    :property="og:description": Use quantum machine learning techniques to tune a beamsplitter.
    :property="og:image": https://pennylane.ai/qml/_images/gauss-circuit.png

.. related:: 
   plugins_hybrid Plugins and Hybrid computation
   quantum_neural_net Function fitting with a photonic quantum neural network
   qonn Optimizing a quantum optical neural network

*Author: Josh Izaac â€” Posted: 11 October 2019. Last updated: 16 October 2020.*

This tutorial demonstrates the basic working principles of PennyLane for
continuous-variable (CV) photonic devices. For more details about photonic
quantum computing, the
`Strawberry Fields documentation <https://strawberryfields.readthedocs.io/en/latest/>`_
is a great starting point.

The quantum circuit
-------------------

For this basic tutorial, we will consider a special subset of CV operations:
the *Gaussian transformations*. We work with the following simple Gaussian circuit:

.. figure:: ../demonstrations/gaussian_transformation/gaussian_transformation.svg
    :align: center
    :width: 40%
    :target: javascript:void(0);

What is this circuit doing?

1. **We begin with one wire (qumode) in the vacuum state**. Note that we use the same
   notation :math:`|0\rangle` for the initial state as the previous qubit tutorial.
   In a photonic CV system, this state is the *vacuum state*, i.e., the state with no
   photons in the wire.

2. **We displace the qumode**. The displacement gate linearly shifts the state of the
   qumode in phase space. The vacuum state is centered at the origin in phase space,
   while the displaced state will be centered at the point :math:`\alpha`.

3. **We rotate the qumode**. This is another linear transformation in phase space,
   albeit a rotation (by angle :math:`\phi`) instead of a displacement.

4. **Finally, we measure the mean photon number** :math:`\langle\hat{n}\rangle =
   \langle\hat{a}^\dagger \hat{a}\rangle`. This quantity, which tells us the average amount of
   photons in the final state, is proportional to the energy of the photonic system.

.. GENERATED FROM PYTHON SOURCE LINES 57-68

The aim of this tutorial is to optimize the circuit parameters :math:`(\alpha, \phi)`
such that the mean photon number is equal to one. The rotation gate is actually a
*passive transformation*, meaning that it does not change the energy of the system.
The displacement gate is an *active transformation*, which modifies the energy of the
photonic system.

Constructing the QNode
----------------------

As before, we import PennyLane, as well as the wrapped version of NumPy provided
by PennyLane:

.. GENERATED FROM PYTHON SOURCE LINES 74-77

Next, we instantiate a device which will be used to evaluate the circuit.
Because our circuit contains only Gaussian operations, we can make use of the
built-in ``default.gaussian`` device.

.. GENERATED FROM PYTHON SOURCE LINES 81-85

After initializing the device, we can construct our quantum node. As before, we use the
:func:`~.pennylane.qnode` to convert our quantum function
(encoded by the circuit above) into a quantum node running on the ``default.gaussian``
device.

.. GENERATED FROM PYTHON SOURCE LINES 95-98

Notice that we have broken up the complex number :math:`\alpha` into two real
numbers ``mag_alpha`` and ``phase_alpha``, which form a polar representation of
:math:`\alpha`. This is so that the notion of a gradient is clear and well-defined.

.. GENERATED FROM PYTHON SOURCE LINES 101-108

Optimization
------------

As in the :ref:`qubit rotation <qubit_rotation>` tutorial, let's now use one
of the built-in PennyLane optimizers in order to optimize the quantum circuit
towards the desired output. We want the mean photon number to be exactly one,
so we will use a squared-difference cost function:

.. GENERATED FROM PYTHON SOURCE LINES 115-116

At the beginning of the optimization, we choose arbitrary small initial parameters:

.. GENERATED FROM PYTHON SOURCE LINES 121-125

When the gate parameters are near to zero, the gates are close to the
identity transformation, which leaves the initial state largely unchanged.
Since the initial state contains no photons, the mean photon number of the
circuit output is approximately zero, and the cost is close to one.

.. GENERATED FROM PYTHON SOURCE LINES 127-134

.. note::

    We avoided initial parameters which are exactly zero because that
    corresponds to a critical point with zero gradient.

Now, let's use the :class:`~.pennylane.GradientDescentOptimizer`, and update the circuit
parameters over 100 optimization steps.

.. GENERATED FROM PYTHON SOURCE LINES 134-153

.. code-block:: default


    # initialise the optimizer


    # set the number of steps

    # set the initial parameter values



















.. GENERATED FROM PYTHON SOURCE LINES 154-169

The optimization converges after about 20 steps to a cost function value
of zero.

We observe that the two angular parameters ``phase_alpha`` and ``phi``
do not change during the optimization. Only the magnitude of the complex
displacement :math:`|\alpha|` affects the mean photon number of the circuit.

Continue on to the next tutorial, :ref:`plugins_hybrid`, to learn how to
utilize the extensive plugin ecosystem of PennyLane,
build continuous-variable (CV) quantum nodes, and to see an example of a
hybrid qubit-CV-classical computation using PennyLane.


About the author
----------------
.. include:: ../_static/authors/josh_izaac.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.000 seconds)


.. _sphx_glr_download_demos_tutorial_gaussian_transformation.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_gaussian_transformation.py <tutorial_gaussian_transformation.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_gaussian_transformation.ipynb <tutorial_gaussian_transformation.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
