
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_pulse_programming101.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_pulse_programming101.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_pulse_programming101.py:

Differentiable pulse programming with qubits in PennyLane
=============================================================

.. meta::
    :property="og:description": Simulating differentialble pulse programs in PennyLane with qubits
    :property="og:image": https://pennylane.ai/qml/_images/thumbnail_tutorial_pulse_programming.png

.. related::
   ahs_aquila Pulse programming on neutral atom hardware

Author: Korbinian Kottmann — Posted: 8 March 2023.

Quantum computers perform gates via electromagnetic pulses on the hardware level. In differentiable pulse programming, we
can write quantum algorithms directly on the hardware level and variationally optimize the shape, phase and amplitude of the interactions
for our desired goals.
In this demo, we are going to introduce pulse programming with qubits in PennyLane and run the
ctrl-VQE algorithm [#Mitei]_ on a two-qubit Hamiltonian for the :math:`\text{HeH}^+` molecule.

|

.. figure:: ../demonstrations/pulse_programming101/pulse_illustration.png
    :align: center
    :width: 50%
    :target: javascript:void(0)

|

Pulses in quantum computers
---------------------------

In many quantum computing architectures such as `superconducting <https://pennylane.ai/qml/demos/tutorial_sc_qubits.html>`_, `ion trap <https://pennylane.ai/qml/demos/tutorial_trapped_ions.html>`_ 
and `neutral atom Rydberg <https://pennylane.ai/qml/demos/tutorial_pasqal.html>`_ systems,
qubits are realized through physical systems with a discrete set of energy levels.
For example, transmon qubits realize an anharmonic oscillator whose ground and first excited states can serve as the two energy
levels of a qubit. Such a qubit can be controlled via an electromagnetic field tuned to its energy gap. In general, this
electromagnetic field can be altered in time, leading to a time-dependent Hamiltonian :math:`H(t)` describing the effect of the field on the qubits.
We call driving the system with such an electromagnetic field for a fixed time window :math:`[t_0, t_1]` a *pulse sequence*. 
During a pulse sequence, the state evolves according to the time-dependent Schrödinger equation

.. math:: \frac{d}{dt}|\psi\rangle = -i H(t) |\psi\rangle

from an initial state :math:`|\psi(t_0)\rangle` to a final state :math:`|\psi(t_1)\rangle`. This process corresponds to a unitary evolution :math:`U(t_0, t_1)`
of the input state from time :math:`t_0` to :math:`t_1`, i.e. :math:`|\psi(t_1)\rangle = U(t_0, t_1) |\psi(t_0)\rangle`.

In most digital quantum computers (with the exception of `measurement-based <https://pennylane.ai/qml/demos/tutorial_mbqc.html>`_ architectures), the amplitude and frequencies of predefined pulse sequences are
fine tuned to realize the native gates of the quantum computer. More specifically, the Hamiltonian interaction :math:`H(t)`
is tuned such that the respective evolution :math:`U(t_0, t_1)` realizes for example a Pauli or CNOT gate (see e.g. *cross-resonance* gates for superconducting qubits in [#Sheldon2016]_).

Pulse programming in PennyLane
------------------------------

A user of a quantum computer typically operates on the higher and more abstract gate level.
Future fault-tolerant quantum computers require this abstraction to allow for error correction.
For noisy and intermediate-sized quantum computers, the abstraction of decomposing quantum algorithms
into a fixed native gate set can be a hindrance and unnecessarily increase execution time, therefore leading
to more noise in the computation. The idea of differentiable pulse programming is to optimize quantum circuits on the pulse
level instead, with the aim of achieving the shortest interaction sequence a hardware system allows.

In PennyLane, we can simulate arbitrary qubit system interactions to explore the possibilities of such pulse programs.
First, we need to define the time-dependent Hamiltonian :math:`H(p, t)= \sum_i f_i(p_i, t) H_i` with constant operators :math:`H_i` and control fields :math:`f_i(p_i, t)`.
The Hamiltonian depends on the set of parameters :math:`p = \{p_i\}`. One way to do this in PennyLane is in the following way:

.. GENERATED FROM PYTHON SOURCE LINES 63-84

.. code-block:: default








    # Set to float64 precision and remove jax CPU/GPU warning




















.. GENERATED FROM PYTHON SOURCE LINES 85-89

This constructs a :class:`~pennylane.pulse.ParametrizedHamiltonian`. Note that the ``callable`` functions ``f1`` and ``f2``
are expected to have the fixed signature ``(p, t)``. When calling the :class:`~pennylane.pulse.ParametrizedHamiltonian`, 
a ``tuple`` or ``list`` of the parameters for each of the functions is passed in the same
order the Hamiltonian was constructed.

.. GENERATED FROM PYTHON SOURCE LINES 96-100

We can construct general Hamiltonians of the form :math:`\sum_i H_i^d + \sum_i f_i(p_i, t) H_i`
using :func:`qml.dot <pennylane.dot>`. Such a time-dependent Hamiltonian consists of time-independent drift terms :math:`H_i^d`
and time-dependent control terms :math:`f_i(p_i, t) H_i` with scalar complex-valued functions :math:`f_i(p, t).` 
In the following we are going to construct :math:`\sum_i X_i X_{i+1} + \sum_i f_i(p_i, t) Z_i` with :math:`f_i(p_i, t) = \sin(p_i^0 t) + \sin(p_i^1 t) \forall i` as an example:

.. GENERATED FROM PYTHON SOURCE LINES 100-114

.. code-block:: default









    # random coefficients












.. GENERATED FROM PYTHON SOURCE LINES 115-117

We can visualize the Hamiltonian interaction by plotting the time-dependent envelopes. We refer to the drift term as all constant terms in time, i.e. :math:`\sum_i X_i X_{i+1}`,
and plot the envelopes :math:`f_i(p_i, t)` of the time-dependent terms :math:`f_i(p_i, t) Z_i`.

.. GENERATED FROM PYTHON SOURCE LINES 133-136

A pulse program is then executed by using the :func:`~.pennylane.evolve` transform to create the evolution
gate :math:`U(t_0, t_1)`, which implicitly depends on the parameters ``p``. The objective of the program
is then to compute the expectation value of some objective Hamiltonian ``H_obj`` (here :math:`\sum_i Z_i` as a simple example).

.. GENERATED FROM PYTHON SOURCE LINES 154-167

We used the decorator ``jax.jit`` to compile this execution just-in-time. This means the first execution will typically take a little longer with the
benefit that all following executions will be significantly faster, see the `jax docs on jitting <https://jax.readthedocs.io/en/latest/jax-101/02-jitting.html>`_.
Note that when removing the ``jax.jit`` decorator, the numerical solver `odeint <https://github.com/google/jax/blob/main/jax/experimental/ode.py>`_ for the time evolution
inside :func:`~.pennylane.evolve` is still jit-compiled by default.

Researchers interested in more specific hardware systems can simulate them using the specific Hamiltonian interactions.
For example, we will simulate a transmon qubit system in the ctrl-VQE example in the last section of this demo.

Gradients of pulse programs
---------------------------
Internally, pulse programs in PennyLane solve the time-dependent Schrödinger equation using the `Dopri5 <https://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method>`_ solver for
ordinary differential equations (ODEs). In particular, the step sizes between :math:`t_0` and :math:`t_1` are chosen adaptively to stay within a given error tolerance.
We can backpropagate through this ODE solver and obtain the gradient via ``jax.grad``.

.. GENERATED FROM PYTHON SOURCE LINES 171-173

Alternatively, one could consider computing the gradient with the parameter shift rule [#Leng2022]_, which is particularly interesting for
real hardware execution. In classical simulations, however, backpropagation is recommended.

.. GENERATED FROM PYTHON SOURCE LINES 176-181

Piecewise-constant parametrizations
------------------------------------
PennyLane also provides a variety of convenience functions to create, for example, piece-wise-constant parametrizations
defining the function values at fixed time bins as parameters. We can construct such a callable with :func:`~pennylane.pulse.pwc`
by providing a ``timespan`` argument which is expected to be either a total time (``float``) or a start and end time (``tuple``).

.. GENERATED FROM PYTHON SOURCE LINES 186-191

This creates a callable with signature ``(p, t)`` that returns ``p[int(len(p)*t/duration)]``, such that the passed parameters are the function values
for different time bins.
Note how the number of time bins is implicitly defined through the length of the parameters. In the following example, we are going to use
``4`` and ``10`` time bins defined through the length of parameters, respectively. Let us create uniformly random parameters between 0 and 5 and plot
the corresponding piece-wise-constant function sampled at ``100`` different points in time.

.. GENERATED FROM PYTHON SOURCE LINES 208-209

We can use these callables as before to construct a :func:`~.pennylane.pulse.ParametrizedHamiltonian`.

.. GENERATED FROM PYTHON SOURCE LINES 215-224

Note that this construction is equivalent to using :func:`qml.dot <pennylane.dot>`.

Variational quantum eigensolver with pulse programming
------------------------------------------------------
We can now use the ability to access gradients to perform the variational quantum eigensolver on the pulse level (ctrl-VQE) as is done in [#Mitei]_.
For a more general introduction to VQE, see :doc:`tutorial_vqe`.
First, we define the molecular Hamiltonian whose energy expectation value we want to minimize. This serves as our objective Hamiltonian.
We are using :math:`\text{HeH}^+` as a simple example and load it from the `PennyLane quantum datasets <https://pennylane.ai/qml/datasets.html>`_ website.
We are going to use the tapered Hamiltonian, which makes use of symmetries to reduce the number of qubits, see :doc:`tutorial_qubit_tapering` for details.

.. GENERATED FROM PYTHON SOURCE LINES 224-233

.. code-block:: default





    # casting the Hamiltonian coefficients to a jax Array











.. GENERATED FROM PYTHON SOURCE LINES 234-242

As a realistic physical system with pulse level control, we are considering a coupled transmon qubit system with the constant drift term Hamiltonian

.. math:: H_D = \sum_q \omega_q a_q^\dagger a_q - \sum_q \frac{\delta_q}{2} a^\dagger_q a^\dagger_q a_q a_q + \sum_{\langle pq \rangle} g_{pq} a^\dagger_p a_q

with bosonic creation and annihilation operators. The anharmonicity :math:`\delta_q` is describing the contribution to higher energy levels.
We are only going to consider the qubit subspace and hence set this term to zero.
The order of magnitude of the resonance frequencies :math:`\omega_q` and coupling strength :math:`g_{pq}` are taken from [#Mitei]_ (in GHz).
Let us construct the Hamiltonian in PennyLane:

.. GENERATED FROM PYTHON SOURCE LINES 258-272

The system is driven under the control term

.. math:: H_C(t) = \sum_q \Omega_q(t) \left(e^{i\nu_q t} a_q + e^{-i\nu_q t} a^\dagger_q \right)

with the (real) time-dependent amplitudes :math:`\Omega_q(t)` and frequencies :math:`\nu_q` of the drive.
We let :math:`\Omega(t)` be a real piecewise-constant function whose values are optimized.
In a transmon qubit systems, entangling gates such as ``CNOT`` are realized by driving a target qubit with the resonance frequency of the control qubit.
This is referred to as cross resonance and is described in [#Sheldon2016]_.
Here, we allow for more general two-qubit interactions by training the drive frequency :math:`\nu_q` on each qubit.

For this drive, there are certain restrictions by the hardware that we want to already account for to make our simulation as realistic as possible.
We therefore restrict the amplitude to :math:`\pm 20 \text{MHz}` and the frequency deviation :math:`\Delta \nu_q = \omega_q - \nu_q` to :math:`\pm 1 \text{GHz}`
(as is done in [#Mitei]_). We achieve this by normalizing the respective quantities with a shifted sigmoid :math:`\mathcal{N}(x) = \frac{1 - e^{-x}}{1 + e^{-x}}`,
which ensures differentiability.

.. GENERATED FROM PYTHON SOURCE LINES 272-304

.. code-block:: default






    # Because ParametrizedHamiltonian expects each callable function to have the signature
    # f(p, t) but we have additional parameters it depends on, we create a wrapper function
    # that constructs the callables with the appropriate parameters imprinted on them































.. GENERATED FROM PYTHON SOURCE LINES 305-309

Overall, we end up with the time-dependent parametrized Hamiltonian :math:`H(p, t) = H_D + H_C(p, t)`
under which the system is evolved for the given time window of ``15ns``. Note that we are expressing time
in nanoseconds (:math:`10^{-9}` s) and frequencies (and energies) in gigahertz (:math:`10^{9}` Hz), such that both
exponents cancel.

.. GENERATED FROM PYTHON SOURCE LINES 313-314

Now we define the ``qnode`` that computes the expectation value of the molecular Hamiltonian.

.. GENERATED FROM PYTHON SOURCE LINES 326-342

We now have all the ingredients to run our ctrl-VQE program. We use the ``adam`` implementation in `optax <https://optax.readthedocs.io/en/latest/>`_,
a package for optimizations in ``jax``.

It has been shown that the loss landscapes of pulse programs are trap-free for a variety of conditions and loss functions, including ours [#Russell2016]_.
In practice however, we see that the optimization is senstive to the initial values of the parameters and the optimization strategy.
In particular, we often find ourselves with very slow progress during optimization, indicating wide flat regions in the loss landscape.
This can be salvaged by increasing the learning rate. Sometimes, it proved advantageous to increase the learning rate after an 
initial finer search for a better starting point. Further, we note that with the increase in the number of parameters due to the continuous evolution,
the optimization becomes harder.

Whether or not that is due to the increased parameter search space or an inherent effect of pulse programs like barren plateaus in variational quantum circuits
is to be determined in future work.

We systematically tried a variety of combinations of learning rate schedule, optimizer, and initial values. Here, we provide one possible choice leading to good results.

We choose ``t_bins = 100`` segments for the piece-wise-constant parametrization of the pulses.

.. GENERATED FROM PYTHON SOURCE LINES 342-384

.. code-block:: default












    # The following block creates a constant schedule of the learning rate
    # that increases from 0.1 to 0.5 after 10 epochs










    ## Compile the evaluation and gradient function and report compilation time





    ## Optimization loop



















.. GENERATED FROM PYTHON SOURCE LINES 385-386

We see that we have converged to chemical accuracy after half the number of epochs.

.. GENERATED FROM PYTHON SOURCE LINES 401-405

We can also visualize the envelopes for each qubit in time.
We only plot the real amplitude :math:`\Omega(t)` and indicate the deviation 
:math:`\Delta \nu_q = \omega_q - \nu_q` of the drive frequency :math:`\nu_q` from the qubit frequency :math:`\omega_q`
in the labels.

.. GENERATED FROM PYTHON SOURCE LINES 422-471

Note that we obtain bang-bang like solutions as indicated in [#Asthana2022]_, making it
likely we are close to the minimal evolution time with ``15ns``.

Conclusion
----------
Pulse programming is an exciting new field within noisy quantum computing. By skipping the digital abstraction, one can
write variational programs on the hardware level, potentially minimizing the computation time. Ideally, this allows for effectively deeper
circuits on noisy hardware.
On the other hand, the possibility to continuously vary the Hamiltonian interaction in time significantly increases
the parameter space. A good parametrization trading off flexibility and the number of parameters is therefore necessary as systems scale up.
Further, the increased flexibility also affects the search space in Hilbert space that pulse gates can reach.
Barren plateaus in variational quantum algorithms are typically due to a lack of a good inductive bias in the ansatz, i.e. having a search space that is too large.
It is therefore crucial to find physically motivated ansätze for pulse programs.

References
----------

.. [#Mitei]

    Oinam Romesh Meitei, Bryan T. Gard, George S. Barron, David P. Pappas, Sophia E. Economou, Edwin Barnes, Nicholas J. Mayhall
    "Gate-free state preparation for fast variational quantum eigensolver simulations: ctrl-VQE"
    `arXiv:2008.04302 <https://arxiv.org/abs/2008.04302>`__, 2020

.. [#Sheldon2016]

    Sarah Sheldon, Easwar Magesan, Jerry M. Chow, Jay M. Gambetta
    "Procedure for systematically tuning up crosstalk in the cross resonance gate"
    `arXiv:1603.04821 <https://arxiv.org/abs/1603.04821>`__, 2016.

.. [#Leng2022]

    Jiaqi Leng, Yuxiang Peng, Yi-Ling Qiao, Ming Lin, Xiaodi Wu
    "Differentiable Analog Quantum Computing for Optimization and Control"
    `arXiv:2210.15812 <https://arxiv.org/abs/2210.15812>`__, 2022

.. [#Asthana2022]

    Ayush Asthana, Chenxu Liu, Oinam Romesh Meitei, Sophia E. Economou, Edwin Barnes, Nicholas J. Mayhall
    "Minimizing state preparation times in pulse-level variational molecular simulations"
    `arXiv:2203.06818 <https://arxiv.org/abs/2203.06818>`__, 2022.

.. [#Russell2016]

    Benjamin Russell, Herschel Rabitz, Rebing Wu
    "Quantum Control Landscapes Are Almost Always Trap Free"
    `arXiv:1608.06198 <https://arxiv.org/abs/1608.06198>`__, 2016.




.. GENERATED FROM PYTHON SOURCE LINES 473-476

About the author
----------------
.. include:: ../_static/authors/korbinian_kottmann.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.001 seconds)


.. _sphx_glr_download_demos_tutorial_pulse_programming101.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_pulse_programming101.py <tutorial_pulse_programming101.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_pulse_programming101.ipynb <tutorial_pulse_programming101.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
