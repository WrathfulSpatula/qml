
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_vqt.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_vqt.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_vqt.py:


Variational Quantum Thermalizer
===================================

.. meta::
    :property="og:description": Using the Variational Quantum Thermalizer to prepare the thermal state of a Heisenberg model Hamiltonian.
    :property="og:image": https://pennylane.ai/qml/_images/thumbnail_vqt.png

.. related::

    tutorial_vqe Variational quantum eigensolver

*Author: Jack Ceroni — Posted: 7 July 2020. Last updated: 28 January 2021.*

This demonstration discusses theory and experiments relating to a recently proposed quantum algorithm called the
`Variational Quantum Thermalizer <https://arxiv.org/abs/1910.02071>`__ (VQT): a generalization of the well-know
:doc:`Variational Quantum Eigensolver </demos/tutorial_vqe>` (VQE) to systems with non-zero temperatures.

.. GENERATED FROM PYTHON SOURCE LINES 22-25

The Idea
--------


.. GENERATED FROM PYTHON SOURCE LINES 28-96

The goal of the VQT is to prepare
the `thermal state <https://en.wikipedia.org/wiki/KMS_state>`__
of a given Hamiltonian :math:`\hat{H}` at temperature :math:`T`,
which is defined as

.. math:: \rho_\text{thermal} \ = \ \frac{e^{- \hat{H} \beta}}{\text{Tr}(e^{- \hat{H} \beta})} \ = \ \frac{e^{- \hat{H} \beta}}{Z_{\beta}},

where :math:`\beta \ = \ 1/T`. The thermal state is a `mixed state
<https://en.wikipedia.org/wiki/Quantum_state#Mixed_states>`__,
which means that can be described by an ensemble of pure states.
Since we are attempting to learn a mixed state, we must
deviate from the standard variational method of passing a pure state
through an ansatz circuit, and minimizing the energy expectation.

The VQT begins with an initial `density matrix
<https://en.wikipedia.org/wiki/Density_matrix>`__, :math:`\rho_{\theta}`,
described by a probability distribution parametrized by some collection
of parameters :math:`\theta`, and an ensemble of pure states,
:math:`\{|\psi_i\rangle\}`. Let :math:`p_i(\theta_i)` be the
probability corresponding to the :math:`i`-th pure state. We sample from
this probability distribution to get some pure state
:math:`|\psi_k\rangle`, which we pass through a parametrized circuit,
:math:`U(\phi)`. From the results of this circuit, we then calculate
:math:`\langle \psi_k | U^{\dagger}(\phi) \hat{H}\, U(\phi) |\psi_k\rangle`.
Repeating this process multiple times and taking the average of these
expectation values gives us the the expectation value of :math:`\hat{H}`
with respect to :math:`U \rho_{\theta} U^{\dagger}`.

.. figure:: ../demonstrations/vqt/ev.png
    :width: 100%
    :align: center

    Inputted parameters create an initial density matrix and a parametrized
    ansatz, which are used to calculate the expectation value of the Hamiltonian
    with respect to a new mixed state.

Arguably, the most important part of a variational circuit is its cost
function, which we attempt to minimize with a classical optimizer.
In VQE, we generally try to
minimize :math:`\langle \psi(\theta) | \hat{H} | \psi(\theta) \rangle`
which, upon minimization, gives us a parametrized circuit that prepares
a good approximation to the ground state of :math:`\hat{H}`. In the VQT,
the goal is to arrive at a parametrized probability distribution, and a
parametrized ansatz, that generate a good approximation to the thermal
state. This generally involves more than calculating the energy
expectation value. Luckily, we know that the thermal state of
:math:`\hat{H}` minimizes the following free-energy cost function

.. math:: \mathcal{L}(\theta, \ \phi) \ = \ \beta \ \text{Tr}( \hat{H} \ \hat{U}(\phi) \rho_{\theta} \hat{U}(\phi)^{\dagger} ) \ - \ S_\theta,

where :math:`S_{\theta}` is the `von Neumann entropy
<https://en.wikipedia.org/wiki/Von_Neumann_entropy>`__ of
:math:`U \rho_{\theta} U^{\dagger}`, which is the same as the von
Neumann entropy of :math:`\rho_{\theta}` due to invariance of entropy
under unitary transformations. This cost function is minimized when
:math:`\hat{U}(\phi) \rho_{\theta} \hat{U}(\phi)^{\dagger} \ = \ \rho_{\text{thermal}}`,
so similarly to VQE, we minimize it with a classical optimizer to obtain
the target parameters, and thus the target state.

.. figure:: ../demonstrations/vqt/vqt.png
    :width: 80%
    :align: center

    A high-level representation of how the VQT works.

All together, the outlined processes give us a general protocol to
generate thermal states.


.. GENERATED FROM PYTHON SOURCE LINES 99-102

Simulating the VQT for a 4-Qubit Heisenberg Model
--------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 105-108

In this demonstration, we simulate the 4-qubit Heisenberg model. We can
begin by importing the necessary dependencies.


.. GENERATED FROM PYTHON SOURCE LINES 122-132

The Heisenberg Hamiltonian is defined as

.. math:: \hat{H} \ = \ \displaystyle\sum_{(i, j) \in E} X_i X_j \ + \ Z_i Z_j \ + \ Y_i Y_j,

where :math:`X_i`, :math:`Y_i` and :math:`Z_i` are the Pauli gates
acting on the :math:`i`-th qubit. In addition, :math:`E` is the set of
edges in the graph :math:`G \ = \ (V, \ E)` describing the interactions
between the qubits. In this demonstration, we define the interaction graph to
be the cycle graph:


.. GENERATED FROM PYTHON SOURCE LINES 139-142

With this, we can calculate the matrix representation of the Heisenberg
Hamiltonian in the computational basis:


.. GENERATED FROM PYTHON SOURCE LINES 142-172

.. code-block:: default


























    # Prints a visual representation of the Hamiltonian matrix











.. GENERATED FROM PYTHON SOURCE LINES 173-176

With this done, we construct the VQT. We begin by defining some
fixed variables that are used throughout the simulation:


.. GENERATED FROM PYTHON SOURCE LINES 183-200

The first step of the VQT is to create the initial density matrix,
:math:`\rho_\theta`. In this demonstration, we let :math:`\rho_\theta` be
*factorized*, meaning that it can be written as an uncorrelated tensor
product of :math:`4` one-qubit density matrices that are diagonal in
the computational basis. The motivation is that in this factorized model,
the number of :math:`\theta_i` parameters needed to describe
:math:`\rho_\theta` scales linearly rather than exponentially with
the number of qubits. For each one-qubit system described by
:math:`\rho_\theta^i`, we have

.. math:: \rho_{\theta}^{i} \ = \ p_i(\theta_i) |0\rangle \langle 0| \ + \ (1 \ - \ p_i(\theta_i))|1\rangle \langle1|.

From here, all we have to do is define :math:`p_i(\theta_i)`, which we
choose to be the sigmoid

.. math:: p_{i}(\theta_{i}) \ = \ \frac{e^{\theta_i}}{e^{\theta_i} \ + \ 1}.


.. GENERATED FROM PYTHON SOURCE LINES 207-214

This is a natural choice for probability function, as it has a range of
:math:`[0, \ 1]`, meaning that we don’t need to restrict the domain of
:math:`\theta_i` to some subset of the real numbers. With the probability
function defined, we can write a method that gives us the diagonal
elements of each one-qubit density matrix, for some parameters
:math:`\theta`:


.. GENERATED FROM PYTHON SOURCE LINES 221-224

Creating the Ansatz Circuit
^^^^^^^^^^^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 227-235

With this done, we can move on to defining the ansatz circuit,
:math:`U(\phi)`, composed of rotational and coupling layers. The
rotation layer is simply ``RX``, ``RY``, and ``RZ``
gates applied to each qubit. We make use of the
``AngleEmbedding``
function, which allows us to easily pass parameters into rotational
layers.


.. GENERATED FROM PYTHON SOURCE LINES 245-251

To construct the general ansatz, we combine the method we have just
defined with a collection of parametrized coupling gates placed between
qubits that share an edge in the interaction graph. In addition, we
define the depth of the ansatz, and the device on which the simulations
are run:


.. GENERATED FROM PYTHON SOURCE LINES 251-280

.. code-block:: default


























    # Constructs the QNode










.. GENERATED FROM PYTHON SOURCE LINES 281-284

We can get an idea of what this circuit looks like by printing out a
test circuit:


.. GENERATED FROM PYTHON SOURCE LINES 292-300

Recall that the final cost function depends not only on the expectation
value of the Hamiltonian, but also the von Neumann entropy of the state,
which is determined by the collection of :math:`p_i(\theta_i)`\ s. Since
the entropy of a collection of multiple uncorrelated subsystems is the
same as the sum of the individual values of entropy for each subsystem,
we can sum the entropy values of each one-qubit system in the factorized
space to get the total:


.. GENERATED FROM PYTHON SOURCE LINES 314-317

The Cost Function
^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 320-342

Finally, we combine the ansatz and the entropy function to get the cost
function. In this demonstration, we deviate slightly from how VQT would be
performed in practice. Instead of sampling from the probability
distribution describing the initial mixed state, we use the ansatz to
calculate
:math:`\langle x_i | U^{\dagger}(\phi) \hat{H} \,U(\phi) |x_i\rangle` for
each basis state :math:`|x_i\rangle`. We then multiply each of these
expectation values by their corresponding :math:`(\rho_\theta)_{ii}`,
which is exactly the probability of sampling :math:`|x_i\rangle` from
the distribution. Summing each of these terms together gives us the
expected value of the Hamiltonian with respect to the transformed
density matrix.

In the case of this small, simple model, exact
calculations such as this reduce the number of circuit executions, and thus the total
execution time.

You may have noticed previously that the “structure” of the
parameters list passed into the ansatz is quite complicated. We write a
general function that takes a one-dimensional list, and converts it into
the nested list structure that can be inputed into the ansatz:


.. GENERATED FROM PYTHON SOURCE LINES 365-368

We then pass this function, along with the ansatz and the entropy
function into the final cost function:


.. GENERATED FROM PYTHON SOURCE LINES 403-405

We then create the function that is passed into the optimizer:


.. GENERATED FROM PYTHON SOURCE LINES 421-428

The last step is to define the optimizer, and execute the optimization
method. We use the "Constrained Optimization by Linear Approximation"
(`COBYLA <https://en.wikipedia.org/wiki/COBYLA>`__) optimization method,
which is a gradient-free optimizer. We observe that for this algorithm, COBYLA
has a lower runtime than its gradient-based counterparts, so we utilize it
in this demonstration:


.. GENERATED FROM PYTHON SOURCE LINES 439-444

We can now check to see how well our optimization method performed by
writing a function that reconstructs the transformed density
matrix of some initial state, with respect to lists of
:math:`\theta` and :math:`\phi` parameters:


.. GENERATED FROM PYTHON SOURCE LINES 444-478

.. code-block:: default































    # Prepares the density matrix










.. GENERATED FROM PYTHON SOURCE LINES 479-482

We then display the prepared state by plotting a heatmap of the
entry-wise absolute value of the density matrix:


.. GENERATED FROM PYTHON SOURCE LINES 488-491

Numerical Calculations
^^^^^^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 494-498

To verify that we have in fact prepared a good approximation of the
thermal state, let’s calculate it numerically by taking the matrix
exponential of the Heisenberg Hamiltonian, as was outlined earlier.


.. GENERATED FROM PYTHON SOURCE LINES 522-524

Finally, we can plot a heatmap of the target density matrix:


.. GENERATED FROM PYTHON SOURCE LINES 531-541

The two images look very similar, which suggests that we have
constructed a good approximation of the thermal state! Alternatively, if
you prefer a more quantitative measure of similarity, we can calculate
the trace distance between the two density matrices, which is defined
as

.. math:: T(\rho, \ \sigma) \ = \ \frac{1}{2} \text{Tr} \sqrt{(\rho \ - \ \sigma)^{\dagger} (\rho \ - \ \sigma)},

and is a metric on the space of density matrices:


.. GENERATED FROM PYTHON SOURCE LINES 552-556

The closer to zero, the more similar the two states are. Thus, we
have found a close approximation of the thermal state
of :math:`H` with the VQT!


.. GENERATED FROM PYTHON SOURCE LINES 559-571

References
----------

1. Verdon, G., Marks, J., Nanda, S., Leichenauer, S., & Hidary, J.
   (2019). Quantum Hamiltonian-Based Models and the Variational Quantum
   Thermalizer Algorithm. arXiv preprint
   `arXiv:1910.02071 <https://arxiv.org/abs/1910.02071>`__.


About the author
----------------
.. include:: ../_static/authors/jack_ceroni.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.001 seconds)


.. _sphx_glr_download_demos_tutorial_vqt.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_vqt.py <tutorial_vqt.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_vqt.ipynb <tutorial_vqt.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
