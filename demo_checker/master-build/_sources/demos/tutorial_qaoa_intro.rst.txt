
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_qaoa_intro.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_qaoa_intro.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_qaoa_intro.py:


Intro to QAOA
=============

.. meta::
    :property="og:description": Learn how to implement QAOA with PennyLane
    :property="og:image": https://pennylane.ai/qml/_images/qaoa_layer.png

.. related::

   tutorial_qaoa_maxcut QAOA for MaxCut

*Author: Jack Ceroni ‚Äî Posted: 18 November 2020. Last updated: 11 January 2021.*

The Quantum Approximate Optimization Algorithm (QAOA) is a widely-studied
method for solving combinatorial optimization problems on NISQ devices.
The applications of QAOA are broad and far-reaching, and the performance
of the algorithm is of great interest to the quantum computing research community.

.. figure:: ../demonstrations/qaoa_module/qaoa_circuit.png
    :align: center
    :width: 90%

The goal of this tutorial is to introduce the basic concepts of QAOA and
to guide you through PennyLane's built-in QAOA
functionality. You will learn how to use time evolution to establish a
connection between Hamiltonians and quantum circuits, and how to layer
these circuits to create more powerful algorithms. These simple ingredients,
together with the ability to optimize quantum circuits, are the building blocks of QAOA. By focusing
on the fundamentals, PennyLane provides general and flexible capabilities that can be tailored and
refined to implement QAOA for a wide variety of problems. In the last part of the tutorial, you will
learn how to bring these pieces together and deploy a complete QAOA workflow to solve the
minimum vertex cover problem. Let's get started! üéâ

Circuits and Hamiltonians
-------------------------

When considering quantum circuits, it is often convenient to define them by a
series of quantum gates. But there are many instances where
it is useful to think of a quantum circuit in terms of a
`Hamiltonian <https://en.wikipedia.org/wiki/Hamiltonian_(quantum_mechanics)>`__.
Indeed, gates are physically implemented by performing time evolution under a carefully engineered
Hamiltonian. These transformations are described by the time evolution operator,
which is a unitary defined as:

.. GENERATED FROM PYTHON SOURCE LINES 47-81

.. math:: U(H, \ t) \ = \ e^{-i H t / \hbar}.

The time evolution operator is determined completely in terms of a Hamiltonian
:math:`H` and a scalar :math:`t` representing time. In fact, any unitary
:math:`U` can be written in the form :math:`e^{i \gamma H}`, where :math:`\gamma` is a scalar
and :math:`H` is a Hermitian operator,
interpreted as a Hamiltonian. Thus, time evolution establishes a connection that allows us to
describe quantum circuits in terms of Hamiltonians. ü§Ø

In general, implementing a quantum circuit that exactly exponentiates a Hamiltonian
with many non-commuting terms, i.e., a Hamiltonian of the form:

.. math:: H \ = \ H_1 \ + \ H_2 \ + \ H_3 \ + \ \cdots \ + \ H_N,

is very challenging. Instead, we can use the
`Trotter-Suzuki <https://en.wikipedia.org/wiki/Lie_product_formula>`__ decomposition formula

.. math:: e^{A \ + \ B} \ \approx \ \Big(e^{A/n} e^{B/n}\Big)^{n},

to implement an *approximate* time-evolution unitary:

.. math:: U(H, t, n) \ = \ \displaystyle\prod_{j \ = \ 1}^{n}
          \displaystyle\prod_{k} e^{-i H_k t / n} \ \ \ \ \ \ \ \ \ \ H \
          = \ \displaystyle\sum_{k} H_k,

where :math:`U` approaches :math:`e^{-i H t}` as :math:`n`
becomes larger.

.. figure:: ../demonstrations/qaoa_module/ham_circuit.png
    :align: center
    :width: 70%

In PennyLane, this is implemented using the :func:`~.pennylane.templates.ApproxTimeEvolution` template.
For example, let's say we have the following Hamiltonian:

.. GENERATED FROM PYTHON SOURCE LINES 81-91

.. code-block:: default


    import pennylane as qml

    H = qml.Hamiltonian(
        [1, 1, 0.5],
        [qml.PauliX(0), qml.PauliZ(1), qml.PauliX(0) @ qml.PauliX(1)]
    )
    print(H)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      (1) [X0]
    + (1) [Z1]
    + (0.5) [X0 X1]




.. GENERATED FROM PYTHON SOURCE LINES 92-94

We can implement the approximate time-evolution operator corresponding to this
Hamiltonian:

.. GENERATED FROM PYTHON SOURCE LINES 95-108

.. code-block:: default


    dev = qml.device('default.qubit', wires=2)

    t = 1
    n = 2

    @qml.qnode(dev)
    def circuit():
        qml.ApproxTimeEvolution(H, t, n)
        return [qml.expval(qml.PauliZ(i)) for i in range(2)]

    print(qml.draw(circuit, expansion_strategy='device')())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0: ‚îÄ‚îÄRX(1.00)‚îÄ‚ï≠RXX(0.50)‚îÄ‚îÄRX(1.00)‚îÄ‚ï≠RXX(0.50)‚îÄ‚î§  <Z>
    1: ‚îÄ‚îÄRZ(1.00)‚îÄ‚ï∞RXX(0.50)‚îÄ‚îÄRZ(1.00)‚îÄ‚ï∞RXX(0.50)‚îÄ‚î§  <Z>




.. GENERATED FROM PYTHON SOURCE LINES 109-140

Layering circuits
-----------------

Think of all the times you have copied a text or image, then pasted it repeatedly to create
many duplicates. This is also a useful feature when designing quantum algorithms!
The idea of repetition is ubiquitous in quantum computing:
from amplitude amplification in `Grover‚Äôs algorithm
<https://en.wikipedia.org/wiki/Grover%27s_algorithm>`__
to layers in `quantum neural networks
<https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.1.033063>`__
and `Hamiltonian simulation
<https://en.wikipedia.org/wiki/Hamiltonian_simulation>`__, repeated application
of a circuit is a central tool in quantum algorithms.


.. figure:: ../demonstrations/qaoa_module/repeat.png
    :align: center
    :width: 100%


Circuit repetition is implemented in PennyLane using the :func:`~.pennylane.layer` function. This method
allows us to take a function containing either quantum operations, a template, or even a single
quantum gate, and repeatedly apply it to a set of wires.

.. figure:: ../demonstrations/qaoa_module/qml_layer.png
    :align: center
    :width: 90%

To create a larger circuit consisting of many repetitions, we pass the circuit to be
repeated as an argument and specify the number of repetitions. For example, let's
say that we want to layer the following circuit three times:

.. GENERATED FROM PYTHON SOURCE LINES 140-153

.. code-block:: default


    def circ(theta):
        qml.RX(theta, wires=0)
        qml.Hadamard(wires=1)
        qml.CNOT(wires=[0, 1])

    @qml.qnode(dev)
    def circuit(param):
        circ(param)
        return [qml.expval(qml.PauliZ(i)) for i in range(2)]

    print(qml.draw(circuit)(0.5))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0: ‚îÄ‚îÄRX(0.50)‚îÄ‚ï≠‚óè‚îÄ‚î§  <Z>
    1: ‚îÄ‚îÄH‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï∞X‚îÄ‚î§  <Z>




.. GENERATED FROM PYTHON SOURCE LINES 154-156

We simply pass this function into the :func:`~.pennylane.layer` function:


.. GENERATED FROM PYTHON SOURCE LINES 157-165

.. code-block:: default


    @qml.qnode(dev)
    def circuit(params, **kwargs):
        qml.layer(circ, 3, params)
        return [qml.expval(qml.PauliZ(i)) for i in range(2)]

    print(qml.draw(circuit)([0.3, 0.4, 0.5]))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0: ‚îÄ‚îÄRX(0.30)‚îÄ‚ï≠‚óè‚îÄ‚îÄRX(0.40)‚îÄ‚ï≠‚óè‚îÄ‚îÄRX(0.50)‚îÄ‚ï≠‚óè‚îÄ‚î§  <Z>
    1: ‚îÄ‚îÄH‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï∞X‚îÄ‚îÄH‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï∞X‚îÄ‚îÄH‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï∞X‚îÄ‚î§  <Z>




.. GENERATED FROM PYTHON SOURCE LINES 166-170

We have learned how time evolution can be used to create circuits from Hamiltonians,
and how these can be layered to create longer circuits. We are now ready to
explore QAOA.


.. GENERATED FROM PYTHON SOURCE LINES 174-208

QAOA
----

The quantum approximate optimization algorithm (QAOA) is a general technique that can be used
to find approximate solutions to combinatorial optimization problems, in particular problems
that can be cast as searching for an optimal bitstring. QAOA consists of the following
steps:

1. Define a *cost Hamiltonian* :math:`H_C` such that its ground state
   encodes the solution to the optimization problem.

2. Define a *mixer Hamiltonian* :math:`H_M`.

3. Construct the circuits :math:`e^{-i \gamma H_C}` and :math:`e^{-i\alpha H_M}`. We call
   these the *cost* and *mixer layers*, respectively.

4. Choose a parameter :math:`n\geq 1` and build the circuit

   .. math:: U(\boldsymbol\gamma, \ \boldsymbol\alpha) \ = \ e^{-i \alpha_n H_M}
             e^{-i \gamma_n H_C} \ ... \ e^{-i \alpha_1 H_M} e^{-i \gamma_1 H_C},

   consisting of repeated application of the cost and mixer layers.

5. Prepare an initial state, apply :math:`U(\boldsymbol\gamma,\boldsymbol\alpha)`,
   and use classical techniques to optimize the parameters.

6. After the circuit has been optimized, measurements of the output state reveal
   approximate solutions to the optimization problem.

In summary, the starting point of QAOA is the specification of cost and mixer Hamiltonians.
We then use time evolution and layering to create a variational circuit and optimize its
parameters. The algorithm concludes by sampling from the circuit to get an approximate solution to
the optimization problem. Let's see it in action! üöÄ


.. GENERATED FROM PYTHON SOURCE LINES 210-231

Minimum Vertex Cover with QAOA
------------------------------

Our goal is to find the `minimum vertex
cover <https://en.wikipedia.org/wiki/Vertex_cover>`__ of a graph:
a collection of vertices such that
each edge in the graph contains at least one of the vertices in the cover. Hence,
these vertices "cover" all the edges üëç.
We wish to find the vertex cover that has the
smallest possible number of vertices.

Vertex covers can be represented by a bit string
where each bit denotes whether the corresponding vertex is present in the cover. For example,
the bit string 01010 represents a cover consisting of the second and fourth vertex in a graph with five vertices.

.. figure:: ../demonstrations/qaoa_module/minvc.png
    :align: center
    :width: 90%

To implement QAOA with PennyLane, we first import the necessary dependencies:


.. GENERATED FROM PYTHON SOURCE LINES 231-238

.. code-block:: default


    from pennylane import qaoa
    from pennylane import numpy as np
    from matplotlib import pyplot as plt
    import networkx as nx









.. GENERATED FROM PYTHON SOURCE LINES 239-241

We also define the four-vertex graph for which we
want to find the minimum vertex cover:

.. GENERATED FROM PYTHON SOURCE LINES 242-250

.. code-block:: default


    edges = [(0, 1), (1, 2), (2, 0), (2, 3)]
    graph = nx.Graph(edges)

    nx.draw(graph, with_labels=True)
    plt.show()





.. image-sg:: /demos/images/sphx_glr_tutorial_qaoa_intro_001.png
   :alt: tutorial qaoa intro
   :srcset: /demos/images/sphx_glr_tutorial_qaoa_intro_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 251-266

There are two minimum vertex covers of this graph: the vertices 0 and 2,
and the vertices 1 and 2. These can be respectively represented by the bit strings 1010 and
0110. The goal of the algorithm is to sample these bit strings with high probability.

The PennyLane QAOA module has a collection of built-in optimization
problems, including minimum vertex cover. For each problem, you can retrieve the cost Hamiltonian
as well as a recommended mixer Hamiltonian. This
makes it straightforward to obtain the Hamiltonians for specific problems while still
permitting the flexibility to make other choices, for example by adding constraints or
experimenting with different mixers.

In our case, the cost
Hamiltonian has two ground states, :math:`|1010\rangle` and :math:`|0110\rangle`, coinciding
with the solutions of the problem. The mixer Hamiltonian is the simple, non-commuting sum of Pauli-X
operations on each node of the graph:

.. GENERATED FROM PYTHON SOURCE LINES 267-273

.. code-block:: default


    cost_h, mixer_h = qaoa.min_vertex_cover(graph, constrained=False)

    print("Cost Hamiltonian", cost_h)
    print("Mixer Hamiltonian", mixer_h)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Cost Hamiltonian   (-0.25) [Z3]
    + (0.5) [Z0]
    + (0.5) [Z1]
    + (1.25) [Z2]
    + (0.75) [Z0 Z1]
    + (0.75) [Z0 Z2]
    + (0.75) [Z1 Z2]
    + (0.75) [Z2 Z3]
    Mixer Hamiltonian   (1) [X0]
    + (1) [X1]
    + (1) [X2]
    + (1) [X3]




.. GENERATED FROM PYTHON SOURCE LINES 274-284

A single layer of QAOA consists of time evolution under these
Hamiltonians:

.. figure:: ../demonstrations/qaoa_module/layer.png
    :align: center
    :width: 90%

While it is possible to use :func:`~.pennylane.templates.ApproxTimeEvolution`, the QAOA module allows you to
build the cost and mixer layers directly using the functions :func:`~.pennylane.qaoa.cost_layer` and
:func:`~.pennylane.qaoa.mixer_layer`, which take as input the respective Hamiltonian and variational parameters:

.. GENERATED FROM PYTHON SOURCE LINES 285-291

.. code-block:: default



    def qaoa_layer(gamma, alpha):
        qaoa.cost_layer(gamma, cost_h)
        qaoa.mixer_layer(alpha, mixer_h)








.. GENERATED FROM PYTHON SOURCE LINES 292-296

We are now ready to build the full variational circuit. The number of wires is equal to
the number of vertices of the graph. We initialize the state to an even superposition over
all basis states.
For this example, we employ a circuit consisting of two QAOA layers:

.. GENERATED FROM PYTHON SOURCE LINES 297-308

.. code-block:: default



    wires = range(4)
    depth = 2

    def circuit(params, **kwargs):
        for w in wires:
            qml.Hadamard(wires=w)
        qml.layer(qaoa_layer, depth, params[0], params[1])









.. GENERATED FROM PYTHON SOURCE LINES 309-319

Note that :func:`~.pennylane.layer` allows us to pass variational parameters
``params[0]`` and ``params[1]`` into each layer of the circuit. That's it! The last
step is PennyLane's specialty: optimizing the circuit parameters.

The cost function is the expectation value of :math:`H_C`, which we want to minimize. We
use the function :func:`~.pennylane.expval` which returns the
expectation value of the Hamiltonian with respect to the circuit's output state.
We also define the device on which the simulation is performed. We use the
PennyLane-Qulacs plugin to run the circuit on the Qulacs simulator:


.. GENERATED FROM PYTHON SOURCE LINES 320-329

.. code-block:: default


    dev = qml.device("qulacs.simulator", wires=wires)

    @qml.qnode(dev)
    def cost_function(params):
        circuit(params)
        return qml.expval(cost_h)









.. GENERATED FROM PYTHON SOURCE LINES 330-333

Finally, we optimize the cost function using the built-in
:func:`~.pennylane.GradientDescentOptimizer`. We perform optimization for seventy steps and initialize the
parameters:

.. GENERATED FROM PYTHON SOURCE LINES 334-341

.. code-block:: default



    optimizer = qml.GradientDescentOptimizer()
    steps = 70
    params = np.array([[0.5, 0.5], [0.5, 0.5]], requires_grad=True)









.. GENERATED FROM PYTHON SOURCE LINES 342-352

Notice that we set each of the initial parameters to :math:`0.5`. For demonstration purposes,
we chose initial parameters that we know work fairly well, and don't get stuck in any local minima.

The choice of initial parameters for a variational circuit is usually a difficult problem,
so we won't linger on it too much in this tutorial, but it is important to note that
finding an initial set of parameters that work well for a few toy problems often yields good results
for more complex instances of the algorithm as well.

Now, we can optimize the circuit:


.. GENERATED FROM PYTHON SOURCE LINES 353-361

.. code-block:: default


    for i in range(steps):
        params = optimizer.step(cost_function, params)

    print("Optimal Parameters")
    print(params)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Optimal Parameters
    [[0.59806352 0.94198485]
     [0.52797281 0.85552845]]




.. GENERATED FROM PYTHON SOURCE LINES 362-367

With the optimal parameters, we can now reconstruct the probability
landscape. We redefine the
full QAOA circuit with the optimal parameters, but this time we
return the probabilities of measuring each bitstring:


.. GENERATED FROM PYTHON SOURCE LINES 368-378

.. code-block:: default


    @qml.qnode(dev)
    def probability_circuit(gamma, alpha):
        circuit([gamma, alpha])
        return qml.probs(wires=wires)


    probs = probability_circuit(params[0], params[1])









.. GENERATED FROM PYTHON SOURCE LINES 379-381

Finally, we can display a bar graph showing the probability of
measuring each bitstring:

.. GENERATED FROM PYTHON SOURCE LINES 382-388

.. code-block:: default


    plt.style.use("seaborn")
    plt.bar(range(2 ** len(wires)), probs)
    plt.show()





.. image-sg:: /demos/images/sphx_glr_tutorial_qaoa_intro_002.png
   :alt: tutorial qaoa intro
   :srcset: /demos/images/sphx_glr_tutorial_qaoa_intro_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 389-398

The states
:math:`|6\rangle \ = \ |0110\rangle` and
:math:`|10\rangle \ = \ |1010\rangle` have the highest probabilities of
being measured, just as expected!

.. figure:: ../demonstrations/qaoa_module/graph.png
    :align: center
    :width: 90%


.. GENERATED FROM PYTHON SOURCE LINES 401-421

Customizing QAOA
----------------

QAOA is not one-size-fits-all when it comes to solving optimization problems. In many cases,
cost and mixer Hamiltonians will be very specific to one scenario, and not necessarily
fit within the structure of the pre-defined problems in the :func:`~.pennylane.qaoa` submodule. Luckily,
one of the core principles behind the entire PennyLane library is customizability, and this principle hold true for
QAOA submodule as well!

The QAOA workflow above gave us two optimal solutions: :math:`|6\rangle = |0110\rangle`
and :math:`|10\rangle = |1010\rangle`. What if we add a constraint
that made one of these solutions "better" than the other? Let's imagine that we are interested in
solutions that minimize the original cost function,
*but also colour the first and third vertices* :math:`1`. A constraint of this form will
favour :math:`|10\rangle`, making it the only true ground state.

It is easy to introduce constraints of this form in PennyLane.
We can use the :func:`~.pennylane.qaoa.edge_driver` cost
Hamiltonian to "reward" cases in which the first and last vertices of the graph
are :math:`0`:

.. GENERATED FROM PYTHON SOURCE LINES 421-424

.. code-block:: default


    reward_h = qaoa.edge_driver(nx.Graph([(0, 2)]), ['11'])








.. GENERATED FROM PYTHON SOURCE LINES 425-427

We then weigh and add the constraining term
to the original minimum vertex cover Hamiltonian:

.. GENERATED FROM PYTHON SOURCE LINES 428-431

.. code-block:: default


    new_cost_h = cost_h + 2 * reward_h








.. GENERATED FROM PYTHON SOURCE LINES 432-435

Notice that PennyLane allows for simple addition and multiplication of
Hamiltonian objects using inline arithmetic operations ‚ûï ‚ûñ ‚úñÔ∏è‚ûó! Finally, we can
use this new cost Hamiltonian to define a new QAOA workflow:

.. GENERATED FROM PYTHON SOURCE LINES 436-461

.. code-block:: default



    def qaoa_layer(gamma, alpha):
        qaoa.cost_layer(gamma, new_cost_h)
        qaoa.mixer_layer(alpha, mixer_h)

    def circuit(params, **kwargs):
        for w in wires:
            qml.Hadamard(wires=w)
        qml.layer(qaoa_layer, depth, params[0], params[1])

    @qml.qnode(dev)
    def cost_function(params):
        circuit(params)
        return qml.expval(new_cost_h)

    params = np.array([[0.5, 0.5], [0.5, 0.5]], requires_grad=True)

    for i in range(steps):
        params = optimizer.step(cost_function, params)

    print("Optimal Parameters")
    print(params)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Optimal Parameters
    [[0.45959941 0.96095271]
     [0.27029962 0.78042396]]




.. GENERATED FROM PYTHON SOURCE LINES 462-464

We then reconstruct the probability landscape with the optimal parameters:


.. GENERATED FROM PYTHON SOURCE LINES 465-477

.. code-block:: default


    @qml.qnode(dev)
    def probability_circuit(gamma, alpha):
        circuit([gamma, alpha])
        return qml.probs(wires=wires)

    probs = probability_circuit(params[0], params[1])

    plt.style.use("seaborn")
    plt.bar(range(2 ** len(wires)), probs)
    plt.show()




.. image-sg:: /demos/images/sphx_glr_tutorial_qaoa_intro_003.png
   :alt: tutorial qaoa intro
   :srcset: /demos/images/sphx_glr_tutorial_qaoa_intro_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 478-481

Just as we expected, the :math:`|10\rangle` state is now favoured
over :math:`|6\rangle`!


.. GENERATED FROM PYTHON SOURCE LINES 484-504

Conclusion
----------

You have learned how to use the PennyLane QAOA functionality, while
also surveying some of the fundamental features that make the QAOA module simple and
flexible. Now, it's your turn to experiment with QAOA! If you need some inspiration for how to get
started:

- Experiment with different optimizers and different devices. Which ones work the best?
- Play around with some of the other built-in cost and mixer Hamiltonians.
- Try making your own custom constraining terms. Is QAOA properly amplifying some bitstrings over others?

.. figure:: ../demonstrations/qaoa_module/qaoa_circuit.png
    :align: center
    :width: 90%


About the author
----------------
.. include:: ../_static/authors/jack_ceroni.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 3 minutes  6.270 seconds)


.. _sphx_glr_download_demos_tutorial_qaoa_intro.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_qaoa_intro.py <tutorial_qaoa_intro.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_qaoa_intro.ipynb <tutorial_qaoa_intro.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
