
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_quantum_analytic_descent.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_quantum_analytic_descent.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_quantum_analytic_descent.py:


.. _quantum_analytic_descent:

Quantum analytic descent
========================

.. meta::
    :property="og:description": Implement the Quantum analytic descent algorithm for VQE.
    :property="og:image": https://pennylane.ai/qml/_images/flowchart.png

.. related::

   tutorial_vqe A brief overview of VQE
   tutorial_quantum_natural_gradient Quantum natural gradient
   tutorial_rotoselect Quantum circuit structure learning
   tutorial_stochastic_parameter_shift The stochastic parameter-shift rule


*Authors: Elies Gil-Fuster, David Wierichs (Xanadu Residents) — Posted: 30 June 2021. Last updated: 18 November 2021*

One of the main problems of many-body physics is that of finding the ground
state and ground state energy of a given Hamiltonian.
`The Variational Quantum Eigensolver (VQE) <https://pennylane.ai/qml/demos/tutorial_vqe.html>`_ combines smart circuit
design with gradient-based optimization to solve this task.
Several practical demonstrations have shown how near-term quantum
devices may be suitable for VQE and other variational quantum algorithms.
One issue for such an approach, though, is that the optimization landscape is
non-convex, so reaching a good enough local minimum quickly requires hundreds or
thousands of update steps. This is problematic because computing gradients of the
cost function on a quantum computer is inefficient when it comes to circuits
with many parameters.

At the same time, we have a good understanding of the *local* shape
of the cost landscape around any reference point.
Cashing in on this, the authors of the
Quantum Analytic Descent paper [#QAD]_
propose an algorithm that constructs a classical model which approximates the
landscape, so that the gradients can be calculated on a classical computer, which is much cheaper.
In order to build the classical model, we need to use the quantum device to
evaluate the cost function on (a) a reference point :math:`\boldsymbol{\theta}_0`,
and (b) a number of points shifted away from :math:`\boldsymbol{\theta}_0`.
With the cost values at these points, we can build the classical model that
approximates the landscape.

In this demo, you will learn how to implement Quantum Analytic Descent using PennyLane.
In addition, you will look under the hood of the constructed models and the optimization steps
carried out by the algorithm.
So: sit down, relax, and enjoy your optimization!

|

.. figure:: ../demonstrations/quantum_analytic_descent/xkcd.png
    :align: center
    :width: 50%
    :target: javascript:void(0)

    Optimization progress with Quantum Analytic Descent.



VQEs give rise to trigonometric cost functions
----------------------------------------------

When we talk about VQEs we have a quantum circuit with :math:`n` qubits in mind, which are typically initialized in the base state :math:`|0\rangle`.
The body of the circuit is a *variational form* :math:`V(\boldsymbol{\theta})` – a fixed architecture of quantum gates parametrized by an array of real-valued parameters :math:`\boldsymbol{\theta}\in\mathbb{R}^m`.
After the variational form, the circuit ends with the measurement of a chosen observable
:math:`\mathcal{M}`, based on the problem
we are trying to solve.

The idea in VQE is to fix a variational form such that the expected value of the measurement relates to the energy of an interesting Hamiltonian:

.. math:: E(\boldsymbol{\theta}) = \langle 0|V^\dagger(\boldsymbol{\theta})\mathcal{M}V(\boldsymbol{\theta})|0\rangle.

We want to find the lowest possible energy the system can attain;
this corresponds to running an optimization program to find the :math:`\boldsymbol{\theta}` that minimizes the function above.


If the gates in the variational form are restricted to be Pauli rotations, then the cost function is a sum of *multilinear trigonometric terms* in each of the parameters.
That's a scary sequence of words!
What it means is that if we look at :math:`E(\boldsymbol{\theta})` but we focus only on one of the parameters, say :math:`\theta_i`, then we can write the functional dependence as a linear combination of three functions: :math:`1`, :math:`\sin(\theta_i)`, and :math:`\cos(\theta_i)`.
That is, for each parameter :math:`\theta_i` there exist :math:`a_i`, :math:`b_i`, and :math:`c_i` such that the cost can be written as

.. math:: E(\boldsymbol{\theta}) = a_i + b_i\sin(\theta_i) + c_i\cos(\theta_i).

All parameters but :math:`\theta_i` are absorbed in the coefficients :math:`a_i`, :math:`b_i` and :math:`c_i`.
Another technique using this structure of :math:`E(\boldsymbol{\theta})` are the
Rotosolve/Rotoselect algorithms [#Rotosolve]_ for which there also is `a PennyLane demo <https://pennylane.ai/qml/demos/tutorial_rotoselect.html>`__.

Let's look at a toy example to illustrate this structure of the cost function.

.. GENERATED FROM PYTHON SOURCE LINES 92-113

.. code-block:: default











    # Create a device with 2 qubits.


    # Define the variational form V and observable M and combine them into a QNode.














.. GENERATED FROM PYTHON SOURCE LINES 114-116

Let us now look at how the energy value depends on each of the two parameters alone.
For that, we just fix one parameter and show the cost when varying the other one:

.. GENERATED FROM PYTHON SOURCE LINES 116-168

.. code-block:: default


    # Create 1D sweeps through parameter space with the other parameter fixed.


    # Fix a parameter position.






    # Show the sweeps.








    # Create a 2D grid and evaluate the energy on the grid points.
    # We cut out a part of the landscape to increase clarity.










    # Show the energy landscape on the grid.


























.. GENERATED FROM PYTHON SOURCE LINES 169-303

Of course this is an overly simplified example, but the key take-home message so far is:
*if the variational parameters feed into Pauli rotations, the energy landscape is a multilinear combination of trigonometric functions*.
What is a good thing about trigonometric functions?
That's right!
We have studied them since high school and know how their graphs look.

The QAD strategy
----------------

By now we know how the energy landscape looks for a small example.
Scaling this up to more parameters would quickly become unfeasible because we need to query a quantum computer for every combination of parameter values.
The secret ingredient of this sauce is that we only need to build an approximate classical model.
Using an approximate classical model has one feature and one bug.
The feature: it is cheap to construct.
The bug: well, it's only approximate, so we cannot rely on it fully.
And one extra feature (you didn't see that coming, did you?): if the reference point about which we build the classical model is a true local minimum, then it will be a local minimum of the classical model too.
And that is the key!
Given a reference point, we use the classical model to find a point that's closer to the true minimum, and then use that point as reference for a new model!
This is what is called Quantum Analytic Descent (QAD), and if you are fine not knowing yet what all the symbols mean, here's its pseudo-algorithm:

#. Set an initial reference point :math:`\boldsymbol{\theta}_0`.
#. Build the model :math:`\hat{E}(\boldsymbol{\theta})\approx E(\boldsymbol{\theta}_0+\boldsymbol{\theta})` at this point.
#. Find the minimum :math:`\boldsymbol{\theta}_\text{min}` of the model.
#. Set :math:`\boldsymbol{\theta}_0+\boldsymbol{\theta}_\text{min}` as the new reference point :math:`\boldsymbol{\theta}_0`, go back to Step 2.
#. After convergence or a fixed number of models built, output the last minimum :math:`\boldsymbol{\theta}_\text{opt}=\boldsymbol{\theta}_0+\boldsymbol{\theta}_\text{min}`.

Computing a classical model
---------------------------

Knowing how the cost looks when restricted to only one parameter (see the plot above), nothing keeps us in theory from constructing a perfect classical model.
The only thing we need to do is write down a general multilinear trigonometric polynomial and determine its coefficients.
Simple, right?
Well, for :math:`m` parameters, there would be :math:`3^m` coefficients to estimate, which gives us the ever-dreaded exponential scaling.
Although conceptually simple, building an exact model would require exponentially many resources, and that's a no-go.
What can we do, then?
The authors of QAD propose building an imperfect model.
This makes *all* the difference—they use a classical model that is accurate only in
a region close to a given reference point, and that delivers good results for the optimization!

Function expansions
^^^^^^^^^^^^^^^^^^^

What do we usually do when we want to approximate something in a region near to a reference point?
Correct!
We use a Taylor expansion!
But what if we told you there is a better option for the case at hand?
In the QAD paper, the authors state that a *trigonometric expansion* up to second order is already a sound model candidate. Let's recap such expansions.

.. admonition:: Taylor expansion vs. Trigonometric expansion

    In spirit, a trigonometric expansion and a Taylor expansion are not that different: both are linear combinations of some basis functions, where the coefficients of the sum take very specific values usually related to the derivatives of the function we want to approximate.
    The difference between Taylor's and a trigonometric expansion is mainly what basis of functions we take.
    In Calculus I we learned that a Taylor series in one variable :math:`x` uses the integer powers of the variable namely :math:`\{1, x, x^2, x^3, \ldots\}`, in short :math:`\{x^n\}_{n\in\mathbb{N}}`:

    .. math:: f_\text{Taylor}(x) = \sum c_n(x-x_0)^n.

    A trigonometric expansion instead uses a different basis, also for one variable: :math:`\{1, \sin(x), \cos(x), \sin(2x), \cos(2x), \ldots\}`, which we could call the set of trigonometric monomials with integer frequency, or in short :math:`\{\sin(nx),\cos(nx)\}_{n\in\mathbb{N}}`:

    .. math:: f_\text{Trig}(x) = \sum a_n \cos(n(x-x_0))+ b_n \sin(n(x-x_0)).

    For higher-dimensional variables we have to take products of the basis functions of each coordinate, i.e., of monomials or trigonometric monomials respectively.
    This does lead to an exponentially increasing number of terms, but if we chop the series soon enough it will not get too much out of hand.
    The proposal here is to only go up to second order terms, so we are safe.

Expanding in adapted trigonometric polynomials
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

One important aspect in which trigonometric series differ from regular
expansions is that there is not a clear separation between what terms
contribute to each order of the expansion (due to the fact that all
derivatives of sine and cosine are non-zero in general).
Because of this, we group the terms by their leading order contribution, and
in the following table write them next to their non-trigonometric analogues.
All chosen trigonometric monomials have leading order coefficient :math:`1`
and they all differ in their leading order contribution.

.. list-table::
   :widths: 10 70 20
   :header-rows: 1

   * - Order
     - Trigonometric monomial
     - Taylor monomial
   * - 0
     - :math:`A(\boldsymbol{\theta})= \prod_{i=1}^m \cos\left(\frac{\theta_i}{2}\right)^2`
     - :math:`1`
   * - 1
     - :math:`B_k(\boldsymbol{\theta}) = 2\cos\left(\frac{\theta_k}{2}\right)\sin\left(\frac{\theta_k}{2}\right)\prod_{i\neq k} \cos\left(\frac{\theta_i}{2}\right)^2`
     - :math:`x_k`
   * - 2
     - :math:`C_k(\boldsymbol{\theta}) = 2\sin\left(\frac{\theta_k}{2}\right)^2\prod_{i\neq k} \cos\left(\frac{\theta_i}{2}\right)^2`
     - :math:`x_k^2`
   * - 2
     - :math:`D_{kl}(\boldsymbol{\theta}) = 4\sin\left(\frac{\theta_k}{2}\right)\cos\left(\frac{\theta_k}{2}\right)\sin\left(\frac{\theta_l}{2}\right)\cos\left(\frac{\theta_l}{2}\right)\prod_{i\neq k,l} \cos\left(\frac{\theta_i}{2}\right)^2`
     - :math:`x_kx_l`

Those are really large terms compared to a Taylor series!
However, you may have noticed all of those terms have large parts in common.
Indeed, we can rewrite the longer ones in a shorter way which is more decent to look at:

.. math::

  B_k(\boldsymbol{\theta}) &= 2\tan\left(\frac{\theta_k}{2}\right)A(\boldsymbol{\theta})\\
  C_k(\boldsymbol{\theta}) &= 2\tan\left(\frac{\theta_k}{2}\right)^2 A(\boldsymbol{\theta})\\
  D_{kl}(\boldsymbol{\theta}) &= 4\tan\left(\frac{\theta_k}{2}\right)\tan\left(\frac{\theta_l}{2}\right)A(\boldsymbol{\theta})

With that, we know what type of terms we should expect to encounter in our local classical model:
the model we want to construct is a linear combination of the functions
:math:`A(\boldsymbol{\theta})`, :math:`B_k(\boldsymbol{\theta})` and :math:`C_k(\boldsymbol{\theta})`
for each parameter, and :math:`D_{kl}(\boldsymbol{\theta})` for every pair of different parameters :math:`(\theta_k,\theta_l)`.

Computing the expansion coefficients
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We can now use the derivatives of the function we are approximating to obtain the coefficients of the linear combination.
As the terms we include in the expansion have leading orders :math:`0`, :math:`1` and :math:`2`, these derivatives are
:math:`E(\boldsymbol{\theta})`, :math:`\partial E(\boldsymbol{\theta})/\partial \theta_k`,
:math:`\partial^2 E(\boldsymbol{\theta})/\partial\theta_k^2`, and :math:`\partial^2 E(\boldsymbol{\theta})/\partial \theta_k\partial\theta_l`.
However, the trigonometric polynomials may contain multiple orders in :math:`\boldsymbol{\theta}`. For example, both
:math:`A(\boldsymbol{\theta})` and :math:`C_k(\boldsymbol{\theta})` contribute to the second order, so we have to account
for this in the coefficient of :math:`\partial^2 E(\boldsymbol{\theta})/\partial \theta_k^2`.
We can name the different coefficients (including the function value itself) accordingly to how we named the terms in the series:

.. math::

  E^{(A)} &= E(\boldsymbol{\theta})\Bigg|_{\boldsymbol{\theta}=0} \\
  E^{(B)}_k &= \frac{\partial E(\boldsymbol{\theta})}{\partial\theta_k}\Bigg|_{\boldsymbol{\theta}=0} \\
  E^{(C)}_k &= \frac{\partial^2 E(\boldsymbol{\theta})}{\partial\theta_k^2}\Bigg|_{\boldsymbol{\theta}=0} + \frac{1}{2}E(\boldsymbol{\theta})\Bigg|_{\boldsymbol{\theta}=0}\\
  E^{(D)}_{kl} &= \frac{\partial^2 E(\boldsymbol{\theta})}{\partial\theta_k\partial\theta_l}\Bigg|_{\boldsymbol{\theta}=0}

In PennyLane, computing the gradient of a cost function with respect to an array of parameters can be easily done
with the `parameter-shift rule <https://pennylane.ai/qml/glossary/parameter_shift.html>`_.
By iterating the rule, we can obtain the second derivatives – the Hessian (see for example [#higher_order_diff]_).
Let us implement a function that does just that and prepares the coefficients :math:`E^{(A/B/C/D)}`:

.. GENERATED FROM PYTHON SOURCE LINES 328-329

Let's test our brand-new function for the circuit from above, at a random parameter position:

.. GENERATED FROM PYTHON SOURCE LINES 343-356

The classical model (finally!)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Bringing all of the above ingredients together, we have the following gorgeous trigonometric expansion up to second order:

.. math:: \hat{E}(\boldsymbol{\theta}) := A(\boldsymbol{\theta}) E^{(A)} + \sum_{k=1}^m\left[B_k(\boldsymbol{\theta})E_k^{(B)} + C_k(\boldsymbol{\theta}) E_k^{(C)}\right] + \sum_{k<l}^m\left[D_{kl}(\boldsymbol{\theta}) E_{kl}^{(D)}\right].

Let us now take a few moments to breath deeply and admire the entirety of it.
On the one hand, we have the :math:`A`, :math:`B_k`, :math:`C_k`, and
:math:`D_{kl}` functions, which we said are the basis functions of the
expansion.
On the other hand we have the real-valued coefficients :math:`E^{(A/B/C/D)}` for the previous functions which are nothing but the derivatives in the corresponding input components.
Combining them yields the trigonometric expansion, which we implement with another function:

.. GENERATED FROM PYTHON SOURCE LINES 356-393

.. code-block:: default
























    # Compute the circuit at parameters (This value is also stored in E_A=coeffs[0])

    # Compute the model at parameters by plugging in relative parameters 0.







    # Check that coeffs[0] indeed is the original energy and that the model is correct at 0.










.. GENERATED FROM PYTHON SOURCE LINES 394-400

As we can see, the model reproduces the correct energy at the parameter
position :math:`\boldsymbol{\theta}_0` at which we constructed it (again note how the
input parameters of the model are *relative* to the reference point
such that :math:`\hat{E}(0)=E(\boldsymbol{\theta}_0)` is satisfied).
When we move away from :math:`\boldsymbol{\theta}_0`, the model starts to deviate,
as it is an *approximation* after all:

.. GENERATED FROM PYTHON SOURCE LINES 400-416

.. code-block:: default


    # Obtain a random shift away from parameters



    # Compute the cost function and the model at the shifted position.

















.. GENERATED FROM PYTHON SOURCE LINES 417-453

.. note::
    **Counting parameters and evaluations**

    How many parameters does our model have?
    In the following table we count them for an :math:`m`-dimensional input
    variable :math:`\boldsymbol{\theta}=(\theta_1,\ldots,\theta_m)`:

    .. list-table::
       :widths: 20 35 45
       :header-rows: 1

       * -
         - Number of coefficients
         - Number of circuit evaluations
       * - :math:`E^{(A)}`
         - :math:`1`
         - :math:`1`
       * - :math:`E^{(B)}`
         - :math:`m`
         - :math:`2m`
       * - :math:`E^{(C)}`
         - :math:`m`
         - :math:`m`
       * - :math:`E^{(D)}`
         - :math:`\frac{m(m-1)}{2}`
         - :math:`4\frac{m(m-1)}{2}`
       * - Total:
         - :math:`\frac{m^2}{2}+\frac{3m}{2}+1`
         - :math:`2m^2+m+1`

    So there we go!
    We only need polynomially many parameters and circuit evaluations.
    This is much cheaper than the :math:`3^m` we would need if we naively tried to construct the cost landscape exactly, without chopping after second order.

Now this should be enough theory, so let's visualize the model that results from our trigonometric expansion.
We'll use the coefficients and the ``model_cost`` function from above and sample a new random parameter position.

.. GENERATED FROM PYTHON SOURCE LINES 454-504

.. code-block:: default





    # We actually make the plotting a function because we will reuse it below.





































    # Get some fresh random parameters and the model coefficients



    # Define a mapped model that has the model coefficients fixed.










.. GENERATED FROM PYTHON SOURCE LINES 505-559

In the first two plots, we see the true landscape, and the approximate model.
The vertical rods indicate the points at which the original cost function
was evaluated in order to obtain the model coefficients (we skip the additional
evaluations for :math:`E^{(C)}`, though, for clarity of the plot).
The rod with the bead on top indicates the reference point around which the model
is built and at which it coincides with the original cost function up to second
order. This is underlined in the third plot, where we see the difference between
the model and true landscapes.
Around the reference point the difference is very small and changes very slowly,
only growing significantly for large simultaneous perturbations in both
parameters. This already hints at the value of the model for local optimization.

Quantum Analytic Descent
------------------------

The underlying idea we will now try to exploit for optimization in VQEs is the following:
if we can model the cost around the reference point well enough, we will be able to find a rough
estimate of where the minimum of the landscape is.
Granted, our model represents the true landscape less accurately the further we go away from the
reference point :math:`\boldsymbol{\theta}_0`, but nonetheless the minimum *of the model*
will bring us much closer to the minimum *of the true cost* than a random choice.
Recall the complete strategy from above:

#. Set an initial reference point :math:`\boldsymbol{\theta}_0`.
#. Build the model :math:`\hat{E}(\boldsymbol{\theta})\approx E(\boldsymbol{\theta}_0+\boldsymbol{\theta})` at this point.
#. Find the minimum :math:`\boldsymbol{\theta}_\text{min}` of the model.
#. Set :math:`\boldsymbol{\theta}_0+\boldsymbol{\theta}_\text{min}` as the new reference point :math:`\boldsymbol{\theta}_0`, go back to Step 2.
#. After convergence or a fixed number of models built, output the last minimum :math:`\boldsymbol{\theta}_\text{opt}=\boldsymbol{\theta}_0+\boldsymbol{\theta}_\text{min}`.

This provides an iterative strategy which will take us to a good enough solution
in fewer iterations than, for example, regular stochastic gradient descent (SGD).
The procedure of Quantum Analytic Descent is also shown in the following flowchart. Note that the minimization
of the model in Step 3 is carried out via an inner optimization loop.

.. figure:: ../demonstrations/quantum_analytic_descent/flowchart.png
   :align: center
   :width: 80%
   :target: javascript:void(0)

Using the functions from above, we now can implement the loop between Steps 2 and 4.
Indeed, for a relatively small number of iterations we should already find a low enough value.
If we look back at the circuit we defined, we notice that we are measuring the observable

.. math ::

  Z\otimes Z=\begin{pmatrix}
  1 & 0 & 0 & 0 \\
  0 & -1 & 0 & 0 \\
  0 & 0 & -1 & 0 \\
  0 & 0 & 0 & 1 \end{pmatrix},

which has the eigenvalues :math:`1` and :math:`-1`.
This means our function is bounded and takes values in the range :math:`[-1,1]`, so that the global minimum should be around :math:`-1` if our circuit is expressive enough.
Let's try it and apply the full optimization strategy:

.. GENERATED FROM PYTHON SOURCE LINES 559-608

.. code-block:: default




    # Set the number of iterations of Steps 2, 3, and 4




















































.. GENERATED FROM PYTHON SOURCE LINES 609-615

This looks great! Quantum Analytic Descent found the minimum.

Inspecting the models
^^^^^^^^^^^^^^^^^^^^^

Let us take a look at the intermediate models QAD built:

.. GENERATED FROM PYTHON SOURCE LINES 620-621

**Iteration 1:** We see the cost function and the model around our starting point. This is the same as the plot before.

.. GENERATED FROM PYTHON SOURCE LINES 626-627

**Iteration 2:** Now we observe the model better resembles the original landscape. In addition, the minimum of the model is within the displayed range – we're getting closer.

.. GENERATED FROM PYTHON SOURCE LINES 632-642

**Iteration 3:** Both the model and the original cost function now show a minimum close to our parameter position— Quantum Analytic Descent converged.
Note how the larger deviations of the model close to the boundaries are not a problem at all because we only use the model in the central area
in which both the original energy and the model form a convex bowl and the deviation plateaus at zero.

Optimization behaviour
^^^^^^^^^^^^^^^^^^^^^^

If we pay close attention to the values printed during the optimization, we can identify a curious phenomenon.
At the last epochs within some iterations, the *model cost* goes beyond :math:`-1`.
Could we visualize this behavior more clearly, please?

.. GENERATED FROM PYTHON SOURCE LINES 656-715

Each of the orange lines corresponds to minimizing the model constructed at a
different reference point.
We can now more easily appreciate the phenomenon we just described:
towards the end of each "outer" optimization step, the model cost
can potentially be significantly lower than the true cost.
Once the true cost itself approaches the absolute minimum, this means the
model cost can overstep the allowed range.
*Wasn't this forbidden? You guys told us the function could only take values in* :math:`[-1,1]` >:@
Yes, but careful!
While the *true cost* values are bounded, that does not mean the ones of the *model* are!
Notice also how this only happens at the first stages of analytic descent.

Bringing together a few chords we have touched so far: once we fix a reference value, the further we go from it, the less accurate our model becomes.
Thus, if we start far off from the true minimum, it can happen that our model exaggerates how steep the landscape is and then the model minimum lies lower than that of the true cost.
We see how values exiting the allowed range of the true cost function does not have an
impact on the overall optimization.

In this demo we've seen how to implement the Quantum Analytic Descent algorithm
using PennyLane for a toy example of a Variational Quantum Eigensolver.
By making extensive use of 3D plots we have also tried to illustrate exactly
what is going on in both the true cost landscape and the trigonometric expansion
approximation.
Recall we wanted to avoid working on the true landscape itself because we can
only access it via very costly quantum computations.
Instead, a fixed number of runs on the quantum device for a few iterations
allowed us to construct a classical model on which we performed (cheap)
classical optimization.

And that was it! Thanks for coming to our show.
Don't forget to fasten your seat belts on your way home! It was a pleasure
having you here today.

References
----------

.. [#QAD]

    Balint Koczor, Simon Benjamin. "Quantum Analytic Descent".
    `arXiv preprint arXiv:2008.13774 <https://arxiv.org/abs/2008.13774>`__.

.. [#Rotosolve]

    Mateusz Ostaszewski, Edward Grant, Marcello Benedetti.
    "Structure optimization for parameterized quantum circuits".
    `arXiv preprint arXiv:1905.09692 <https://arxiv.org/abs/1905.09692>`__.

.. [#higher_order_diff]

    Andrea Mari, Thomas R. Bromley, Nathan Killoran.
    "Estimating the gradient and higher-order derivatives on quantum hardware".
    `Phys. Rev. A 103, 012405 <https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.012405>`__, 2021.
    `arXiv preprint arXiv:2008.06517 <https://arxiv.org/abs/2008.06517>`__.


About the authors
-----------------
.. include:: ../_static/authors/elies_gil-fuster.txt

.. include:: ../_static/authors/david_wierichs.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.001 seconds)


.. _sphx_glr_download_demos_tutorial_quantum_analytic_descent.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_quantum_analytic_descent.py <tutorial_quantum_analytic_descent.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_quantum_analytic_descent.ipynb <tutorial_quantum_analytic_descent.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
