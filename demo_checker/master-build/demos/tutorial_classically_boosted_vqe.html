
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Learn how to implement classically-boosted VQE in PennyLane." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/CB_VQE.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Classically-Boosted Variational Quantum Eigensolver &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_classically_boosted_vqe.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Learn how to implement classically-boosted VQE in PennyLane." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Classically-Boosted Variational Quantum Eigensolver &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_classically_boosted_vqe.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Using PennyLane with PySCF and OpenFermion" href="tutorial_qchem_external.html" />
    <link rel="prev" title="Qubit tapering" href="tutorial_qubit_tapering.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_qchem_external.html" title="Using PennyLane with PySCF and OpenFermion"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_qubit_tapering.html" title="Qubit tapering"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-chemistry.html" accesskey="U">Quantum Chemistry</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Classically-Boosted Variational Quantum Eigensolver</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-classically-boosted-vqe-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="classically-boosted-variational-quantum-eigensolver">
<span id="sphx-glr-demos-tutorial-classically-boosted-vqe-py"></span><h1>Classically-Boosted Variational Quantum Eigensolver<a class="headerlink" href="#classically-boosted-variational-quantum-eigensolver" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_quantum_chemistry.html", "tutorial_vqe.html"];
    var related_tutorials_titles = ['Building molecular Hamiltonians', 'Variational Quantum Eigensolver'];
</script></p>
<p><em>Authors: Joana Fraxanet &amp; Isidor Schoch (Xanadu Residents).
Posted: 31 October 2022. Last updated: 31 October 2022.</em></p>
<p>One of the most important applications of quantum computers is expected
to be the computation of ground-state energies of complicated molecules
and materials. Even though there are already some solid proposals on how
to tackle these problems when fault-tolerant quantum computation comes
into play, we currently live in the <a class="reference external" href="https://en.wikipedia.org/wiki/Noisy_intermediate-scale_quantum_era">noisy intermediate-scale quantum
(NISQ)</a>
era, meaning that we can only access noisy and limited devices.
That is why a large part of the current research on quantum algorithms is
focusing on what can be done with few resources. In particular, most
proposals rely on variational quantum algorithms (VQA), which are
optimized classically and adapt to the limitations of the quantum
devices. For the specific problem of computing ground-state energies,
the paradigmatic algorithm is the <a class="reference external" href="https://en.wikipedia.org/wiki/Variational_quantum_eigensolver">Variational Quantum Eigensolver
(VQE)</a> algorithm.</p>
<p>Although VQE is intended to run on NISQ devices, it is nonetheless
sensitive to noise. This is particularly problematic when applying VQE to complicated molecules which requires a large number of gates.
As a consequence, several modifications to the
original VQE algorithm have been proposed. These variants are usually
intended to improve the algorithm’s performance on NISQ-era devices.</p>
<p>In this demo, we will go through one of these proposals step-by-step: the
Classically-Boosted Variational Quantum Eigensolver (CB-VQE) <a class="footnote-reference brackets" href="#radin2021" id="id1">1</a>.
Implementing CB-VQE reduces the number of measurements required to obtain the
ground-state energy with a certain precision. This is done by making use
of classical states, which in this context are product states that can be
written as a single <a class="reference external" href="https://en.wikipedia.org/wiki/Slater_determinant">Slater determinant</a>
and that already contain some information about the ground-state of the problem.
Their structure allows for efficient classical computation of expectation values.
An example of such classical state would be the <a class="reference external" href="https://en.wikipedia.org/wiki/Hartree%E2%80%93Fock_method">Hartree-Fock state</a>,
in which the electrons occupy the molecular orbitals with the lowest energy.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/CB_VQE.png"><img alt="../_images/CB_VQE.png" src="../_images/CB_VQE.png" style="width: 50%;" /></a>
</div>
<p>We will restrict ourselves to the <span class="math notranslate nohighlight">\(H_2\)</span> molecule for
the sake of simplicity. First, we will give a short introduction to how
to perform standard VQE for the molecule of interest. For more details,
we recommend the tutorial <a class="reference internal" href="tutorial_vqe.html"><span class="doc">A brief overview of VQE</span></a> to learn
how to implement VQE for molecules step by step. Then, we will implement
the CB-VQE algorithm for the specific case in which we rely only on one
classical state⁠—that being the Hartree-Fock state. Finally, we will
discuss the number of measurements needed to obtain a certain
error-threshold by comparing the two methods.</p>
<p>Let’s get started!</p>
<div class="section" id="prerequisites-standard-vqe">
<h2>Prerequisites: Standard VQE<a class="headerlink" href="#prerequisites-standard-vqe" title="Permalink to this headline">¶</a></h2>
<p>If you are not already familiar with the VQE family of algorithms and
wish to see how one can apply it to the <span class="math notranslate nohighlight">\(H_2\)</span> molecule, feel free to
work through the aforementioned demo before reading this section.
Here, we will only briefly review the main idea behind standard VQE
and highlight the important concepts in connection with CB-VQE.</p>
<p>Given a Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>, the main goal of VQE is to find the ground state energy of a system governed by the Schrödinger
equation</p>
<div class="math notranslate nohighlight">
\[H \vert \phi \rangle = E  \vert \phi \rangle.\]</div>
<p>This corresponds to the problem of diagonalizing the Hamiltonian and
finding the smallest eigenvalue. Alternatively, one can formulate the
problem using the <a class="reference external" href="https://en.wikipedia.org/wiki/Variational_principle">variational principle</a>,
in which we are interested in minimizing the energy</p>
<div class="math notranslate nohighlight">
\[E = \langle \phi \vert H \vert \phi \rangle.\]</div>
<p>In VQE, we prepare a statevector <span class="math notranslate nohighlight">\(\vert \phi \rangle\)</span> by applying
the parameterized ansatz <span class="math notranslate nohighlight">\(A(\Theta)\)</span>, represented by a unitary matrix,
to an initial state <span class="math notranslate nohighlight">\(\vert 0 \rangle^{\otimes n}\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of qubits. Then, the parameters <span class="math notranslate nohighlight">\(\Theta\)</span> are
optimized to minimize a cost function, which in this case is the energy:</p>
<div class="math notranslate nohighlight">
\[E(\Theta) = \langle 0 \vert^{\otimes n} A(\Theta)^{\dagger} H A(\Theta) \vert 0 \rangle^{\otimes n}.\]</div>
<p>This is done using a classical optimization method, which is typically
gradient descent.</p>
<p>To implement our example of VQE, we first define the molecular
Hamiltonian for the <span class="math notranslate nohighlight">\(H_2\)</span> molecule in the minimal <a class="reference external" href="https://en.wikipedia.org/wiki/STO-nG_basis_sets">STO-3G basis</a>
using PennyLane</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">qchem</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">]</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">coordinates</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6614</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.6614</span><span class="p">])</span>
<span class="n">basis_set</span> <span class="o">=</span> <span class="s2">&quot;sto-3g&quot;</span>
<span class="n">electrons</span> <span class="o">=</span> <span class="mi">2</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">,</span> <span class="n">qubits</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.qchem.molecular_hamiltonian.html#pennylane.qchem.molecular_hamiltonian" title="pennylane.qchem.molecular_hamiltonian" class="sphx-glr-backref-module-pennylane-qchem sphx-glr-backref-type-py-function"><span class="n">qchem</span><span class="o">.</span><span class="n">molecular_hamiltonian</span></a><span class="p">(</span>
    <span class="n">symbols</span><span class="p">,</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">coordinates</span></a><span class="p">,</span>
    <span class="n">basis</span><span class="o">=</span><span class="n">basis_set</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We then initialize the Hartree-Fock state
<span class="math notranslate nohighlight">\(\vert \phi_{HF}\rangle=\vert 1100 \rangle\)</span></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hf</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.qchem.hf_state.html#pennylane.qchem.hf_state" title="pennylane.qchem.hf_state" class="sphx-glr-backref-module-pennylane-qchem sphx-glr-backref-type-py-function"><span class="n">qchem</span><span class="o">.</span><span class="n">hf_state</span></a><span class="p">(</span><span class="n">electrons</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we implement the ansatz <span class="math notranslate nohighlight">\(A(\Theta)\)</span>. In this case, we use the
class <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AllSinglesDoubles.html#pennylane.AllSinglesDoubles" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">AllSinglesDoubles</span></code></a>, which enables us to apply all possible combinations of single and
double excitations obeying the Pauli principle to the Hartree-Fock
state. Single and double excitation gates, denoted <span class="math notranslate nohighlight">\(G^{(1)}(\Theta)\)</span> and <span class="math notranslate nohighlight">\(G^{(2)}(\Theta)\)</span> respectively, are
conveniently implemented in PennyLane with <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.SingleExcitation.html#pennylane.SingleExcitation" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SingleExcitation</span></code></a>
and <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.DoubleExcitation.html#pennylane.DoubleExcitation" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoubleExcitation</span></code></a> classes. You can find more information
about how these gates work in this <a class="reference external" href="https://youtu.be/4Xnxa6tzPeA">video</a> and in the demo <a class="reference internal" href="tutorial_givens_rotations.html"><span class="doc">Givens rotations for quantum chemistry</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">singles</span><span class="p">,</span> <span class="n">doubles</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.qchem.excitations.html#pennylane.qchem.excitations" title="pennylane.qchem.excitations" class="sphx-glr-backref-module-pennylane-qchem sphx-glr-backref-type-py-function"><span class="n">qchem</span><span class="o">.</span><span class="n">excitations</span></a><span class="p">(</span><span class="n">electrons</span><span class="o">=</span><span class="n">electrons</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>
<span class="n">num_theta</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">singles</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">doubles</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">circuit_VQE</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">,</span> <span class="n">wires</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AllSinglesDoubles.html#pennylane.AllSinglesDoubles" title="pennylane.AllSinglesDoubles" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">AllSinglesDoubles</span></a><span class="p">(</span><span class="n">weights</span><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hf_state</span></a><span class="o">=</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hf</span></a><span class="p">,</span> <span class="n">singles</span><span class="o">=</span><span class="n">singles</span><span class="p">,</span> <span class="n">doubles</span><span class="o">=</span><span class="n">doubles</span><span class="p">)</span>
</pre></div>
</div>
<p>Once this is defined, we can run the VQE algorithm. We first need to
define a circuit for the cost function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cost_fn</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">):</span>
    <span class="n">circuit_VQE</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">)</span>
</pre></div>
</div>
<p>We then fix the classical optimization parameters <code class="docutils literal notranslate"><span class="pre">stepsize</span></code> and
<code class="docutils literal notranslate"><span class="pre">max_iteration</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stepsize</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">30</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.GradientDescentOptimizer.html#pennylane.GradientDescentOptimizer" title="pennylane.GradientDescentOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">opt</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.GradientDescentOptimizer.html#pennylane.GradientDescentOptimizer" title="pennylane.GradientDescentOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">GradientDescentOptimizer</span></a><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="n">stepsize</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_theta</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we run the algorithm.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">,</span> <span class="n">prev_energy</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.GradientDescentOptimizer.html#pennylane.GradientDescentOptimizer.step_and_cost" title="pennylane.GradientDescentOptimizer.step_and_cost" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">opt</span><span class="o">.</span><span class="n">step_and_cost</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_fn</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">samples</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_fn</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">energy_VQE</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_fn</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta_opt</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta</span></a>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;VQE energy: </span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">energy_VQE</span></a><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal parameters:&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta_opt</span></a><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>VQE energy: -1.1362
Optimal parameters: [0.         0.         0.20973221]
</pre></div>
</div>
<p>Note that as an output we obtain the VQE approximation to the ground
state energy and a set of optimized parameters <span class="math notranslate nohighlight">\(\Theta\)</span> that
define the ground state through the ansatz <span class="math notranslate nohighlight">\(A(\Theta)\)</span>. We will need
to save these two quantities, as they are necessary to implement CB-VQE
in the following steps.</p>
</div>
<div class="section" id="classically-boosted-vqe">
<h2>Classically-Boosted VQE<a class="headerlink" href="#classically-boosted-vqe" title="Permalink to this headline">¶</a></h2>
<p>Now we are ready to present the classically-boosted version of VQE.</p>
<p>The key of this new method relies on the notion of the
<a class="reference external" href="https://en.wikipedia.org/wiki/Generalized_eigenvalue_problem">generalized eigenvalue problem</a>.
The main idea is to restrict the problem of finding the ground state to
an eigenvalue problem in a subspace <span class="math notranslate nohighlight">\(\mathcal{H}^{\prime}\)</span> of the
complete Hilbert space <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>. If this subspace is spanned
by a combination of both classical and quantum states, we can run parts
of our algorithm on classical hardware and thus reduce the number of
measurements needed to reach a certain precision threshold. The generalized
eigenvalue problem is expressed as</p>
<div class="math notranslate nohighlight">
\[\bar{H} \vec{v}=  \lambda \bar{S} \vec{v},\]</div>
<p>where the matrix <span class="math notranslate nohighlight">\(\bar{S}\)</span> contains the overlaps between the basis states and <span class="math notranslate nohighlight">\(\bar{H}\)</span>
is the Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> projected into the
subspace of interest, i.e. with the entries</p>
<div class="math notranslate nohighlight">
\[\bar{H}_{\alpha, \beta} = \langle \phi_\alpha \vert H \vert \phi_\beta \rangle,\]</div>
<p>for all <span class="math notranslate nohighlight">\(\vert \phi_\alpha \rangle\)</span> and <span class="math notranslate nohighlight">\(\vert \phi_\beta \rangle\)</span> in <span class="math notranslate nohighlight">\(\mathcal{H}^{\prime}\)</span>.
For a complete orthonormal basis, the overlap matrix
<span class="math notranslate nohighlight">\(\bar{S}\)</span> would simply be the identity matrix. However, we need to
take a more general approach which works for a subspace spanned by
potentially non-orthogonal states. We can retrieve the representation of
<span class="math notranslate nohighlight">\(S\)</span> by calculating</p>
<div class="math notranslate nohighlight">
\[\bar{S}_{\alpha, \beta} = \langle \phi_\alpha \vert \phi_\beta \rangle,\]</div>
<p>for all <span class="math notranslate nohighlight">\(\vert \phi_\alpha \rangle\)</span> and <span class="math notranslate nohighlight">\(\vert \phi_\beta \rangle\)</span> in <span class="math notranslate nohighlight">\(\mathcal{H}^{\prime}\)</span>.
Finally, note that <span class="math notranslate nohighlight">\(\vec{v}\)</span> and <span class="math notranslate nohighlight">\(\lambda\)</span> are the eigenvectors and
eigenvalues respectively. Our goal is to find the lowest
eigenvalue <span class="math notranslate nohighlight">\(\lambda_0.\)</span></p>
<p>Equipped with the useful mathematical description of generalized
eigenvalue problems, we can now choose our subspace such that some of
the states <span class="math notranslate nohighlight">\(\vert \phi_{\alpha} \rangle \in \mathcal{H}^{\prime}\)</span> are
classically tractable.</p>
<p>We will consider the simplest case in which the subspace is spanned only
by one classical state <span class="math notranslate nohighlight">\(\vert \phi_{HF} \rangle\)</span> and one quantum
state <span class="math notranslate nohighlight">\(\vert \phi_{q} \rangle\)</span>. More precisely, we define the
classical state to be a single
<a class="reference external" href="https://en.wikipedia.org/wiki/Slater_determinant">Slater determinant</a>,
which directly hints towards using the <em>Hartree-Fock</em> state for several
reasons. First of all, it is well-known that the Hartree-Fock state is a
good candidate to approximate the ground state in the mean-field limit.
Secondly, we already computed it when we built the molecular Hamiltonian
for the standard VQE!</p>
<p>To summarize, our goal is to build the Hamiltonian <span class="math notranslate nohighlight">\(\bar{H}\)</span> and
the overlap matrix <span class="math notranslate nohighlight">\(\bar{S}\)</span>, which act on the subspace
<span class="math notranslate nohighlight">\(\mathcal{H}^{\prime} \subseteq \mathcal{H}\)</span> spanned by
<span class="math notranslate nohighlight">\(\{\vert \phi_{HF} \rangle, \vert \phi_q \rangle\}\)</span>. These will be
two-dimensional matrices, and in the following sections we will show how
to compute all their entries step by step.</p>
<p>As done previously, we start by importing <em>PennyLane</em>, <em>Qchem</em> and
differentiable <em>NumPy</em> followed by defining the molecular Hamiltonian in
the Hartree-Fock basis for <span class="math notranslate nohighlight">\(H_2\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">]</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">coordinates</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6614</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.6614</span><span class="p">])</span>
<span class="n">basis_set</span> <span class="o">=</span> <span class="s2">&quot;sto-3g&quot;</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">,</span> <span class="n">qubits</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.qchem.molecular_hamiltonian.html#pennylane.qchem.molecular_hamiltonian" title="pennylane.qchem.molecular_hamiltonian" class="sphx-glr-backref-module-pennylane-qchem sphx-glr-backref-type-py-function"><span class="n">qchem</span><span class="o">.</span><span class="n">molecular_hamiltonian</span></a><span class="p">(</span>
    <span class="n">symbols</span><span class="p">,</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">coordinates</span></a><span class="p">,</span>
    <span class="n">basis</span><span class="o">=</span><span class="n">basis_set</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="section" id="computing-classical-quantities">
<h3>Computing Classical Quantities<a class="headerlink" href="#computing-classical-quantities" title="Permalink to this headline">¶</a></h3>
<p>We first set out to calculate the purely classical part of the
Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>. Since we only have one classical state this will
already correspond to a scalar energy value. The terms can be expressed
as</p>
<div class="math notranslate nohighlight">
\[H_{11} = \langle \phi_{HF} \vert H \vert \phi_{HF} \rangle \quad \text{and} \quad S_{11} = \langle \phi_{HF} \vert \phi_{HF} \rangle\]</div>
<p>which is tractable using classical methods. This energy corresponds to
the Hartree-Fock energy due to our convenient choice of the classical
state. Note that the computation of the classical component of the
overlap matrix
<span class="math notranslate nohighlight">\(S_{11} = \langle \phi_{HF} \vert \phi_{HF} \rangle = 1\)</span> is
trivial.</p>
<p>Using PennyLane, we can access the Hartree-Fock energy by looking at the
fermionic Hamiltonian, which is the Hamiltonian on the basis of Slater
determinants. The basis is organized in lexicographic order, meaning
that if we want the entry corresponding to the Hartree-Fock determinant
<span class="math notranslate nohighlight">\(\vert 1100 \rangle\)</span>, we will have to take the entry
<span class="math notranslate nohighlight">\(H_{i,i}\)</span>, where <span class="math notranslate nohighlight">\(1100\)</span> is the binary representation of the
index <span class="math notranslate nohighlight">\(i\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hf_state</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.qchem.hf_state.html#pennylane.qchem.hf_state" title="pennylane.qchem.hf_state" class="sphx-glr-backref-module-pennylane-qchem sphx-glr-backref-type-py-function"><span class="n">qchem</span><span class="o">.</span><span class="n">hf_state</span></a><span class="p">(</span><span class="n">electrons</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>
<span class="n">fermionic_Hamiltonian</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span><span class="o">.</span><span class="n">sparse_matrix</span></a><span class="p">()</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>

<span class="c1"># we first convert the HF slater determinant to a string</span>
<span class="n">binary_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hf_state</span></a><span class="p">])</span>
<span class="c1"># we then obtain the integer corresponding to its binary representation</span>
<span class="n">idx0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">binary_string</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># finally we access the entry that corresponds to the HF energy</span>
<span class="n">H11</span> <span class="o">=</span> <span class="n">fermionic_Hamiltonian</span><span class="p">[</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx0</span><span class="p">]</span>
<span class="n">S11</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-quantum-quantities">
<h3>Computing Quantum Quantities<a class="headerlink" href="#computing-quantum-quantities" title="Permalink to this headline">¶</a></h3>
<p>We now move on to the purely quantum part of the Hamiltonian, i.e. the
entry</p>
<div class="math notranslate nohighlight">
\[H_{22} = \langle \phi_{q} \vert H \vert \phi_{q} \rangle,\]</div>
<p>where <span class="math notranslate nohighlight">\(\vert \phi_q \rangle\)</span> is the quantum state. This state is
just the output of the standard VQE with a given ansatz, following the
steps in the first section. Therefore, the entry <span class="math notranslate nohighlight">\(H_{22}\)</span> just
corresponds to the final energy of the VQE. In particular, note that the
quantum state can be written as
<span class="math notranslate nohighlight">\(\vert \phi_{q} \rangle = A(\Theta^*) \vert \phi_{HF} \rangle\)</span>
where <span class="math notranslate nohighlight">\(A(\Theta^*)\)</span> is the ansatz of the VQE with the optimised
parameters <span class="math notranslate nohighlight">\(\Theta^*\)</span>. Once again, we have
<span class="math notranslate nohighlight">\(S_{22}=\langle \phi_{q} \vert \phi_{q} \rangle = 1\)</span> for the
overlap matrix.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H22</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">energy_VQE</span></a>
<span class="n">S22</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-mixed-quantities">
<h3>Computing Mixed Quantities<a class="headerlink" href="#computing-mixed-quantities" title="Permalink to this headline">¶</a></h3>
<p>The final part of the algorithm computes the cross-terms between the
classical and quantum state</p>
<div class="math notranslate nohighlight">
\[H_{12} = \langle \phi_{HF} \vert H \vert \phi_{q} \rangle = H_{21}^{\dagger}.\]</div>
<p>This part of the algorithm is slightly more complicated than the
previous steps, since we still want to make use of the classical component
of the problem in order to minimize the number of required measurements.</p>
<p>Keep in mind that most algorithms usually perform computations either on
fully classically or quantum tractable Hilbert spaces. CB-VQE takes
advantage of the classical part of the problem while still calculating a
classically-intractable quantity by using the so-called
<a class="reference external" href="https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)">Hadamard test</a>
to construct <span class="math notranslate nohighlight">\(H_{12}\)</span>. The Hadamard test is a prime example of an
indirect measurement, which allows us to measure properties of a state
without (completely) destroying it.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/boosted_hadamard_test.png"><img alt="../_images/boosted_hadamard_test.png" src="../_images/boosted_hadamard_test.png" style="width: 50%;" /></a>
</div>
<p>As the Hadamard test returns the real part of a coefficient from a unitary representing
an operation, we will focus on calculating the quantities</p>
<div class="math notranslate nohighlight">
\[H_{12} = \sum_{i} Re(\langle \phi_q \vert i \rangle) \langle i \vert H \vert \phi_{HF} \rangle,\]</div>
<div class="math notranslate nohighlight">
\[S_{12} = Re(\langle \phi_q \vert \phi_{HF} \rangle),\]</div>
<p>where <span class="math notranslate nohighlight">\(\lvert i \rangle\)</span> are the computational basis states of the system,
i.e. the basis of single Slater determinants. Note that we have to decompose the Hamiltonian
into a sum of unitaries. For the problem under consideration, the set of relevant computational basis states for which
<span class="math notranslate nohighlight">\(\langle i \vert H \vert \phi_{HF}\rangle \neq 0\)</span> contains all the
single and double excitations (allowed by spin symmetries), namely, the states</p>
<div class="math notranslate nohighlight">
\[\vert 1100 \rangle, \vert 1001 \rangle, \vert 0110 \rangle, \vert 0011 \rangle.\]</div>
<p>Specifically, the set of computational basis states includes the
<em>Hartree-Fock</em> state <span class="math notranslate nohighlight">\(\lvert i_0 \rangle = \vert \phi_{HF} \rangle = \vert 1100 \rangle\)</span> and the
projections <span class="math notranslate nohighlight">\(\langle i \vert H \vert \phi_{HF} \rangle\)</span> can be
extracted analytically from the fermionic Hamiltonian that we computed
above. This is done by accessing the entries by the index given by the binary
expression of each Slater determinant.</p>
<p>The Hadamard test is required to compute the real part of
<span class="math notranslate nohighlight">\(\langle \phi_q \vert i \rangle\)</span>.</p>
<p>To implement the Hadamard test, we need a register of <span class="math notranslate nohighlight">\(n\)</span> qubits
given by the size of the molecular Hamiltonian (<span class="math notranslate nohighlight">\(n=4\)</span> in our case)
initialized in the state <span class="math notranslate nohighlight">\(\rvert 0 \rangle^{\otimes n}\)</span> and an ancillary
qubit prepared in the <span class="math notranslate nohighlight">\(\rvert 0 \rangle\)</span> state.</p>
<p>In order to generate <span class="math notranslate nohighlight">\(\langle \phi_q \vert i \rangle\)</span>, we take
<span class="math notranslate nohighlight">\(U_q\)</span> such that
<span class="math notranslate nohighlight">\(U_q \vert 0 \rangle^{\otimes n} = \vert \phi_q \rangle\)</span>.
This is equivalent to using the standard VQE ansatz with the optimized
parameters <span class="math notranslate nohighlight">\(\Theta^*\)</span> that we obtained in the previous section
<span class="math notranslate nohighlight">\(U_q = A(\Theta^*)\)</span>. Moreover,
we also need <span class="math notranslate nohighlight">\(U_i\)</span> such that
<span class="math notranslate nohighlight">\(U_i \vert 0^n \rangle = \vert \phi_i \rangle\)</span>. In this case, this
is just a mapping of a classical basis state into the circuit consisting
of <span class="math notranslate nohighlight">\(X\)</span> gates and can be easily implemented using PennyLane’s
function <code class="docutils literal notranslate"><span class="pre">qml.BasisState(i,</span> <span class="pre">n))</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wires</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">qubits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hadamard_test</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Uq</span></a><span class="p">,</span> <span class="n">Ucl</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s2">&quot;real&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;imag&quot;</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.ControlledQubitUnitary.html#pennylane.ControlledQubitUnitary" title="pennylane.ControlledQubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">ControlledQubitUnitary</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Uq</span></a><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Ucl</span><span class="p">,</span> <span class="n">control_wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wires</span><span class="o">=</span><span class="n">wires</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.probs.html#pennylane.probs" title="pennylane.probs" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">probs</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Now, we are ready to compute the Hamiltonian
cross-terms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">circuit_product_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.BasisState.html#pennylane.BasisState" title="pennylane.BasisState" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">BasisState</span></a><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Uq</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><span class="n">circuit_VQE</span><span class="p">)(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">theta_opt</span></a><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H12</span></a> <span class="o">=</span> <span class="mi">0</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">relevant_basis_states</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis_state</span></a> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">relevant_basis_states</span></a><span class="p">):</span>
    <span class="n">Ucl</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><span class="n">circuit_product_state</span><span class="p">)(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis_state</span></a><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probs</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">hadamard_test</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Uq</span></a><span class="p">,</span> <span class="n">Ucl</span><span class="p">)</span>
    <span class="c1"># The projection Re(&lt;phi_q|i&gt;) corresponds to 2p-1</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y</span></a> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">probs</span></a><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># We retrieve the quantities &lt;i|H|HF&gt; from the fermionic Hamiltonian</span>
    <span class="n">binary_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">basis_state</span></a><span class="p">])</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">binary_string</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">overlap_H</span> <span class="o">=</span> <span class="n">fermionic_Hamiltonian</span><span class="p">[</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
    <span class="c1"># We sum over all computational basis states</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H12</span></a> <span class="o">+=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y</span></a> <span class="o">*</span> <span class="n">overlap_H</span>
    <span class="c1"># y0 corresponds to Re(&lt;phi_q|HF&gt;)</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y0</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y</span></a>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H21</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H12</span></a><span class="p">)</span>
</pre></div>
</div>
<p>The cross terms of the <span class="math notranslate nohighlight">\(S\)</span> matrix are defined making
use of the projections with the <em>Hartree-Fock</em> state.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S12</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y0</span></a>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S21</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">y0</span></a><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-the-generalized-eigenvalue-problem">
<h3>Solving the generalized eigenvalue problem<a class="headerlink" href="#solving-the-generalized-eigenvalue-problem" title="Permalink to this headline">¶</a></h3>
<p>We are ready to solve the generalized eigenvalue problem. For
this, we will build the matrices <span class="math notranslate nohighlight">\(H\)</span> and <span class="math notranslate nohighlight">\(S\)</span> and use <cite>scipy</cite>
to obtain the lowest eigenvalue.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">S11</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S12</span></a><span class="p">],</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S21</span></a><span class="p">,</span> <span class="n">S22</span><span class="p">]])</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">H11</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H12</span></a><span class="p">],</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H21</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H22</span></a><span class="p">]])</span>

<span class="n">evals</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">H</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">S</span></a><span class="p">)</span>
<span class="n">energy_CBVQE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CB-VQE energy </span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">energy_CBVQE</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>CB-VQE energy -1.1362
</pre></div>
</div>
</div>
</div>
<div class="section" id="measurement-analysis">
<h2>Measurement analysis<a class="headerlink" href="#measurement-analysis" title="Permalink to this headline">¶</a></h2>
<p>CB-VQE is helpful when it comes to reducing the number of measurements
that are required to reach a given precision in the ground state energy.
In fact, for very small systems it can be shown that the classically-boosted method
reduces the number of required measurements by a factor of <span class="math notranslate nohighlight">\(1000\)</span> <a class="footnote-reference brackets" href="#radin2021" id="id2">1</a>.</p>
<p>Let’s see if this is the case for the example above.
Now that we know how to run standard VQE and CB-VQE algorithms, we can re-run the code above
for a finite number of measurements. This is done by specifying the number of
shots in the definition of the devices, for example, <code class="docutils literal notranslate"><span class="pre">num_shots</span> <span class="pre">=</span> <span class="pre">20</span></code>. By doing this, Pennylane
will output the expectation value of the energy computed from a sample of 20 measurements.
Then, we simply run both VQE and CB-VQE enough times to obtain statistics on the results.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/energy_deviation.png"><img alt="../_images/energy_deviation.png" src="../_images/energy_deviation.png" style="width: 80%;" /></a>
</div>
<p>In the plot above, the dashed line corresponds to the true ground state energy of the <span class="math notranslate nohighlight">\(H_2\)</span> molecule.
In the x-axis we represent the number of measurements that are used to compute the expected value of the
Hamiltonian (<cite>num_shots</cite>). In the y-axis, we plot the mean value and the standard deviation of the energies
obtained from a sample of 100 circuit evaluations.
As expected, CB-VQE leads to a better approximation of the ground state energy - the mean energies are lower-
and, most importantly, to a much smaller standard deviation, improving on the results given
by standard VQE by several orders of magnitude when considering a small number of measurements.
As expected, for a large number of measurements both algorithms start to converge to similar
results and the standard deviation decreases.</p>
<p><cite>Note: In order to obtain these results, we had to discard the samples in which the VQE shot noise
underestimated the true ground state energy of the problem, since this was leading to large
variances in the CB-VQE estimation of the energy.</cite></p>
</div>
<div class="section" id="conclusions">
<h2>Conclusions<a class="headerlink" href="#conclusions" title="Permalink to this headline">¶</a></h2>
<p>In this demo, we have learnt how to implement the CB-VQE algorithm in PennyLane. Furthermore, it was observed that we require
fewer measurements to be executed on a quantum computer to reach the same accuracy as standard VQE.
Such algorithms could be executed on smaller quantum computers, potentially allowing us to implement useful
quantum algorithms on real hardware sooner than expected.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="radin2021"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span></dt>
<dd><p>M. D. Radin. (2021) “Classically-Boosted Variational Quantum Eigensolver”,
<a class="reference external" href="https://arxiv.org/abs/2106.04755">arXiv:2106.04755 [quant-ph]</a> (2021)</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/joana_fraxanet.jpeg" alt="Joana Fraxanet" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Joana Fraxanet</h4>
        <p class="bio-text__author-description">Joana is a PhD student at The Institute of Photonic Sciences in Barcelona, where she studies quantum many-body systems. She is also currently working as a summer resident at Xanadu.</p>
    </div>
</div><div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/isidor_schoch.png" alt="Isidor Schoch" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Isidor Schoch</h4>
        <p class="bio-text__author-description">Isidor is a Quantum Engineering MSc student at ETH Zurich. He is passionate about exploring the connections between mathematics, physics and computer science. Besides his studies, he currently also works in the PennyLane performance team as a summer resident.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  2.328 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-classically-boosted-vqe-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/1dfa77d0d2e55d711e604db440d5a3bd/tutorial_classically_boosted_vqe.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_classically_boosted_vqe.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/b9a8a8a195c6f960d8b880f8081aa9bc/tutorial_classically_boosted_vqe.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_classically_boosted_vqe.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_classically_boosted_vqe</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Classically-Boosted Variational Quantum Eigensolver</a><ul class='current'>
<li class='current'><a class="reference internal" href="#prerequisites-standard-vqe">Prerequisites: Standard VQE</a></li>
<li class='current'><a class="reference internal" href="#classically-boosted-vqe">Classically-Boosted VQE</a><ul class='current'>
<li class='current'><a class="reference internal" href="#computing-classical-quantities">Computing Classical Quantities</a></li>
<li class='current'><a class="reference internal" href="#computing-quantum-quantities">Computing Quantum Quantities</a></li>
<li class='current'><a class="reference internal" href="#computing-mixed-quantities">Computing Mixed Quantities</a></li>
<li class='current'><a class="reference internal" href="#solving-the-generalized-eigenvalue-problem">Solving the generalized eigenvalue problem</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#measurement-analysis">Measurement analysis</a></li>
<li class='current'><a class="reference internal" href="#conclusions">Conclusions</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_classically_boosted_vqe</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_quantum-chemistry.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_qchem_external.html" title="Using PennyLane with PySCF and OpenFermion"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_qubit_tapering.html" title="Qubit tapering"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-chemistry.html" >Quantum Chemistry</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Classically-Boosted Variational Quantum Eigensolver</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>