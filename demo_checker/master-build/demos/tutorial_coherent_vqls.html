
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="This demonstration extends the variational quantum linear solver to solve linear equations defined by a probabilistic coherent operation." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/cvqls_zoom.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Coherent Variational Quantum Linear Solver &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_coherent_vqls.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="This demonstration extends the variational quantum linear solver to solve linear equations defined by a probabilistic coherent operation." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Coherent Variational Quantum Linear Solver &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_coherent_vqls.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Optimizing a quantum optical neural network" href="qonn.html" />
    <link rel="prev" title="Variational Quantum Linear Solver" href="tutorial_vqls.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="qonn.html" title="Optimizing a quantum optical neural network"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_vqls.html" title="Variational Quantum Linear Solver"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" accesskey="U">Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Coherent Variational Quantum Linear Solver</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-coherent-vqls-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="coherent-variational-quantum-linear-solver">
<span id="coherent-vqls"></span><span id="sphx-glr-demos-tutorial-coherent-vqls-py"></span><h1>Coherent Variational Quantum Linear Solver<a class="headerlink" href="#coherent-variational-quantum-linear-solver" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_vqls.html"];
    var related_tutorials_titles = ['Variational Quantum Linear Solver'];
</script></p>
<p><em>Author: Andrea Mari — 06 November 2019. Last updated: 15 January 2021.</em></p>
<p>In this tutorial we propose and implement an algorithm that we call
<em>coherent variational quantum linear solver</em> (CVQLS).
This is inspired by the VQLS proposed in Ref. [1] (implemented in a <a class="reference internal" href="tutorial_vqls.html"><span class="doc">previous demo</span></a>), with an important difference:
the matrix <span class="math notranslate nohighlight">\(A\)</span> associated to the problem is physically
applied as a probabilistic coherent operation. This approach has some advantages and
disadvantages and its practical convenience depends on the specific linear problem
to be solved and on experimental constraints.</p>
<div class="figure align-center">
<a class="reference external image-reference" href="javascript:void(0)"><img alt="../_images/cvqls_circuit.png" src="../_images/cvqls_circuit.png" style="width: 100%;" /></a>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>We first define the problem and the general structure of the CVQLS.
As a second step, we consider a particular case and we solve it explicitly with PennyLane.</p>
<div class="section" id="the-problem">
<h3>The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h3>
<p>We are given a <span class="math notranslate nohighlight">\(2^n \times 2^n\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span> which can be expressed as a linear
combination of <span class="math notranslate nohighlight">\(L\)</span> unitary matrices <span class="math notranslate nohighlight">\(A_0, A_1, \dots A_{L-1}\)</span>, i.e.,</p>
<div class="math notranslate nohighlight">
\[A = \sum_{l=0}^{L-1} c_l A_l,\]</div>
<p>where <span class="math notranslate nohighlight">\(c_l\)</span> are arbitrary complex numbers. Importantly, we assume that each of the
unitary components <span class="math notranslate nohighlight">\(A_l\)</span> can be efficiently implemented with a quantum circuit
acting on <span class="math notranslate nohighlight">\(n\)</span> qubits.</p>
<p>We are also given a normalized complex vector in the physical form of a quantum
state <span class="math notranslate nohighlight">\(|b\rangle\)</span>, which can be generated by a unitary operation <span class="math notranslate nohighlight">\(U\)</span>
applied to the ground state of <span class="math notranslate nohighlight">\(n\)</span> qubits. , i.e.,</p>
<div class="math notranslate nohighlight">
\[|b\rangle = U_b |0\rangle,\]</div>
<p>where again we assume that <span class="math notranslate nohighlight">\(U_b\)</span> can be efficiently implemented with a quantum circuit.</p>
<p>The problem that we aim to solve is that of preparing a quantum state <span class="math notranslate nohighlight">\(|x\rangle\)</span>, such that
<span class="math notranslate nohighlight">\(A |x\rangle\)</span> is proportional to <span class="math notranslate nohighlight">\(|b\rangle\)</span> or, equivalently, such that</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle :=  \frac{A |x\rangle}{\sqrt{\langle x |A^\dagger A |x\rangle}} \approx |b\rangle.\]</div>
</div>
<div class="section" id="coherent-variational-quantum-linear-solver-cvqls">
<h3>Coherent Variational Quantum Linear Solver (CVQLS)<a class="headerlink" href="#coherent-variational-quantum-linear-solver-cvqls" title="Permalink to this headline">¶</a></h3>
<p>We approximate the solution <span class="math notranslate nohighlight">\(|x\rangle\)</span> with a variational quantum
circuit, i.e., a unitary circuit <span class="math notranslate nohighlight">\(V\)</span> depending on a finite number of classical real parameters
<span class="math notranslate nohighlight">\(w = (w_0, w_1, \dots)\)</span>:</p>
<div class="math notranslate nohighlight">
\[|x \rangle = V(w) |0\rangle.\]</div>
<p>The parameters should be optimized in order to maximize the overlap between the quantum states
<span class="math notranslate nohighlight">\(|\Psi\rangle\)</span> and <span class="math notranslate nohighlight">\(|b\rangle\)</span>. We define the following cost function,</p>
<div class="math notranslate nohighlight">
\[C = 1- |\langle b | \Psi \rangle|^2,\]</div>
<p>such that its minimization with respect to the variational parameters should lead towards the problem solution.</p>
<p>The approach used in Ref. [1] is to decompose the cost function in terms of many expectation values associated to the
individual components <span class="math notranslate nohighlight">\(A_l\)</span> of the problem matrix <span class="math notranslate nohighlight">\(A\)</span>. For this reason, in the VQLS of Ref. [1],
the state vector proportional to <span class="math notranslate nohighlight">\(A |x\rangle\)</span> is not physically prepared.
On the contrary, the idea presented in this tutorial is to physically implement the linear map <span class="math notranslate nohighlight">\(A\)</span> as
a coherent probabilistic operation. This approach allows to prepare the state
<span class="math notranslate nohighlight">\(|\Psi\rangle :=  A |x\rangle/\sqrt{\langle x |A^\dagger A |x\rangle}\)</span> which can be used to estimate the
cost function of the problem in a more direct way.</p>
<div class="section" id="coherently-applying-a">
<h4>Coherently applying <span class="math notranslate nohighlight">\(A\)</span><a class="headerlink" href="#coherently-applying-a" title="Permalink to this headline">¶</a></h4>
<p>The problem of coherently applying a liner combination of unitary operations has been already studied in Ref. [2]
and here we follow a very similar approach.</p>
<p>Without loss of generality we can assume that the coefficients <span class="math notranslate nohighlight">\(c=(c_1, c_2, \dots c_L)\)</span> appearing
in the definition of <span class="math notranslate nohighlight">\(A\)</span> represent a positive and normalized probability distribution, i.e.,</p>
<div class="math notranslate nohighlight">
\[c_l \ge 0 \quad \forall l,  \qquad \sum_{l=0}^{L-1} c_l=1.\]</div>
<p>Indeed the complex phase of each coefficient <span class="math notranslate nohighlight">\(c_l\)</span> can always be absorbed into the associated unitary <span class="math notranslate nohighlight">\(A_l\)</span>, obtaining
in this way a vector of positive values. Moreover, since the linear problem is
defined up to a constant scaling factor, we can also normalize the coefficients to get a probability distribution.</p>
<p>For simplicity, since we can always pad <span class="math notranslate nohighlight">\(c\)</span> with additional zeros, we assume that <span class="math notranslate nohighlight">\(L=2^m\)</span> for some positive integer <span class="math notranslate nohighlight">\(m\)</span>.</p>
<p>Let us consider a unitary circuit <span class="math notranslate nohighlight">\(U_c\)</span>, embedding the square root of <span class="math notranslate nohighlight">\(c\)</span> into the quantum state <span class="math notranslate nohighlight">\(|\sqrt{c}\rangle\)</span> of <span class="math notranslate nohighlight">\(m\)</span> ancillary qubits:</p>
<div class="math notranslate nohighlight">
\[|\sqrt{c} \rangle =  U_c |0\rangle = \sum_{l=0}^{L-1} \sqrt{c_l} | l \rangle,\]</div>
<p>where <span class="math notranslate nohighlight">\(\{ |l\rangle \}\)</span> is the computational basis of the ancillary system.</p>
<p>Now, for each component <span class="math notranslate nohighlight">\(A_l\)</span> of the problem matrix <span class="math notranslate nohighlight">\(A\)</span>, we can define an associated controlled unitary operation <span class="math notranslate nohighlight">\(CA_l\)</span>,
acting on the system and on the ancillary basis states as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}CA_l \, |j\rangle |l' \rangle  =
\Bigg\{
\begin{array}{c}
\left(A_l \otimes \mathbb{I}\right) \; |j\rangle |l \rangle \quad \; \mathrm{for}\; l'=l \\
\qquad \qquad |j\rangle |l' \rangle  \quad \mathrm{for}\; l'\neq l
\end{array},\end{split}\]</div>
<p>i.e., the unitary <span class="math notranslate nohighlight">\(A_l\)</span> is applied only when the ancillary system is in the corresponding basis state <span class="math notranslate nohighlight">\(|l\rangle\)</span>.</p>
<p>A natural generalization of the <a class="reference external" href="https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)">Hadamard test</a>, to the case of multiple unitary operations, is the following
(see also the figure at the top of this tutorial):</p>
<ol class="arabic simple">
<li><p>Prepare all qubits in the ground state.</p></li>
<li><p>Apply <span class="math notranslate nohighlight">\(U_c\)</span> to the ancillary qubits.</p></li>
<li><p>Apply the variational circuit <span class="math notranslate nohighlight">\(V\)</span> to the system qubits.</p></li>
<li><p>Apply all the controlled unitaries <span class="math notranslate nohighlight">\(CA_l\)</span> for all values of <span class="math notranslate nohighlight">\(l\)</span>.</p></li>
<li><p>Apply <span class="math notranslate nohighlight">\(U_c^\dagger\)</span> to the ancillary qubits.</p></li>
<li><p>Measure the ancillary qubits in the computational basis.</p></li>
<li><p>If the outcome of the measurement is the ground state, the system collapses to
<span class="math notranslate nohighlight">\(|\Psi\rangle :=  A |x\rangle/\sqrt{\langle x |A^\dagger A |x\rangle}\)</span>.
If the outcome is not the ground state, the experiment should be repeated.</p></li>
</ol>
</div>
<div class="section" id="estimating-the-cost-function">
<h4>Estimating the cost function<a class="headerlink" href="#estimating-the-cost-function" title="Permalink to this headline">¶</a></h4>
<p>From a technical point of view, the previous steps represent the most difficult part of the algorithm.
Once we have at our disposal the quantum system prepared in the state <span class="math notranslate nohighlight">\(|\Psi\rangle\)</span>,
it is very easy to compute the cost function.
Indeed one could simply continue the previous protocol with the following two steps:</p>
<ol class="arabic simple" start="8">
<li><p>Apply <span class="math notranslate nohighlight">\(U_b^\dagger\)</span> to the system.</p></li>
<li><p>Measure the system in the computational basis. The probability of finding it
in the ground state (given the ancillary qubits measured in their ground state),
is <span class="math notranslate nohighlight">\(|\langle 0 | U_b^\dagger |\Psi \rangle|^2 = |\langle b | \Psi \rangle|^2\)</span>.</p></li>
</ol>
<p>So, with sufficiently many shots of the previous experiment, one can directly estimate
the cost function of the problem.</p>
<p>Importantly, the operations of steps 7 and 8 commute. Therefore all the measurements can be
delayed until the end of the quantum circuit (as shown in the figure at the top of this tutorial),
making the structure of the experiment more straightforward.</p>
</div>
</div>
<div class="section" id="a-simple-example">
<h3>A simple example<a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h3>
<p>In this tutorial we apply the previous theory to the following simple example
based on a system of 3 qubits, which was already considered in Ref. [1] and also reproduced in PennyLane (<a class="reference internal" href="tutorial_vqls.html"><span class="doc">VQLS</span></a>):</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A  &amp;=  c_0 A_0 + c_1 A_1 + c_2 A_2 = \mathbb{I} + 0.2 X_0 Z_1 + 0.2 X_0, \\
\\
|b\rangle &amp;= U_b |0 \rangle = H_0  H_1  H_2 |0\rangle,
\end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(Z_j, X_j, H_j\)</span> represent the Pauli <span class="math notranslate nohighlight">\(Z\)</span>, Pauli <span class="math notranslate nohighlight">\(X\)</span> and Hadamard gates applied to the qubit with index <span class="math notranslate nohighlight">\(j\)</span>.</p>
<p>This problem is computationally quite easy since a single layer of local rotations is enough to generate the
solution state, i.e., we can use the following simple ansatz:</p>
<div class="math notranslate nohighlight">
\[|x\rangle = V(w) |0\rangle = \Big [  R_y(w_0) \otimes  R_y(w_1) \otimes  R_y(w_2) \Big ]  H_0  H_1  H_2 |0\rangle.\]</div>
<p>In the code presented below we solve this particular problem, by following the general scheme of the CVQLS previously discussed.
Eventually we will compare the quantum solution with the classical one.</p>
</div>
</div>
<div class="section" id="general-setup">
<h2>General setup<a class="headerlink" href="#general-setup" title="Permalink to this headline">¶</a></h2>
<p>This Python code requires <em>PennyLane</em> and the plotting library <em>matplotlib</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="section" id="setting-of-the-main-hyper-parameters-of-the-model">
<h3>Setting of the main hyper-parameters of the model<a class="headerlink" href="#setting-of-the-main-hyper-parameters-of-the-model" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_qubits</span> <span class="o">=</span> <span class="mi">3</span>                <span class="c1"># Number of system qubits</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">2</span>                       <span class="c1"># Number of ancillary qubits</span>
<span class="n">n_shots</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span>           <span class="c1"># Number of quantum measurements</span>
<span class="n">tot_qubits</span> <span class="o">=</span> <span class="n">n_qubits</span> <span class="o">+</span> <span class="n">m</span>   <span class="c1"># System + ancillary qubits</span>
<span class="n">ancilla_idx</span> <span class="o">=</span> <span class="n">n_qubits</span>      <span class="c1"># Index of the first ancillary qubit</span>
<span class="n">steps</span> <span class="o">=</span> <span class="mi">10</span>                  <span class="c1"># Number of optimization steps</span>
<span class="n">eta</span> <span class="o">=</span> <span class="mf">0.8</span>                   <span class="c1"># Learning rate</span>
<span class="n">q_delta</span> <span class="o">=</span> <span class="mf">0.001</span>             <span class="c1"># Initial spread of random quantum weights</span>
<span class="n">rng_seed</span> <span class="o">=</span> <span class="mi">0</span>                <span class="c1"># Seed for random number generator</span>
</pre></div>
</div>
</div>
<div class="section" id="circuits-of-the-quantum-linear-problem">
<h3>Circuits of the quantum linear problem<a class="headerlink" href="#circuits-of-the-quantum-linear-problem" title="Permalink to this headline">¶</a></h3>
<p>We need to define the unitary operations associated to the simple example
presented in the introduction.</p>
<p>The coefficients of the linear combination are three positive numbers <span class="math notranslate nohighlight">\((1, 0.2, 0.2)\)</span>.
So we can embed them in the state of  <span class="math notranslate nohighlight">\(m=2\)</span> ancillary qubits by adding a final zero element and
normalizing their sum to <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a><span class="p">)</span>
<span class="c1"># We also compute the square root of c</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">sqrt_c</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a><span class="p">)</span>
</pre></div>
</div>
<p>We need to embed the square root of the probability distribution <code class="docutils literal notranslate"><span class="pre">c</span></code> into the amplitudes
of the ancillary state. It is easy to check that one can always embed 3 positive
amplitudes with just three gates:
a local <span class="math notranslate nohighlight">\(R_y\)</span> rotation, a controlled-<span class="math notranslate nohighlight">\(R_y\)</span> and a controlled-NOT.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">U_c</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unitary matrix rotating the ground state of the ancillary qubits</span>
<span class="sd">    to |sqrt(c)&gt; = U_c |0&gt;.&quot;&quot;&quot;</span>
    <span class="c1"># Circuit mapping |00&gt; to sqrt_c[0] |00&gt; + sqrt_c[1] |01&gt; + sqrt_c[2] |10&gt;</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">sqrt_c</span></a><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">wires</span><span class="o">=</span><span class="n">ancilla_idx</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CRY.html#pennylane.CRY" title="pennylane.CRY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CRY</span></a><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">sqrt_c</span></a><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">sqrt_c</span></a><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">ancilla_idx</span><span class="p">,</span> <span class="n">ancilla_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">ancilla_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ancilla_idx</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">U_c_dagger</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjoint of U_c.&quot;&quot;&quot;</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">ancilla_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ancilla_idx</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CRY.html#pennylane.CRY" title="pennylane.CRY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CRY</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">sqrt_c</span></a><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">sqrt_c</span></a><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">ancilla_idx</span><span class="p">,</span> <span class="n">ancilla_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">sqrt_c</span></a><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">wires</span><span class="o">=</span><span class="n">ancilla_idx</span><span class="p">)</span>
</pre></div>
</div>
<p>We are left to define the sequence of all controlled-unitaries <span class="math notranslate nohighlight">\(CA_l\)</span>, acting
as <span class="math notranslate nohighlight">\(A_l\)</span> on the system whenever the ancillary state is <span class="math notranslate nohighlight">\(|l\rangle\)</span>.
Since in our case <span class="math notranslate nohighlight">\(A_0=\mathbb{I}\)</span> and <code class="docutils literal notranslate"><span class="pre">c[3]</span> <span class="pre">=</span> <span class="pre">0</span></code>, we only need to apply <span class="math notranslate nohighlight">\(A_1\)</span> and
<span class="math notranslate nohighlight">\(A_2\)</span> controlled by the first and second ancillary qubits respectively.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">CA_all</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Controlled application of all the unitary components A_l of the problem matrix A.&quot;&quot;&quot;</span>
    <span class="c1"># Controlled-A_1</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">ancilla_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">ancilla_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Controlled-A2</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">ancilla_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>The circuit for preparing the problem vector <span class="math notranslate nohighlight">\(|b\rangle\)</span> is very simple:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">U_b</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unitary matrix rotating the system ground state to the</span>
<span class="sd">    problem vector |b&gt; = U_b |0&gt;.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="variational-quantum-circuit">
<h3>Variational quantum circuit<a class="headerlink" href="#variational-quantum-circuit" title="Permalink to this headline">¶</a></h3>
<p>What follows is the variational quantum circuit that should generate the solution
state <span class="math notranslate nohighlight">\(|x\rangle= V(w)|0\rangle\)</span>.</p>
<p>The first layer of the circuit is a product of Hadamard gates preparing a
balanced superposition of all basis states.</p>
<p>After that, we apply a very simple variational ansatz
which is just a single layer of qubit rotations
<span class="math notranslate nohighlight">\(R_y(w_0) \otimes  R_y(w_1) \otimes  R_y(w_2)\)</span>.
For solving more complex problems, we suggest to use more expressive circuits as,
e.g., the PennyLane <code class="docutils literal notranslate"><span class="pre">StronglyEntanglingLayers</span></code> template.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">variational_block</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Variational circuit mapping the ground state |0&gt; to the ansatz state |x&gt;.&quot;&quot;&quot;</span>
    <span class="c1"># We first prepare an equal superposition of all the states of the computational basis</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

    <span class="c1"># A very minimal variational circuit</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RY.html#pennylane.RY" title="pennylane.RY" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RY</span></a><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="full-quantum-circuit">
<h2>Full quantum circuit<a class="headerlink" href="#full-quantum-circuit" title="Permalink to this headline">¶</a></h2>
<p>Now, we can define the full circuit associated to the CVQLS protocol presented in the introduction and
corresponding to the figure at the top of this tutorial.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">full_circuit</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Full quantum circuit necessary for the CVQLS protocol,</span>
<span class="sd">    without the final measurement.&quot;&quot;&quot;</span>
    <span class="c1"># U_c applied to the ancillary qubits</span>
    <span class="n">U_c</span><span class="p">()</span>

    <span class="c1"># Variational circuit generating a guess for the solution vector |x&gt;</span>
    <span class="n">variational_block</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Application of all the controlled-unitaries CA_l associated to the problem matrix A</span>
    <span class="n">CA_all</span><span class="p">()</span>

    <span class="c1"># Adjoint of U_b, where U_b |0&gt; = |b&gt;</span>
    <span class="c1"># For this particular problem adjoint(U_b)=U_b</span>
    <span class="n">U_b</span><span class="p">()</span>

    <span class="c1"># Adjoint of U_c, applied to the ancillary qubits</span>
    <span class="n">U_c_dagger</span><span class="p">()</span>
</pre></div>
</div>
<p>To estimate the overlap of the ground state with the post-selected state, one could
directly make use of the measurement samples. However, since we want to optimize the cost
function, it is useful to express everything in terms of expectation values through
Bayes’ theorem:</p>
<div class="math notranslate nohighlight">
\[|\langle b | \Psi \rangle|^2=
P( \mathrm{sys}=\mathrm{ground}\,|\, \mathrm{anc} = \mathrm{ground}) =
P( \mathrm{all}=\mathrm{ground})/P( \mathrm{anc}=\mathrm{ground})\]</div>
<p>To evaluate the two probabilities appearing on the right hand side of the previous equation
we initialize a <code class="docutils literal notranslate"><span class="pre">default.qubit</span></code> device and we define two different <code class="docutils literal notranslate"><span class="pre">qnode</span></code> circuits.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">tot_qubits</span><span class="p">)</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">global_ground</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="c1"># Circuit gates</span>
    <span class="n">full_circuit</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="c1"># Projector on the global ground state</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="n">tot_qubits</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">tot_qubits</span><span class="p">))</span>
    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hermitian</span></a><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">tot_qubits</span><span class="p">)))</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ancilla_ground</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="c1"># Circuit gates</span>
    <span class="n">full_circuit</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="c1"># Projector on the ground state of the ancillary system</span>
    <span class="n">P_anc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="n">m</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">P_anc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hermitian</span></a><span class="p">(</span><span class="n">P_anc</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">tot_qubits</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="section" id="variational-optimization">
<h2>Variational optimization<a class="headerlink" href="#variational-optimization" title="Permalink to this headline">¶</a></h2>
<p>In order to variationally solve our linear problem, we first define the cost function
<span class="math notranslate nohighlight">\(C = 1- |\langle b | \Psi \rangle|^2\)</span> that we are going to minimize.
As explained above, we express it in terms of expectation values through Bayes’ theorem.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cost function which tends to zero when A |x&gt; tends to |b&gt;.&quot;&quot;&quot;</span>

    <span class="n">p_global_ground</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">global_ground</span></a><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">p_ancilla_ground</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ancilla_ground</span></a><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">p_cond</span> <span class="o">=</span> <span class="n">p_global_ground</span> <span class="o">/</span> <span class="n">p_ancilla_ground</span>

    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_cond</span>
</pre></div>
</div>
<p>To minimize the cost function we use the gradient-descent optimizer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.GradientDescentOptimizer.html#pennylane.GradientDescentOptimizer" title="pennylane.GradientDescentOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">opt</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.GradientDescentOptimizer.html#pennylane.GradientDescentOptimizer" title="pennylane.GradientDescentOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">GradientDescentOptimizer</span></a><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
</pre></div>
</div>
<p>We initialize the variational weights with random parameters (with a fixed seed).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">w</span></a> <span class="o">=</span> <span class="n">q_delta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>We are ready to perform the optimization loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cost_history</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">w</span></a><span class="p">,</span> <span class="n">_cost</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.GradientDescentOptimizer.html#pennylane.GradientDescentOptimizer.step_and_cost" title="pennylane.GradientDescentOptimizer.step_and_cost" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">opt</span><span class="o">.</span><span class="n">step_and_cost</span></a><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">w</span></a><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step </span><span class="si">{:3d}</span><span class="s2">       Cost = </span><span class="si">{:9.7f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">_cost</span><span class="p">))</span>
    <span class="n">cost_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_cost</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Step   0       Cost = 0.0269663
Step   1       Cost = 0.0111488
Step   2       Cost = 0.0041483
Step   3       Cost = 0.0014305
Step   4       Cost = 0.0004695
Step   5       Cost = 0.0001495
Step   6       Cost = 0.0000468
Step   7       Cost = 0.0000145
Step   8       Cost = 0.0000045
Step   9       Cost = 0.0000014
</pre></div>
</div>
<p>We plot the cost function with respect to the optimization steps.
We remark that this is not an abstract mathematical quantity
since it also represents a bound for the error between the generated state
and the exact solution of the problem.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;seaborn&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cost_history</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Cost function&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Optimization steps&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_coherent_vqls_001.png" srcset="../_images/sphx_glr_tutorial_coherent_vqls_001.png" alt="tutorial coherent vqls" class = "sphx-glr-single-img"/></div>
<div class="section" id="comparison-of-quantum-and-classical-results">
<h2>Comparison of quantum and classical results<a class="headerlink" href="#comparison-of-quantum-and-classical-results" title="Permalink to this headline">¶</a></h2>
<p>Since the specific problem considered in this tutorial has a small size, we can also
solve it in a classical way and then compare the results with our quantum solution.</p>
<div class="section" id="classical-algorithm">
<h3>Classical algorithm<a class="headerlink" href="#classical-algorithm" title="Permalink to this headline">¶</a></h3>
<p>To solve the problem in a classical way, we use the explicit matrix representation in
terms of numerical NumPy arrays.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Id</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Z</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_0</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_1</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Z</span></a><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Id</span></a><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_2</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">X</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Id</span></a><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">Id</span></a><span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_num</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_0</span></a> <span class="o">+</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_1</span></a> <span class="o">+</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c</span></a><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_2</span></a>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">b</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>We can print the explicit values of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(b\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_num</span></a><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;b = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">b</span></a><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>A =
 [[0.71428571 0.         0.         0.         0.28571429 0.
  0.         0.        ]
 [0.         0.71428571 0.         0.         0.         0.28571429
  0.         0.        ]
 [0.         0.         0.71428571 0.         0.         0.
  0.         0.        ]
 [0.         0.         0.         0.71428571 0.         0.
  0.         0.        ]
 [0.28571429 0.         0.         0.         0.71428571 0.
  0.         0.        ]
 [0.         0.28571429 0.         0.         0.         0.71428571
  0.         0.        ]
 [0.         0.         0.         0.         0.         0.
  0.71428571 0.        ]
 [0.         0.         0.         0.         0.         0.
  0.         0.71428571]]
b =
 [0.35355339 0.35355339 0.35355339 0.35355339 0.35355339 0.35355339
 0.35355339 0.35355339]
</pre></div>
</div>
<p>The solution can be computed via a matrix inversion:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_inv</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_num</span></a><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">A_inv</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">b</span></a><span class="p">)</span>
</pre></div>
</div>
<p>Finally, in order to compare <span class="math notranslate nohighlight">\(x\)</span> with the quantum state <span class="math notranslate nohighlight">\(|x\rangle\)</span>,
we normalize and square its elements.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c_probs</span></a> <span class="o">=</span> <span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">x</span></a><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="preparation-of-the-quantum-solution">
<h3>Preparation of the quantum solution<a class="headerlink" href="#preparation-of-the-quantum-solution" title="Permalink to this headline">¶</a></h3>
<p>Given the variational weights <code class="docutils literal notranslate"><span class="pre">w</span></code> that we have previously optimized,
we can generate the quantum state <span class="math notranslate nohighlight">\(|x\rangle\)</span>. By measuring <span class="math notranslate nohighlight">\(|x\rangle\)</span>
in the computational basis we can estimate the probability of each basis state.</p>
<p>For this task, we initialize a new PennyLane device and define the associated
QNode.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev_x</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev_x</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">prepare_and_sample</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>

    <span class="c1"># Variational circuit generating a guess for the solution vector |x&gt;</span>
    <span class="n">variational_block</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># We assume that the system is measured in the computational basis.</span>
    <span class="c1"># Therefore, sampling from the device will give us a value of 0 or 1 for each qubit (n_qubits)</span>
    <span class="c1"># this will be repeated for the total number of shots provided (n_shots).</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.sample.html#pennylane.sample" title="pennylane.sample" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">sample</span></a><span class="p">()</span>
</pre></div>
</div>
<p>To estimate the probability distribution over the basis states we first take <code class="docutils literal notranslate"><span class="pre">n_shots</span></code>
samples and then compute the relative frequency of each outcome.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">raw_samples</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">prepare_and_sample</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">w</span></a><span class="p">)</span>

<span class="c1"># convert the raw samples (bit strings) into integers and count them</span>
<span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">sam</span> <span class="ow">in</span> <span class="n">raw_samples</span><span class="p">:</span>
    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="n">sam</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">q_probs</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n_qubits</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_shots</span>
</pre></div>
</div>
</div>
<div class="section" id="comparison">
<h3>Comparison<a class="headerlink" href="#comparison" title="Permalink to this headline">¶</a></h3>
<p>Let us print the classical result.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x_n^2 =</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c_probs</span></a><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>x_n^2 =
 [0.08445946 0.08445946 0.16554054 0.16554054 0.08445946 0.08445946
 0.16554054 0.16554054]
</pre></div>
</div>
<p>The previous probabilities should match the following quantum state probabilities.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;|&lt;x|n&gt;|^2=</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">q_probs</span></a><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>|&lt;x|n&gt;|^2=
 [0.084366 0.084768 0.164876 0.165119 0.085023 0.084483 0.165655 0.16571 ]
</pre></div>
</div>
<p>Let us graphically visualize both distributions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_qubits</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">c_probs</span></a><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_qubits</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Vector space basis&quot;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Classical probabilities&quot;</span><span class="p">)</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_qubits</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">q_probs</span></a><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_qubits</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Hilbert space basis&quot;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Quantum probabilities&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_coherent_vqls_002.png" srcset="../_images/sphx_glr_tutorial_coherent_vqls_002.png" alt="Classical probabilities, Quantum probabilities" class = "sphx-glr-single-img"/></div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Carlos Bravo-Prieto, Ryan LaRose, Marco Cerezo, Yigit Subasi, Lukasz Cincio, Patrick J. Coles.
“Variational Quantum Linear Solver: A Hybrid Algorithm for Linear Systems.”
<a class="reference external" href="https://arxiv.org/abs/1909.05820">arXiv:1909.05820</a>, 2019.</p></li>
<li><p>Robin Kothari.
“Efficient algorithms in quantum query complexity.”
PhD thesis, University of Waterloo, 2014.</p></li>
</ol>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/andrea_mari.jpeg" alt="Andrea Mari" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Andrea Mari</h4>
        <p class="bio-text__author-description">Andrea obtained a PhD in quantum information theory from the University of Potsdam (Germany). He worked as a postdoc at Scuola Normale Superiore (Pisa, Italy) and as a remote researcher at Xanadu. Since 2020 is a Member of Technical Staff at Unitary Fund.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  5.580 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-coherent-vqls-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/29ee9b3e774cef933b2f6778da2d61dd/tutorial_coherent_vqls.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_coherent_vqls.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/93892a08292dd35e723fab6ebb7f31fe/tutorial_coherent_vqls.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_coherent_vqls.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_coherent_vqls</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Coherent Variational Quantum Linear Solver</a><ul class='current'>
<li class='current'><a class="reference internal" href="#introduction">Introduction</a><ul class='current'>
<li class='current'><a class="reference internal" href="#the-problem">The problem</a></li>
<li class='current'><a class="reference internal" href="#coherent-variational-quantum-linear-solver-cvqls">Coherent Variational Quantum Linear Solver (CVQLS)</a><ul class='current'>
<li class='current'><a class="reference internal" href="#coherently-applying-a">Coherently applying <span class="math notranslate nohighlight">\(A\)</span></a></li>
<li class='current'><a class="reference internal" href="#estimating-the-cost-function">Estimating the cost function</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#a-simple-example">A simple example</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#general-setup">General setup</a><ul class='current'>
<li class='current'><a class="reference internal" href="#setting-of-the-main-hyper-parameters-of-the-model">Setting of the main hyper-parameters of the model</a></li>
<li class='current'><a class="reference internal" href="#circuits-of-the-quantum-linear-problem">Circuits of the quantum linear problem</a></li>
<li class='current'><a class="reference internal" href="#variational-quantum-circuit">Variational quantum circuit</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#full-quantum-circuit">Full quantum circuit</a></li>
<li class='current'><a class="reference internal" href="#variational-optimization">Variational optimization</a></li>
<li class='current'><a class="reference internal" href="#comparison-of-quantum-and-classical-results">Comparison of quantum and classical results</a><ul class='current'>
<li class='current'><a class="reference internal" href="#classical-algorithm">Classical algorithm</a></li>
<li class='current'><a class="reference internal" href="#preparation-of-the-quantum-solution">Preparation of the quantum solution</a></li>
<li class='current'><a class="reference internal" href="#comparison">Comparison</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_coherent_vqls</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_optimization.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="qonn.html" title="Optimizing a quantum optical neural network"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_vqls.html" title="Variational Quantum Linear Solver"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" >Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Coherent Variational Quantum Linear Solver</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>