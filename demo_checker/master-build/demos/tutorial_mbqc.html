
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Learn about measurement-based quantum computation" property="og:description" />
<meta content="https://pennylane.ai/qml/_images/thumbnail_mbqc.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Measurement-based quantum computation &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_mbqc.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Learn about measurement-based quantum computation" property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Measurement-based quantum computation &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_mbqc.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Introduction to the ZX-calculus" href="tutorial_zx_calculus.html" />
    <link rel="prev" title="Estimating observables with classical shadows in the Pauli basis" href="tutorial_diffable_shadows.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_zx_calculus.html" title="Introduction to the ZX-calculus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_diffable_shadows.html" title="Estimating observables with classical shadows in the Pauli basis"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" accesskey="U">Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Measurement-based quantum computation</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-mbqc-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="measurement-based-quantum-computation">
<span id="mbqc"></span><span id="sphx-glr-demos-tutorial-mbqc-py"></span><h1>Measurement-based quantum computation<a class="headerlink" href="#measurement-based-quantum-computation" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_toric_code.html"];
    var related_tutorials_titles = ['Toric code'];
</script></p>
<p><em>Authors: Joost Bus and Radoica Draškić — Posted: 05 December 2022. Last updated: 05 December 2022.</em></p>
<p><strong>Measurement-based quantum computing (MBQC)</strong>, also known as one-way quantum computing, is an
inventive approach to quantum computing that makes use of <em>off-line</em> entanglement as a resource
for computation. A one-way quantum computer starts out with an entangled state, a so-called
<em>cluster state</em>, and applies particular single-qubit measurements that correspond to the desired quantum circuit. In this context,
off-line means that the entanglement is created independently from the rest of the
computation, like how a blank sheet of paper is made separately from the text of a book. Coming
from the gate-based model, this method might seem unintuitive to you at first, but the approaches
can be proven to be equally powerful. In MBQC, the measurements <em>are</em> the computation and the
entanglement of the cluster state is used as a resource.</p>
<p>The structure of this demo will be as follows. First, we introduce the concept of a cluster
state, the substrate for measurement-based quantum computation. Then, we will move on to explain
how to implement arbitrary quantum circuits, thus proving that MBQC is universal. Lastly, we will
briefly touch upon how quantum error correction (QEC) is done in this scheme.</p>
<p>Throughout this tutorial, we will explain the underlying concepts with the help of some code
snippets using <a class="reference external" href="https://pennylane.readthedocs.io/en/stable/">PennyLane</a>. In the section about QEC,
we will also use Xanadu’s quantum error correction simulation software
<a class="reference external" href="https://flamingpy.readthedocs.io/en/latest/">FlamingPy</a> developed by our architecture team
<a class="footnote-reference brackets" href="#xanadupassivearchitecture" id="id1">4</a>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/DALLE-mbqc.png"><img alt="DALLE representation of Measurement-based quantum computation" src="../_images/DALLE-mbqc.png" style="width: 60%;" /></a>
<div class="legend">
<p>In MBQC, seeing is computing!</p>
</div>
</div>
<div class="section" id="cluster-states-and-graph-states">
<h2>Cluster states and graph states<a class="headerlink" href="#cluster-states-and-graph-states" title="Permalink to this headline">¶</a></h2>
<p><em>Cluster states</em> are the universal substrate for measurement-based quantum computation
<a class="footnote-reference brackets" href="#oneway2001" id="id2">1</a>. They are a special instance of <em>graph states</em> <a class="footnote-reference brackets" href="#entanglementgraphstates" id="id3">20</a>, a
class of entangled multi-qubit states that can be represented by an undirected graph
<span class="math notranslate nohighlight">\(G = (V,E)\)</span> whose vertices <span class="math notranslate nohighlight">\(V\)</span> are associated with qubits and the edges <span class="math notranslate nohighlight">\(E\)</span> with entanglement
between them. The associated quantum state reads as follows</p>
<div class="math notranslate nohighlight">
\[|\Phi\rangle=\Pi_{(i,j)\in E}CZ_{ij}|+⟩^{\otimes n}.\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of qubits, <span class="math notranslate nohighlight">\(CZ_{ij}\)</span> is the controlled-<span class="math notranslate nohighlight">\(Z\)</span> gate between
qubits <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>, and <span class="math notranslate nohighlight">\(|+\rangle = \frac{1}{\sqrt{2}}\big(|0\rangle + |1\rangle\big)\)</span>
is the <span class="math notranslate nohighlight">\(+1\)</span> eigenstate of the Pauli-<span class="math notranslate nohighlight">\(X\)</span> operator. The distinction between graph
states and a cluster states is rather technical and details can be found in Ref.
<a class="footnote-reference brackets" href="#persistententanglement" id="id4">21</a>. For now, suffice to say that cluster states are a subset of graph
states with some additional conditions.</p>
<p>We can also describe the creation of a cluster state in the gate-based model. Let us first
define a graph we want to look at, and then construct a circuit in PennyLane to create the
corresponding graph state.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span>  <span class="c1"># dimensions of the graph (lattice)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">grid_graph</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>  <span class="c1"># there are a * b qubits</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="p">},</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_mbqc_001.png" srcset="../_images/sphx_glr_tutorial_mbqc_001.png" alt="tutorial mbqc" class = "sphx-glr-single-img"/><p>This is a fairly simple cluster state, but we will later see how even
this simple graph is useful for logical operations. Now that we have defined a graph, we can go ahead
and define a circuit to prepare the cluster state.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>

<span class="n">qubits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cluster_state</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">edge</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>


<span class="nb">print</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.draw.html#pennylane.draw" title="pennylane.draw" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">draw</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cluster_state</span></a><span class="p">)())</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>(0, 0): ──H─╭●──────────┤  State
(1, 0): ──H─╰Z─╭●───────┤  State
(2, 0): ──H────╰Z─╭●────┤  State
(3, 0): ──H───────╰Z─╭●─┤  State
(4, 0): ──H──────────╰Z─┤  State
</pre></div>
</div>
<p>Observe that the structure of the circuit is fairly simple. It only requires Hadamard
gates on each qubit and then a controlled-<span class="math notranslate nohighlight">\(Z\)</span> gate between connected qubits. This part of
the computation is not actually computing anything. In fact, aside from the width and depth of
the desired quantum circuit, the cluster state generation is essentially independent of the
calculation. If you have a reliable way of applying these two operations (Hadamard and
controlled-<span class="math notranslate nohighlight">\(Z\)</span>), you are ready for the next step: worrying about conditional single-qubit
measurements.</p>
</div>
<div class="section" id="information-propagation-and-teleportation">
<h2>Information propagation and teleportation<a class="headerlink" href="#information-propagation-and-teleportation" title="Permalink to this headline">¶</a></h2>
<p>Measurement-based quantum computation heavily relies on the idea of information propagation. In
particular, we make use of a protocol called <em>quantum teleportation</em>, one of the driving concepts behind MBQC. Despite its Sci-Fi name, quantum
teleportation is very real and has been experimentally demonstrated multiple times in the last few decades
<a class="footnote-reference brackets" href="#hermans2022" id="id5">13</a>, <a class="footnote-reference brackets" href="#furusawa1998" id="id6">11</a>, <a class="footnote-reference brackets" href="#riebe2004" id="id7">14</a>, <a class="footnote-reference brackets" href="#nielsen1998" id="id8">12</a>. Moreover, it has related applications
in safe communication protocols that are impossible with classical communication so it’s certainly
worth learning about. In this protocol, we transport <em>information</em>, not matter, between systems. Admittedly, it has a
somewhat misleading name because it is not instantaneous: it requires communication of
additional classical information, which is still limited by the speed of light.</p>
<div class="section" id="one-qubit-teleportation">
<h3>One-qubit Teleportation<a class="headerlink" href="#one-qubit-teleportation" title="Permalink to this headline">¶</a></h3>
<p>Let’s take a deeper look at the principles behind quantum teleportation using a simple example of one-qubit
teleportation. We start with one qubit in the state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> that we want to transfer
to the second qubit initially in the state <span class="math notranslate nohighlight">\(|0\rangle\)</span>. The figure below represents the
protocol. The green box represents the creation of a cluster state, while
the red box represents the measurement of a qubit with the appropriate correction applied to
the second qubit based on the measurement outcome.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/one-bit-teleportation.png"><img alt="Teleportation protocol" src="../_images/one-bit-teleportation.png" style="width: 75%;" /></a>
</div>
<p>Let’s implement one-qubit teleportation in PennyLane.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">import</span> <span class="nn">pennylane.numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">one_bit_teleportation</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">):</span>
    <span class="c1"># Prepare the input state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Prepare the cluster state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Measure the first qubit in the Pauli-X basis</span>
    <span class="c1"># and apply an X-gate conditioned on the outcome</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.measure.html#pennylane.measure" title="pennylane.measure" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">measure</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">)(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Return the density matrix of the output state</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.density_matrix.html#pennylane.density_matrix" title="pennylane.density_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">density_matrix</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that we return a <a class="reference external" href="https://en.wikipedia.org/wiki/Density_matrix">density matrix</a> in the
function above.
This allows for us to describe operations beyond unitaries,
such as the teleportation protocol.</p>
<p>Now, let’s prepare a random qubit state and see if the teleportation protocol is working as
expected. To do so, we’ll generate a random normalized state <span class="math notranslate nohighlight">\(|\psi\rangle = \alpha |0\rangle + \beta |1\rangle\)</span>
and apply the teleportation protocol to see if the resulting density matrix
describing the second qubit is the same as our input state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define helper function for random input state on n qubits</span>
<span class="k">def</span> <span class="nf">generate_random_state</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">)</span>


<span class="c1"># Generate a random input state |psi&gt; for n=1 qubit</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a> <span class="o">=</span> <span class="n">generate_random_state</span><span class="p">()</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">density_matrix</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">))</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">density_matrix_mbqc</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">one_bit_teleportation</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">density_matrix</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">density_matrix_mbqc</span></a><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
<p>As we can see, <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, originally the state of the first qubit, has been transported to the second qubit!</p>
<p>This protocol is one of the main ingredients of one-way quantum computing. Essentially, we
propagate the information in one end of our cluster state to the other end through
successive teleportations. In addition, we can “write” our circuit onto the cluster state by
choosing the measurements adaptively. In the next section, we will see how we can actually do this.</p>
</div>
</div>
<div class="section" id="universality-of-mbqc">
<h2>Universality of MBQC<a class="headerlink" href="#universality-of-mbqc" title="Permalink to this headline">¶</a></h2>
<p>How do we know if this measurement-based scheme is just as powerful as its gate-based counterpart? We
have to prove it! In particular, we want to show that a measurement-based quantum computer is a
<a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_Turing_machine">quantum Turing machine (QTM)</a>. To do this, we
need to show 4 things <a class="footnote-reference brackets" href="#oneway2001" id="id9">1</a>:</p>
<ol class="arabic simple">
<li><p>How <strong>information propagates</strong> through the cluster state.</p></li>
<li><p>How arbitrary <strong>single-qubit rotations</strong> can be implemented.</p></li>
<li><p>How a <strong>two-qubit gate</strong> can be implemented in this scheme.</p></li>
<li><p>How to implement <strong>arbitrary quantum circuits</strong>.</p></li>
</ol>
<p>In the previous section, we have already seen how the quantum information propagates from one
side of the cluster to the other. In this
section, we will tackle the remaining parts concerning logical operations. Throughout, we will
assume the ability to measure in arbitrary bases.</p>
<div class="section" id="single-qubit-rotations">
<span id="id10"></span><h3>Single-qubit rotations<a class="headerlink" href="#single-qubit-rotations" title="Permalink to this headline">¶</a></h3>
<p>Arbitrary single-qubit rotations are essential operations for a universal quantum computer. In
MBQC, we can implement these rotations by using the entanglement of the cluster state. Any
single-qubit gate can be represented as a composition of three rotations along two different axes,
for example <span class="math notranslate nohighlight">\(U(\alpha, \beta, \gamma) = R_x(\gamma)R_z(\beta)R_x(\alpha)\)</span> where
<span class="math notranslate nohighlight">\(R_x\)</span> and <span class="math notranslate nohighlight">\(R_z\)</span> represent rotations around the <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> axis,
respectively.</p>
<p>We will see that in our measurement-based scheme, this operation can be implemented using a linear
chain of 5 qubits prepared in a cluster state, as shown in the figure below <a class="footnote-reference brackets" href="#mbqcrealization" id="id11">2</a>. The first qubit
<span class="math notranslate nohighlight">\(t_\mathrm{in}\)</span> is prepared in some input state <span class="math notranslate nohighlight">\(|\psi_\mathrm{in}\rangle\)</span>,
and we are interested in the final state of the output qubit <span class="math notranslate nohighlight">\(t_\mathrm{out}\)</span>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/single-qubit-rotation.png"><img alt="Measurement-based single qubit rotation" src="../_images/single-qubit-rotation.png" style="width: 75%;" /></a>
</div>
<p>The input qubit <span class="math notranslate nohighlight">\(t_\mathrm{in}\)</span>, together with the intermediate qubits <span class="math notranslate nohighlight">\(a_1\)</span>,
<span class="math notranslate nohighlight">\(a_2\)</span>, and <span class="math notranslate nohighlight">\(a_3\)</span> are then measured in the bases</p>
<div class="math notranslate nohighlight">
\[\mathcal{B}_j(\theta_j) \equiv \left\{\frac{|0\rangle + e^{i\theta_j}|1\rangle}{\sqrt{2}},
\frac{|0\rangle - e^{i\theta_j}|1\rangle}{\sqrt{2}}\right\},\]</div>
<p>where the angles <span class="math notranslate nohighlight">\(\theta_j\)</span> depend on prior measurement outcomes and
are given by</p>
<div class="math notranslate nohighlight">
\[\theta_{\mathrm{in}} = 0, \qquad \theta_{1} = (-1)^{m_{\mathrm{in}} + 1} \alpha, \qquad
\theta_{2} = (-1)^{m_1} \beta, \quad \text{and} \quad \theta_{3} = (-1)^{m_{\mathrm{in}} + m_2} \gamma\]</div>
<p>with <span class="math notranslate nohighlight">\(m_{\mathrm{in}}, m_1, m_2 \in \{0, 1\}\)</span> being the measurement outcomes on nodes
<span class="math notranslate nohighlight">\(t_\mathrm{in}\)</span>, <span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span>, respectively. Note that the
measurement basis is adaptive; the measurement on <span class="math notranslate nohighlight">\(a_3\)</span>, for example, depends on the outcome
of earlier measurements in the chain. After these operations, the state of qubit
<span class="math notranslate nohighlight">\(t_\mathrm{out}\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[|\psi_{\mathrm{out}}\rangle = \tilde{U}(\alpha, \beta, \gamma)|\psi_{\mathrm{in}}\rangle
= X^{m_1 + m_3}Z^{m_{\mathrm{in}} + m_2}U(\alpha, \beta, \gamma)
|\psi_{\mathrm{in}}\rangle.\]</div>
<p>with <span class="math notranslate nohighlight">\(m_3\)</span> being the measurement outcome on node <span class="math notranslate nohighlight">\(a_3\)</span>. Now note that this unitary
<span class="math notranslate nohighlight">\(\tilde{U}\)</span> is related to our desired unitary <span class="math notranslate nohighlight">\(U\)</span> up to
the first two Pauli terms. Luckily, we can correct for these additional Pauli gates by
choosing the measurement basis of qubit <span class="math notranslate nohighlight">\(t_\mathrm{out}\)</span> appropriately or correcting for them classically after
the quantum computation.</p>
<p>To demonstrate that this actually works, we will use PennyLane. For simplicity, we will just
show the ability will to perform single-axis rotations <span class="math notranslate nohighlight">\(R_z(\theta)\)</span> and
<span class="math notranslate nohighlight">\(R_x(\theta)\)</span> for arbitrary <span class="math notranslate nohighlight">\(\theta \in [0, 2 \pi)\)</span>. Note that these two operations
plus the CNOT also constitute a universal gate set.</p>
<p>To start off, we define the <span class="math notranslate nohighlight">\(R_z(\theta)\)</span> gate using two qubits with the gate-based approach
so we can later compare our MBQC approach to it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">RZ</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">):</span>
    <span class="c1"># Prepare the input state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Perform the Rz rotation</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Return the density matrix of the output state</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.density_matrix.html#pennylane.density_matrix" title="pennylane.density_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">density_matrix</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Let’s now implement an <span class="math notranslate nohighlight">\(R_z\)</span> gate on an arbitrary state
in the MBQC formalism.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mbqc_dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">mbqc_dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">RZ_MBQC</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">):</span>
    <span class="c1"># Prepare the input state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Prepare the cluster state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Measure the first qubit an correct the state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.measure.html#pennylane.measure" title="pennylane.measure" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">measure</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">)(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Return the density matrix of the output state</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.density_matrix.html#pennylane.density_matrix" title="pennylane.density_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">density_matrix</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Next, we will prepare a random input state and compare the two approaches.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate a random input state</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a> <span class="o">=</span> <span class="n">generate_random_state</span><span class="p">()</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>

<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RZ</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RZ_MBQC</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
<p>Seems good! As we can see, the resulting states are practically the same.
For the <span class="math notranslate nohighlight">\(R_x(\theta)\)</span> gate we take a similar approach.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">RX</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">):</span>
    <span class="c1"># Prepare the input state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Perform the Rz rotation</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Return the density matrix of the output state</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.density_matrix.html#pennylane.density_matrix" title="pennylane.density_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">density_matrix</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="n">mbqc_dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">mbqc_dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">RX_MBQC</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">):</span>
    <span class="c1"># Prepare the input state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Prepare the cluster state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Measure the qubits and perform corrections</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m1</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.measure.html#pennylane.measure" title="pennylane.measure" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">measure</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">)(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">theta</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.measure.html#pennylane.measure" title="pennylane.measure" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">measure</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">)(</span><span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">)(</span><span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Return the density matrix of the output state</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.density_matrix.html#pennylane.density_matrix" title="pennylane.density_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">density_matrix</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Finally, we again compare the two implementations with a random state as an input.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate a random input state</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a> <span class="o">=</span> <span class="n">generate_random_state</span><span class="p">()</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>

<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RX</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">RX_MBQC</span></a><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
<p>Perfect! We have shown that we can implement any single-axis rotation on an arbitrary state in the
MBQC formalism. In the following section we will look at a two-qubit gate to complete our
universal gate set.</p>
</div>
<div class="section" id="the-two-qubit-gate-cnot">
<h3>The two-qubit gate: CNOT<a class="headerlink" href="#the-two-qubit-gate-cnot" title="Permalink to this headline">¶</a></h3>
<p>The second ingredient for a universal quantum computing scheme is the two-qubit gate. Here, we will
show how to perform a CNOT operation in the measurement-based framework. The input state is given on two qubits,
control qubit <span class="math notranslate nohighlight">\(c\)</span> and target qubit <span class="math notranslate nohighlight">\(t_\mathrm{in}\)</span>. Preparing the cluster state shown in
the figure below, and measuring qubits <span class="math notranslate nohighlight">\(t_\mathrm{in}\)</span> and <span class="math notranslate nohighlight">\(a\)</span> in the <span class="math notranslate nohighlight">\(X\)</span>-basis,
we implement the CNOT gate between qubits <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(t_\mathrm{out}\)</span> up to Pauli corrections <a class="footnote-reference brackets" href="#mbqcrealization" id="id12">2</a>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/cnot1.png"><img alt="Measurement-based CNOT" src="../_images/cnot1.png" style="width: 50%;" /></a>
</div>
<p>Let’s see how one can do this in PennyLane.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">CNOT</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">):</span>
    <span class="c1"># Prepare the input state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CNOT.html#pennylane.CNOT" title="pennylane.CNOT" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.density_matrix.html#pennylane.density_matrix" title="pennylane.density_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">density_matrix</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>


<span class="n">mbqc_dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>


<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">mbqc_dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">CNOT_MBQC</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">):</span>
    <span class="c1"># Prepare the input state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Prepare the cluster state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CZ.html#pennylane.CZ" title="pennylane.CZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CZ</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

    <span class="c1"># Measure the qubits in the appropriate bases</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">m1</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.measure.html#pennylane.measure" title="pennylane.measure" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">measure</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.measure.html#pennylane.measure" title="pennylane.measure" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">measure</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Correct the state</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">)(</span><span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">)(</span><span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.cond.html#pennylane.cond" title="pennylane.cond" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">cond</span></a><span class="p">(</span><span class="n">m1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">)(</span><span class="n">wires</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Return the density matrix of the output state</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.density_matrix.html#pennylane.density_matrix" title="pennylane.density_matrix" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">density_matrix</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Now let’s prepare a random input state and check our implementation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate a random 2-qubit state</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a> <span class="o">=</span> <span class="n">generate_random_state</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">CNOT</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">CNOT_MBQC</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">input_state</span></a><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
<div class="section" id="arbitrary-quantum-circuits">
<h3>Arbitrary quantum circuits<a class="headerlink" href="#arbitrary-quantum-circuits" title="Permalink to this headline">¶</a></h3>
<p>Once we have established the ability to implement arbitrary single-qubit rotations and a two-qubit
gate, the final step is to show that we can implement arbitrary quantum circuits. To do so,
we simply have to note that we have a <em>universal gate set</em> <a class="footnote-reference brackets" href="#divincenzo" id="id13">10</a>. The complete computation
can be performed as shown in the figure below. The qubits are teleported along the arrows in the
cluster and single-qubit gates are applied through a selection of measurement bases along these arrays.
Two-qubit gates are implemented along vertical arrows, and the rest of the qubits are measured in the
<span class="math notranslate nohighlight">\(Z\)</span>-basis, effectively taking them out of the cluster without affecting the neighboring nodes.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/mbqc_info_flow.png"><img alt="measurement-based quantum computation information flow" src="../_images/mbqc_info_flow.png" style="width: 75%;" /></a>
<div class="legend">
<p>A complete measurement-based quantum computation. Circles <span class="math notranslate nohighlight">\(\odot\)</span> symbolize measurements
of Pauli-<span class="math notranslate nohighlight">\(Z\)</span>, vertical arrows <span class="math notranslate nohighlight">\(\uparrow\)</span> are measurements of Pauli-<span class="math notranslate nohighlight">\(X\)</span>, while
tilted arrows <span class="math notranslate nohighlight">\(\nwarrow\)</span> or <span class="math notranslate nohighlight">\(\nearrow\)</span> refer to
measurements in the <span class="math notranslate nohighlight">\(xy\)</span>-plane. <a class="footnote-reference brackets" href="#oneway2001" id="id14">1</a></p>
</div>
</div>
<p>However, you might wonder: Is it even feasible to construct the large cluster states that
one-way quantum computation requires? The number of qubits needed to construct a circuit can grow
to be very large, as it not only depends on the number of logical qubits, but also on the depth
of the circuit. At this point, it’s good to reiterate that the entanglement of the cluster
state is created <em>off-line</em>.</p>
<p><em>…the entanglement is created independently from the rest of the computation, like how a blank
sheet of paper is made separately from the text of a book.</em></p>
<p>Interestingly enough, we do not have to prepare all of the entanglement at once. Just like we can
already start printing text upon the first few pages, we can apply measurements to one end of the
cluster while growing it at the same time, as shown in the figure below. That is, we can start
printing the text on the first few pages while at the same time reloading the printer’s paper
tray!</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/measure_entangle.jpeg"><img alt="entanglement measurement" src="../_images/measure_entangle.jpeg" style="width: 75%;" /></a>
<div class="legend">
<p>Schematic showing how we can also consume the cluster state while we grow it. The blue qubits are in a cluster state,
where the bonds between them represent entanglement. The gray qubits have been measured,
destroying the entanglement and removing them from the cluster. At the same time, the green
qubits are being added to the cluster by entangling them with it. Prior measurement outcomes
determine the basis for future measurements <a class="footnote-reference brackets" href="#opticalquantumcomputing" id="id15">18</a>.</p>
</div>
</div>
<p>This feature makes it particularly attractive for photonic quantum computers: we can use
expendable qubits that can’t stick around for the full calculation. If we can find a
reliable way to produce qubits and stitch them together through entanglement, we can use it to
produce our cluster state resource! Essentially, we need some kind of qubit factory and a
stitching mechanism that puts it all together. The stitching mechanism depends on the physical
platform; for example, it can be implemented with an Ising interaction <a class="footnote-reference brackets" href="#oneway2001" id="id16">1</a> or by
interfering two optical modes with a beamsplitter <a class="footnote-reference brackets" href="#xanadupassivearchitecture" id="id17">4</a>.</p>
</div>
</div>
<div class="section" id="quantum-error-correction">
<h2>Quantum error correction<a class="headerlink" href="#quantum-error-correction" title="Permalink to this headline">¶</a></h2>
<p>To mitigate the physical errors that can (and will) happen during a quantum computation, we
require some kind of error correction scheme. Error correction is a technique for detecting errors and
reconstructing the logical data with as little information loss as possible. It is not exclusive
to quantum computing; it is also used in “classical” information processing such as computation,
data storage, and communication where one also has to deal <a class="reference external" href="https://www.youtube.com/watch?v=AaZ_RSt0KP8">with
noise coming from the environment</a>. However, it is
a stringent requirement in the quantum realm as the systems one works with are much more
precarious and therefore prone to environmental factors, causing errors.</p>
<p>Due to the peculiarities of quantum physics, we have to be careful when implementing error
correction. First of all, we can not simply look inside our quantum computer and see if an error occurred; this would collapse the
wavefunction, which carries valuable information. Secondly, we can not make copies of a quantum
state to create redundancy because of the <em>no-cloning theorem</em>. Lastly, there are infinitely many
more errors in quantum computing, whereas the only errors in classical computing are bit flips: a 1
being flipped to a 0 or vice versa.</p>
<p>A whole research field devoted to combating these challenges has formed since Peter Shor published his
seminal paper in 1995 <a class="footnote-reference brackets" href="#shorqec1995" id="id18">5</a>. The main idea in QEC is using redundancy to encode
information, just like classical error correction. However, to
overcome the quantum-specific problems, we must measure groups of qubits and observe correlations
between rather than measuring individual qubits.  More technically, we measure
operators that involve multiple qubits, called <em>stabilizers</em>. Based on the outcome of these stabilizer
measurements, we can apply a correction and recover our information.
Full coverage of this topic is beyond the scope of this tutorial, but a good place to start is
<a class="reference external" href="https://arxiv.org/abs/quant-ph/9705052">Daniel Gottesman’s thesis</a> or <a class="reference external" href="https://arthurpesah.me/blog/2022-01-25-intro-qec-1/">this blog post by
Arthur Pesah</a> for a more compact
introduction. Instead, we will give you the gist of quantum error correction in the
MBQC framework. We will do so by using the surface code <a class="footnote-reference brackets" href="#fowlersurfacecode" id="id19">7</a> <a class="footnote-reference brackets" href="#fowlerpolyestimate" id="id20">19</a> <a class="footnote-reference brackets" href="#googleqec2022" id="id21">8</a> as an example. This code makes use of stabilizers of the form <span class="math notranslate nohighlight">\(\bigotimes_i X_i\)</span> or
<span class="math notranslate nohighlight">\(\bigotimes_j Z_j\)</span>, as depicted below.</p>
<div class="figure align-center" id="fig-surfacecode">
<a class="reference internal image-reference" href="../_images/surface_code_d3.png"><img alt="surface code" src="../_images/surface_code_d3.png" style="width: 50%;" /></a>
<div class="legend">
<p>A distance <span class="math notranslate nohighlight">\(d=3\)</span> surface code. Circles represent qubits and bubbles represent operators, called
stabilizers, used to detect errors. The stabilizers are tensor products of Pauli-<span class="math notranslate nohighlight">\(X\)</span> or Pauli-<span class="math notranslate nohighlight">\(Z\)</span>
operators and each is associated with its own ancilla qubit. The combined system encodes one
logical qubit and can correct any combination of <span class="math notranslate nohighlight">\(\lfloor (d-1)/2 \rfloor\)</span> errors.
<a class="footnote-reference brackets" href="#fowlerpolyestimate" id="id22">19</a></p>
</div>
</div>
<p>In the measurement-based picture, quantum error correction requires cluster states that are at
least 3-dimensional <a class="footnote-reference brackets" href="#xanadublueprint" id="id23">3</a>, contrary to the 2-dimensional cluster states required for
universal quantum computation discussed in the previous section. The error correcting code that you want to implement
dictates the structure of the cluster state. The cluster state that is associated with the surface code is known as the RHG lattice,
named after its architects Raussendorf, Harrington, and Goyal. We can visualize this cluster
state with FlamingPy.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flamingpy.codes</span> <span class="kn">import</span> <span class="n">SurfaceCode</span>

<span class="n">code_distance</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">RHG</span> <span class="o">=</span> <span class="n">SurfaceCode</span><span class="p">(</span><span class="n">code_distance</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">RHG</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;matplotlib&quot;</span><span class="p">,</span> <span class="n">showbackground</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_mbqc_002.png" srcset="../_images/sphx_glr_tutorial_mbqc_002.png" alt="tutorial mbqc" class = "sphx-glr-single-img"/><p>For the sake of intuition, you can think of the graph shown above as having two spatial dimensions (<span class="math notranslate nohighlight">\(x\)</span>
and <span class="math notranslate nohighlight">\(y\)</span>) and one temporal dimension (<span class="math notranslate nohighlight">\(z\)</span>). The cluster state alternates between <em>primal</em> and <em>dual sheets</em>, shown below in more detail.
In principle, any quantum error correction stabilizer code can be <a class="reference external" href="https://arxiv.org/abs/1607.02579">foliated</a> into
a graph state for measurement-based QEC <a class="footnote-reference brackets" href="#foliatedquantumcodes" id="id24">15</a>, <a class="footnote-reference brackets" href="#universalftmbqc" id="id25">22</a>. However, the foliations are particularly nice for <a class="reference external" href="https://errorcorrectionzoo.org/c/css">CSS
codes</a>, named after Calderbank, Shor, and Steane. CSS codes have stabilizers that exclusively contain
<span class="math notranslate nohighlight">\(X\)</span>-stabilizers <em>or</em> <span class="math notranslate nohighlight">\(Z\)</span>-stabilizers, and include the <em>surface code</em> and <em>colour code</em> families.
For these CSS codes, you can roughly view the primal and dual sheets as measuring the
<span class="math notranslate nohighlight">\(Z\)</span>-stabilizers and <span class="math notranslate nohighlight">\(X\)</span>-stabilizers, respectively. We encourage you to have another
look at the <a class="reference internal" href="#fig-surfacecode"><span class="std std-ref">figure</span></a> with the distance-3 surface code and try to link it
with the dual and primal sheets shown here!</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/primal_dual.png"><img alt="primal and dual" src="../_images/primal_dual.png" style="width: 70%;" /></a>
</div>
<p>The computation and error correction are again performed with single-qubit measurements, as illustrated below.
At each timestep, we measure all the qubits on one sheet of the lattice. The binary
outcomes of these measurements determine the measurement bases for future measurements, and the
last sheet of the lattice contains the encoded result of the computation which can be read out by yet another measurement.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/gif_measuring.gif"><img alt="error corrected computation with measurements using the RHG lattice" src="../_images/gif_measuring.gif" style="width: 75%;" /></a>
<div class="legend">
<p>Performing an error corrected computation with measurements using the RHG lattice. <a class="footnote-reference brackets" href="#xanadublueprint" id="id26">3</a></p>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>We have learned that a one-way quantum computer capable of cluster state
entanglement together with adaptive arbitrary single-qubit measurements allows for universal
quantum computation. The MBQC framework is a powerful quantum computing approach, particularly
useful in platforms that allow for many expendable flying qubits and easy physical entangling
gates. It circumvents the need for applying in-line entangling gates that are often the most
noisy operations in gate-based quantum computers with trapped-ions or superconducting circuits.
Instead, the required entanglement is created off-line which is often simpler to implement.
Furthermore, it’s advantageous for photonics because the depth of the optical circuit can remain
constant. This means that it does not grow with the depth of the logical circuit, preventing
intolerable losses.</p>
<p>In this demo, we assumed that the system is capable of performing arbitrary
single-qubit measurements. This is not a strict requirement, as one can acquire the same
capabilities by sprinkling <em>magic states</em> into the cluster state. A discussion of this topic is
beyond the scope of this tutorial, but a good place to start is <a class="reference external" href="https://arxiv.org/abs/quant-ph/0403025">this
paper</a> <a class="footnote-reference brackets" href="#magicstates" id="id27">16</a>.</p>
<p>Xanadu’s approach toward a universal quantum computer involves <em>continuous-variable</em> cluster states
<a class="footnote-reference brackets" href="#cv-mbqc" id="id28">9</a>. If you would like to learn more about the architecture, you can read our blueprint
papers <a class="footnote-reference brackets" href="#xanadublueprint" id="id29">3</a> and <a class="footnote-reference brackets" href="#xanadupassivearchitecture" id="id30">4</a>. We also highly recommend watching <a class="reference external" href="https://www.youtube.com/watch?v=SD6TH7GZ1rM&amp;feature=emb_title">this
video</a> outlining the main ideas!</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="oneway2001"><span class="brackets">1</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id9">2</a>,<a href="#id14">3</a>,<a href="#id16">4</a>)</span></dt>
<dd><p>Robert Raussendorf and Hans J. Briegel (2001) <em>A One-Way Quantum Computer</em>,
<a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.86.5188">Phys. Rev. Lett. 86, 5188</a>.</p>
</dd>
<dt class="label" id="mbqcrealization"><span class="brackets">2</span><span class="fn-backref">(<a href="#id11">1</a>,<a href="#id12">2</a>)</span></dt>
<dd><p>Swapnil Nitin Shah (2021) <em>Realizations of Measurement Based Quantum Computing</em>,
<a class="reference external" href="https://arxiv.org/pdf/2112.11601.pdf">arXiv</a>.</p>
</dd>
<dt class="label" id="xanadublueprint"><span class="brackets">3</span><span class="fn-backref">(<a href="#id23">1</a>,<a href="#id26">2</a>,<a href="#id29">3</a>)</span></dt>
<dd><p>J. Eli Bourassa, Rafael N. Alexander, Michael Vasmer, Ashlesha Patil, Ilan Tzitrin,
Takaya Matsuura, Daiqin Su, Ben Q. Baragiola, Saikat Guha, Guillaume Dauphinais, Krishna K.
Sabapathy, Nicolas C. Menicucci, and Ish Dhand (2021) <em>Blueprint for a Scalable Photonic Fault-Tolerant Quantum Computer</em>,
<a class="reference external" href="https://quantum-journal.org/papers/q-2021-02-04-392/">Quantum 5, 392</a>.</p>
</dd>
<dt class="label" id="xanadupassivearchitecture"><span class="brackets">4</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id17">2</a>,<a href="#id30">3</a>)</span></dt>
<dd><p>Ilan Tzitrin, Takaya Matsuura, Rafael N. Alexander, Guillaume Dauphinais, J. Eli Bourassa,
Krishna K. Sabapathy, Nicolas C. Menicucci, and Ish Dhand (2021) <em>Fault-Tolerant Quantum Computation with Static Linear Optics</em>,
<a class="reference external" href="http://dx.doi.org/10.1103/PRXQuantum.2.040353">PRX Quantum, Vol. 2, No. 4</a>.</p>
</dd>
<dt class="label" id="shorqec1995"><span class="brackets"><a class="fn-backref" href="#id18">5</a></span></dt>
<dd><p>Peter W. Shor (1995) <em>Scheme for reducing decoherence in quantum computer memory</em>,
<a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493">Physical Review A, Vol. 52, Iss. 4</a>.</p>
</dd>
<dt class="label" id="latticesurgeryraussendorf2018"><span class="brackets">6</span></dt>
<dd><p>Daniel Herr, Alexandru Paler, Simon J. Devitt and Franco Nori (2018) <em>Lattice Surgery on the Raussendorf Lattice</em>,
<a class="reference external" href="https://arxiv.org/abs/1711.04921">IOP Publishing 3, 3</a>.</p>
</dd>
<dt class="label" id="fowlersurfacecode"><span class="brackets"><a class="fn-backref" href="#id19">7</a></span></dt>
<dd><p>Austin G. Fowler, Matteo Mariantoni, John M. Martinis, Andrew N. Cleland (2012)
<em>Surface codes: Towards practical large-scale quantum computation</em>, <a class="reference external" href="https://arxiv.org/abs/1208.0928">arXiv</a>.</p>
</dd>
<dt class="label" id="googleqec2022"><span class="brackets"><a class="fn-backref" href="#id21">8</a></span></dt>
<dd><p>Google Quantum AI (2022) <em>Suppressing quantum errors by scaling a surface code logical qubit</em>, <a class="reference external" href="https://arxiv.org/pdf/2207.06431.pdf">arXiv</a>.</p>
</dd>
<dt class="label" id="cv-mbqc"><span class="brackets"><a class="fn-backref" href="#id28">9</a></span></dt>
<dd><p>Nicolas C. Menicucci, Peter van Loock, Mile Gu, Christian Weedbrook, Timothy C. Ralph, and
Michael A. Nielsen (2006) <em>Universal Quantum Computation with Continuous-Variable Cluster States</em>,
<a class="reference external" href="https://arxiv.org/abs/quant-ph/0605198">arXiv</a>.</p>
</dd>
<dt class="label" id="divincenzo"><span class="brackets"><a class="fn-backref" href="#id13">10</a></span></dt>
<dd><p>David P. DiVincenzo. (2000) <em>The Physical Implementation of Quantum Computation</em>,
<a class="reference external" href="https://arxiv.org/abs/quant-ph/0002077">arXiv</a>.</p>
</dd>
<dt class="label" id="furusawa1998"><span class="brackets"><a class="fn-backref" href="#id6">11</a></span></dt>
<dd><p>A. Furusawa, J. L. Sørensen, S. L. Braunstein, C. A. Fuchs,H. J. Kimble, E. S. Polzik. (1998)
<em>Unconditional Quantum Teleportation</em>, <a class="reference external" href="https://www.science.org/doi/10.1126/science.282.5389.706">Science Vol 282, Issue 5389</a>.</p>
</dd>
<dt class="label" id="nielsen1998"><span class="brackets"><a class="fn-backref" href="#id8">12</a></span></dt>
<dd><p>M. A. Nielsen, E. Knill &amp; R. Laflamme. (1998) <em>Complete quantum teleportation using nuclear
magnetic resonance</em>, <a class="reference external" href="https://www.nature.com/articles/23891">Nature volume 396, 52–55</a>.</p>
</dd>
<dt class="label" id="hermans2022"><span class="brackets"><a class="fn-backref" href="#id5">13</a></span></dt>
<dd><p>S. L. N. Hermans, M. Pompili, H. K. C. Beukers, S. Baier, J. Borregaard &amp; R. Hanson. (2022)
<em>Qubit teleportation between non-neighbouring nodes in a quantum network</em>,
<a class="reference external" href="https://www.nature.com/articles/s41586-022-04697-y">Nature 605, 663–668</a>.</p>
</dd>
<dt class="label" id="riebe2004"><span class="brackets"><a class="fn-backref" href="#id7">14</a></span></dt>
<dd><p>M. Riebe, H. Häffner, C. F. Roos, W. Hänsel, J. Benhelm, G. P. T. Lancaster, T. W. Körber,
C. Becher, F. Schmidt-Kaler, D. F. V. James &amp; R. Blatt. (2002) <em>Deterministic quantum
teleportation with atoms</em>, <a class="reference external" href="https://www.nature.com/articles/nature02570">Nature 429, 734-737</a>.</p>
</dd>
<dt class="label" id="foliatedquantumcodes"><span class="brackets"><a class="fn-backref" href="#id24">15</a></span></dt>
<dd><p>A. Bolt, G. Duclos-Cianci, D. Poulin, T. M. Stace. (2016) <em>Foliated Quantum Codes</em>,
<a class="reference external" href="https://arxiv.org/abs/1607.02579">arXiv</a>.</p>
</dd>
<dt class="label" id="magicstates"><span class="brackets"><a class="fn-backref" href="#id27">16</a></span></dt>
<dd><p>Sergey Bravyi and Alexei Kitaev. (2004) <em>Universal quantum computation with ideal Clifford gates and noisy ancillas</em>,
<a class="reference external" href="https://arxiv.org/abs/quant-ph/0403025">arXiv</a>.</p>
</dd>
<dt class="label" id="quantumteleportation"><span class="brackets">17</span></dt>
<dd><p>M. Hein, J. Eisert and H.J. Briegel. (2003) <em>Multi-party entanglement in graph states</em>,
<a class="reference external" href="https://arxiv.org/abs/quant-ph/0307130">arXiv</a>.</p>
</dd>
<dt class="label" id="opticalquantumcomputing"><span class="brackets"><a class="fn-backref" href="#id15">18</a></span></dt>
<dd><p>Jeremy L. O’Brien. (2007) <em>Optical quantum computing</em>, <a class="reference external" href="https://www.science.org/doi/10.1126/science.1142892">Science Vol. 318, Issue 5856, 1567-1570</a>.</p>
</dd>
<dt class="label" id="fowlerpolyestimate"><span class="brackets">19</span><span class="fn-backref">(<a href="#id20">1</a>,<a href="#id22">2</a>)</span></dt>
<dd><p>Austin G. Fowler. (2013) <em>Polyestimate: instantaneous open source surface code analysis</em>, <a class="reference external" href="https://arxiv.org/abs/1307.0689">arXiv</a>.</p>
</dd>
<dt class="label" id="entanglementgraphstates"><span class="brackets"><a class="fn-backref" href="#id3">20</a></span></dt>
<dd><p>M. Hein, W. Dür, J. Eisert, R. Raussendorf, M. Van den Nest, H.J. Briegel. (2006) <em>Entanglement
in Graph States and its Applications</em>, <a class="reference external" href="https://arxiv.org/abs/quant-ph/0602096">arXiv</a>.</p>
</dd>
<dt class="label" id="persistententanglement"><span class="brackets"><a class="fn-backref" href="#id4">21</a></span></dt>
<dd><p>Hans J. Briegel and Robert Raussendorf (2001) <em>Persistent Entanglement in Arrays of
Interacting Particles</em>, <a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.86.910">Phys. Rev. Lett. 86, 910</a>.</p>
</dd>
<dt class="label" id="universalftmbqc"><span class="brackets"><a class="fn-backref" href="#id25">22</a></span></dt>
<dd><p>Benjamin J. Brown, Sam Roberts. (2018) <em>Universal fault-tolerant measurement-based quantum computation</em>, <a class="reference external" href="https://arxiv.org/abs/1811.11780">arXiv</a>.</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-authors">
<h2>About the authors<a class="headerlink" href="#about-the-authors" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/joost_bus.webp" alt="Joost Bus" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Joost Bus</h4>
        <p class="bio-text__author-description">I am a MSc student in Quantum Engineering at ETH Zürich who likes to explore how to wield quantum physics for technology. This summer, I am working with the architecture team on FlamingPy as a Xanadu resident.</p>
    </div>
</div><div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/radoica_draskic.jpg" alt="Radoica Draskic" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Radoica Draskic</h4>
        <p class="bio-text__author-description">I am a trained theoretical physicist and a wannabe computer scientist. I am currently working as a summer resident at Xanadu.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  2.022 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-mbqc-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/4d427c539dd3505516266b92a1bfb1b1/tutorial_mbqc.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_mbqc.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/45cd77921131dafd82f5dab41ed6a487/tutorial_mbqc.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_mbqc.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_mbqc</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Measurement-based quantum computation</a><ul class='current'>
<li class='current'><a class="reference internal" href="#cluster-states-and-graph-states">Cluster states and graph states</a></li>
<li class='current'><a class="reference internal" href="#information-propagation-and-teleportation">Information propagation and teleportation</a><ul class='current'>
<li class='current'><a class="reference internal" href="#one-qubit-teleportation">One-qubit Teleportation</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#universality-of-mbqc">Universality of MBQC</a><ul class='current'>
<li class='current'><a class="reference internal" href="#single-qubit-rotations">Single-qubit rotations</a></li>
<li class='current'><a class="reference internal" href="#the-two-qubit-gate-cnot">The two-qubit gate: CNOT</a></li>
<li class='current'><a class="reference internal" href="#arbitrary-quantum-circuits">Arbitrary quantum circuits</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#quantum-error-correction">Quantum error correction</a></li>
<li class='current'><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-authors">About the authors</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_mbqc</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_quantum-computing.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_zx_calculus.html" title="Introduction to the ZX-calculus"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_diffable_shadows.html" title="Estimating observables with classical shadows in the Pauli basis"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" >Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Measurement-based quantum computation</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>