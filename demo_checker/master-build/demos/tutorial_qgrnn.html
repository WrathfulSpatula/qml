
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Using a quantum graph recurrent neural network to learn quantum dynamics." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/qgrnn_thumbnail.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="The Quantum Graph Recurrent Neural Network &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_qgrnn.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Using a quantum graph recurrent neural network to learn quantum dynamics." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>The Quantum Graph Recurrent Neural Network &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_qgrnn.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Learning to learn with quantum neural networks" href="learning2learn.html" />
    <link rel="prev" title="Function fitting with a photonic quantum neural network" href="quantum_neural_net.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="learning2learn.html" title="Learning to learn with quantum neural networks"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quantum_neural_net.html" title="Function fitting with a photonic quantum neural network"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_qml.html" accesskey="U">Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">The Quantum Graph Recurrent Neural Network</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-qgrnn-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="the-quantum-graph-recurrent-neural-network">
<span id="sphx-glr-demos-tutorial-qgrnn-py"></span><h1>The Quantum Graph Recurrent Neural Network<a class="headerlink" href="#the-quantum-graph-recurrent-neural-network" title="Permalink to this headline">¶</a></h1>
<p><em>Author: Jack Ceroni — Posted: 27 July 2020. Last updated: 25 March 2021.</em></p>
<p>This demonstration investigates quantum graph
recurrent neural networks (QGRNN), which are the quantum analogue of a
classical graph recurrent neural network, and a subclass of the more
general quantum graph
neural network ansatz. Both the QGNN and QGRNN were introduced in
<a class="reference external" href="https://arxiv.org/abs/1909.12264">this paper (2019)</a>.</p>
<div class="section" id="the-idea">
<h2>The Idea<a class="headerlink" href="#the-idea" title="Permalink to this headline">¶</a></h2>
<p>A graph is defined as a set of <em>nodes</em> along with a set of
<strong>edges</strong>, which represent connections between nodes.
Information can be encoded into graphs by assigning numbers
to nodes and edges, which we call <strong>weights</strong>.
It is usually convenient to think of a graph visually:</p>
<a class="reference internal image-reference" href="../_images/graph4.png"><img alt="../_images/graph4.png" class="align-center" src="../_images/graph4.png" style="width: 70%;" /></a>
<p>In recent years, the concept of a
<a class="reference external" href="https://arxiv.org/abs/1812.08434">graph neural network</a> (GNN) has been
receiving a lot of attention from the machine learning community.
A GNN seeks
to learn a representation (a mapping of data into a
low-dimensional vector space) of a given graph with feature vectors assigned
to nodes and edges. Each of the vectors in the learned
representation preserves not only the features, but also the overall
topology of the graph, i.e., which nodes are connected by edges. The
quantum graph neural network attempts to do something similar, but for
features that are quantum-mechanical; for instance, a
collection of quantum states.</p>
<p>Consider the class of qubit Hamiltonians that are <em>quadratic</em>, meaning that
the terms of the Hamiltonian represent either interactions between two
qubits, or the energy of individual qubits.
This class of Hamiltonians is naturally described by graphs, with
second-order terms between qubits corresponding to weighted edges between
nodes, and first-order terms corresponding to node weights.</p>
<p>A well known example of a quadratic Hamiltonian is the transverse-field
Ising model, which is defined as</p>
<div class="math notranslate nohighlight">
\[\hat{H}_{\text{Ising}}(\boldsymbol\theta) \ = \ \displaystyle\sum_{(i, j) \in E}
\theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \
\displaystyle\sum_{i} X_{i},\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol\theta \ = \ \{\theta^{(1)}, \ \theta^{(2)}\}\)</span>.
In this Hamiltonian, the set <span class="math notranslate nohighlight">\(E\)</span> that determines which pairs of qubits
have <span class="math notranslate nohighlight">\(ZZ\)</span> interactions can be represented by the set of edges for some graph. With
the qubits as nodes, this graph is called the <em>interaction graph</em>.
The <span class="math notranslate nohighlight">\(\theta^{(1)}\)</span> parameters correspond to the edge weights and
the <span class="math notranslate nohighlight">\(\theta^{(2)}\)</span>
parameters correspond to weights on the nodes.</p>
<p>This result implies that we can think about <em>quantum circuits</em> with
graph-theoretic properties. Recall that the time-evolution operator
with respect to some Hamiltonian <span class="math notranslate nohighlight">\(H\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[U \ = \ e^{-it H}.\]</div>
<p>Thus, we have a clean way of taking quadratic Hamiltonians and turning
them into unitaries (quantum circuits) that preserve the same correspondance to a graph.
In the case of the Ising Hamiltonian, we have:</p>
<div class="math notranslate nohighlight">
\[U_{\text{Ising}} \ = \ e^{-it \hat{H}_{\text{Ising}} (\boldsymbol\theta)} \ = \ \exp \Big[ -it
\Big( \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \
\displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i} \Big) \Big]\]</div>
<p>In general, this kind of unitary is very difficult to implement on a quantum computer.
However, we can approximate it using the <a class="reference external" href="https://en.wikipedia.org/wiki/Time-evolving_block_decimation#The_Suzuki-Trotter_expansion">Trotter-Suzuki decomposition</a>:</p>
<div class="math notranslate nohighlight">
\[\exp \Big[ -it \Big( \displaystyle\sum_{(i, j) \in E} \theta_{ij}^{(1)} Z_{i} Z_{j} \ + \
\displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \ \displaystyle\sum_{i} X_{i} \Big) \Big]
\ \approx \ \displaystyle\prod_{k \ = \ 1}^{t / \Delta} \Bigg[ \displaystyle\prod_{j \ = \
1}^{Q} e^{-i \Delta \hat{H}_{\text{Ising}}^{j}(\boldsymbol\theta)} \Bigg]\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{H}_{\text{Ising}}^{j}(\boldsymbol\theta)\)</span> is the <span class="math notranslate nohighlight">\(j\)</span>-th term of the
Ising Hamiltonian and <span class="math notranslate nohighlight">\(\Delta\)</span> is some small number.</p>
<p>This circuit is a specific instance of the <strong>Quantum Graph
Recurrent Neural Network</strong>, which in general is defined as a variational ansatz of
the form</p>
<div class="math notranslate nohighlight">
\[U_{H}(\boldsymbol\mu, \ \boldsymbol\gamma) \ = \ \displaystyle\prod_{i \ = \ 1}^{P} \Bigg[
\displaystyle\prod_{j \ = \ 1}^{Q} e^{-i \gamma_j H^{j}(\boldsymbol\mu)} \Bigg],\]</div>
<p>for some parametrized quadratic Hamiltonian, <span class="math notranslate nohighlight">\(H(\boldsymbol\mu)\)</span>.</p>
<div class="section" id="using-the-qgrnn">
<h3>Using the QGRNN<a class="headerlink" href="#using-the-qgrnn" title="Permalink to this headline">¶</a></h3>
<p>Since the QGRNN ansatz is equivalent to the
approximate time evolution of some quadratic Hamiltonian, we can use it
to learn the dynamics of a quantum system.</p>
<p>Continuing with the Ising model example, let’s imagine we have some system
governed by <span class="math notranslate nohighlight">\(\hat{H}_{\text{Ising}}(\boldsymbol\alpha)\)</span> for an unknown set of
target parameters,
<span class="math notranslate nohighlight">\(\boldsymbol\alpha\)</span> and an unknown interaction graph <span class="math notranslate nohighlight">\(G\)</span>. Let’s also
suppose we have access to copies of some
low-energy, non-ground state of the target Hamiltonian, <span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span>. In addition,
we have access to a collection of time-evolved states,
<span class="math notranslate nohighlight">\(\{ |\psi(t_1)\rangle, \ |\psi(t_2)\rangle, \ ..., \ |\psi(t_N)\rangle \}\)</span>, defined by:</p>
<div class="math notranslate nohighlight">
\[|\psi(t_k)\rangle \ = \ e^{-i t_k \hat{H}_{\text{Ising}}(\boldsymbol\alpha)} |\psi_0\rangle.\]</div>
<p>We call the low-energy states and the collection of time-evolved states <em>quantum data</em>.
From here, we randomly pick a number of time-evolved states
from our collection. For any state that we choose, which is
evolved to some time <span class="math notranslate nohighlight">\(t_k\)</span>, we compare it
to</p>
<div class="math notranslate nohighlight">
\[U_{\hat{H}_{\text{Ising}}}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle \ \approx \ e^{-i t_k
\hat{H}_{\text{Ising}}(\boldsymbol\mu)} |\psi_0\rangle.\]</div>
<p>This is done by feeding one of the copies of <span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span> into a quantum circuit
with the QGRNN ansatz, with some guessed set of parameters <span class="math notranslate nohighlight">\(\boldsymbol\mu\)</span>
and a guessed interaction graph, <span class="math notranslate nohighlight">\(G'\)</span>.
We then use a classical optimizer to maximize the average
“similarity” between the time-evolved states and the states prepared
with the QGRNN.</p>
<p>As the QGRNN states becomes more similar to
each time-evolved state for each sampled time, it follows that
<span class="math notranslate nohighlight">\(\boldsymbol\mu \ \rightarrow \ \boldsymbol\alpha\)</span>
and we are able to learn the unknown parameters of the Hamiltonian.</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="../_images/qgrnn3.png"><img alt="../_images/qgrnn3.png" src="../_images/qgrnn3.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">A visual representation of one execution of the QGRNN for one piece of quantum data.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="learning-an-ising-model-with-the-qgrnn">
<h2>Learning an Ising Model with the QGRNN<a class="headerlink" href="#learning-an-ising-model-with-the-qgrnn" title="Permalink to this headline">¶</a></h2>
<p>We now attempt to use the QGRNN to learn the parameters corresponding
to an arbitrary transverse-field Ising model Hamiltonian.</p>
<div class="section" id="getting-started">
<h3>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h3>
<p>We begin by importing the necessary dependencies:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">copy</span>
</pre></div>
</div>
<p>We also define some fixed values that are used throughout
the simulation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qubit_number</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">)</span>
</pre></div>
</div>
<p>In this
simulation, we don’t have quantum data readily available to pass into
the QGRNN, so we have to generate it ourselves. To do this, we must
have knowledge of the target interaction graph and the target Hamiltonian.</p>
<p>Let us use the following cyclic graph as the target interaction graph
of the Ising Hamiltonian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ising_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edges: </span><span class="si">{</span><span class="n">ising_graph</span><span class="o">.</span><span class="n">edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ising_graph</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_qgrnn_001.png" srcset="../_images/sphx_glr_tutorial_qgrnn_001.png" alt="tutorial qgrnn" class = "sphx-glr-single-img"/><p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Edges: [(0, 1), (0, 3), (1, 2), (2, 3)]
</pre></div>
</div>
<p>We can then initialize the “unknown” target parameters that describe the
target Hamiltonian, <span class="math notranslate nohighlight">\(\boldsymbol\alpha \ = \ \{\alpha^{(1)}, \ \alpha^{(2)}\}\)</span>.
Recall from the introduction that we have defined our parametrized
Ising Hamiltonian to be of the form:</p>
<div class="math notranslate nohighlight">
\[\hat{H}_{\text{Ising}}(\boldsymbol\theta) \ = \ \displaystyle\sum_{(i, j) \in E}
\theta_{ij}^{(1)} Z_{i} Z_{j} \ + \ \displaystyle\sum_{i} \theta_{i}^{(2)} Z_{i} \ + \
\displaystyle\sum_{i} X_{i},\]</div>
<p>where <span class="math notranslate nohighlight">\(E\)</span> is the set of edges in the interaction graph, and
<span class="math notranslate nohighlight">\(X_i\)</span> and <span class="math notranslate nohighlight">\(Z_i\)</span> are the Pauli-X and Pauli-Z on the
<span class="math notranslate nohighlight">\(i\)</span>-th qubit.</p>
<p>For this tutorial, we choose the target parameters by sampling from
a uniform probability distribution ranging from <span class="math notranslate nohighlight">\(-2\)</span> to <span class="math notranslate nohighlight">\(2\)</span>, with
two-decimal precision.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">target_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.56</span><span class="p">,</span> <span class="mf">1.24</span><span class="p">,</span> <span class="mf">1.67</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.79</span><span class="p">]</span>
<span class="n">target_bias</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.44</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.43</span><span class="p">,</span> <span class="mf">1.18</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.93</span><span class="p">]</span>
</pre></div>
</div>
<p>In theory, these parameters can
be any value we want, provided they are reasonably small enough that the QGRNN can reach them
in a tractable number of optimization steps.
In <code class="docutils literal notranslate"><span class="pre">matrix_params</span></code>, the first list represents the <span class="math notranslate nohighlight">\(ZZ\)</span> interaction parameters and
the second list represents the single-qubit <span class="math notranslate nohighlight">\(Z\)</span> parameters.</p>
<p>Finally,
we use this information to generate the matrix form of the
Ising model Hamiltonian in the computational basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_hamiltonian_matrix</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">):</span>

    <span class="n">full_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_qubits</span><span class="p">))</span>

    <span class="c1"># Creates the interaction component of the Hamiltonian</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
        <span class="n">interaction_term</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
                <span class="n">interaction_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">interaction_term</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">)(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interaction_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">interaction_term</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">full_matrix</span> <span class="o">+=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">interaction_term</span>

    <span class="c1"># Creates the bias components of the matrix</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>
        <span class="n">z_term</span> <span class="o">=</span> <span class="n">x_term</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">z_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">z_term</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">)(</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">x_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">x_term</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.op_transform.html#pennylane.op_transform" title="pennylane.op_transform" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qml</span><span class="o">.</span><span class="n">matrix</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliX.html#pennylane.PauliX" title="pennylane.PauliX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliX</span></a><span class="p">)(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">z_term</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">x_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">x_term</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">full_matrix</span> <span class="o">+=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">z_term</span> <span class="o">+</span> <span class="n">x_term</span>

    <span class="k">return</span> <span class="n">full_matrix</span>


<span class="c1"># Prints a visual representation of the Hamiltonian matrix</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham_matrix</span></a> <span class="o">=</span> <span class="n">create_hamiltonian_matrix</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">,</span> <span class="n">ising_graph</span><span class="p">,</span> <span class="n">target_weights</span><span class="p">,</span> <span class="n">target_bias</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham_matrix</span></a><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;hot&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_qgrnn_002.png" srcset="../_images/sphx_glr_tutorial_qgrnn_002.png" alt="tutorial qgrnn" class = "sphx-glr-single-img"/></div>
<div class="section" id="preparing-quantum-data">
<h3>Preparing Quantum Data<a class="headerlink" href="#preparing-quantum-data" title="Permalink to this headline">¶</a></h3>
<p>The collection of quantum data needed to run the QGRNN has two components:
(i) copies of a low-energy state, and (ii) a collection of time-evolved states, each of which are
simply the low-energy state evolved to different times.
The following is a low-energy state of the target Hamiltonian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">low_energy_state</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.054661080280306085</span> <span class="o">+</span> <span class="mf">0.016713907320174026</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.12290003656489545</span> <span class="o">-</span> <span class="mf">0.03758500591109822</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.3649337966440005</span> <span class="o">-</span> <span class="mf">0.11158863596657455</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.8205175732627094</span> <span class="o">+</span> <span class="mf">0.25093231967092877</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.010369790825776609</span> <span class="o">-</span> <span class="mf">0.0031706387262686003</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.02331544978544721</span> <span class="o">+</span> <span class="mf">0.007129899300113728</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.06923183949694546</span> <span class="o">+</span> <span class="mf">0.0211684344103713</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.15566094863283836</span> <span class="o">-</span> <span class="mf">0.04760201916285508</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.014520590919500158</span> <span class="o">-</span> <span class="mf">0.004441887836078486</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.032648113364535575</span> <span class="o">+</span> <span class="mf">0.009988590222879195</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.09694382811137187</span> <span class="o">+</span> <span class="mf">0.02965579457620536</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.21796861485652747</span> <span class="o">-</span> <span class="mf">0.06668776658411019</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.0027547112135013247</span> <span class="o">+</span> <span class="mf">0.0008426289322652901</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.006193695872468649</span> <span class="o">-</span> <span class="mf">0.0018948418969390599</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.018391279795405405</span> <span class="o">-</span> <span class="mf">0.005625722994009138</span><span class="n">j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.041350974715649635</span> <span class="o">+</span> <span class="mf">0.012650711602265649</span><span class="n">j</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>This state can be obtained by using a decoupled version of the
<a class="reference internal" href="tutorial_vqe.html"><span class="doc">Variational Quantum Eigensolver</span></a> algorithm (VQE).
Essentially, we choose a
VQE ansatz such that the circuit cannot learn the exact ground state,
but it can get fairly close. Another way to arrive at the same result is
to perform VQE with a reasonable ansatz, but to terminate the algorithm
before it converges to the ground state. If we used the exact ground state
<span class="math notranslate nohighlight">\(|\psi_0\rangle\)</span>, the time-dependence would be trivial and the
data would not provide enough information about the Hamiltonian parameters.</p>
<p>We can verify that this is a low-energy
state by numerically finding the lowest eigenvalue of the Hamiltonian
and comparing it to the energy expectation of this low-energy state:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">low_energy_state</span><span class="p">,</span> <span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham_matrix</span></a> <span class="o">@</span> <span class="n">low_energy_state</span><span class="p">))</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">energy_exp</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Energy Expectation: </span><span class="si">{</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">energy_exp</span></a><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ground_state_energy</span></a> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham_matrix</span></a><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ground State Energy: </span><span class="si">{</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ground_state_energy</span></a><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Energy Expectation: -7.244508985189116
Ground State Energy: -7.330689661291261
</pre></div>
</div>
<p>We have in fact found a low-energy, non-ground state,
as the energy expectation is slightly greater than the energy of the true ground
state. This, however, is only half of the information we need. We also require
a collection of time-evolved, low-energy states.
Evolving the low-energy state forward in time is fairly straightforward: all we
have to do is multiply the initial state by a time-evolution unitary. This operation
can be defined as a custom gate in PennyLane:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">state_evolve</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">hamiltonian</span> <span class="o">*</span> <span class="n">time</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>
</pre></div>
</div>
<p>We don’t actually generate time-evolved quantum data quite yet,
but we now have all the pieces required for its preparation.</p>
</div>
<div class="section" id="learning-the-hamiltonian">
<h3>Learning the Hamiltonian<a class="headerlink" href="#learning-the-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>With the quantum data defined, we are able to construct the QGRNN and
learn the target Hamiltonian.
Each of the exponentiated
Hamiltonians in the QGRNN ansatz,
<span class="math notranslate nohighlight">\(\hat{H}^{j}_{\text{Ising}}(\boldsymbol\mu)\)</span>, are the
<span class="math notranslate nohighlight">\(ZZ\)</span>, <span class="math notranslate nohighlight">\(Z\)</span>, and <span class="math notranslate nohighlight">\(X\)</span> terms from the Ising
Hamiltonian. This gives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qgrnn_layer</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">trotter_step</span><span class="p">):</span>

    <span class="c1"># Applies a layer of RZZ gates (based on a graph)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.MultiRZ.html#pennylane.MultiRZ" title="pennylane.MultiRZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">MultiRZ</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">trotter_step</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Applies a layer of RZ gates</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">trotter_step</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">qubit</span><span class="p">)</span>

    <span class="c1"># Applies a layer of RX gates</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RX.html#pennylane.RX" title="pennylane.RX" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RX</span></a><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trotter_step</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">qubit</span><span class="p">)</span>
</pre></div>
</div>
<p>As was mentioned in the first section, the QGRNN has two
registers. In one register, some piece of quantum data
<span class="math notranslate nohighlight">\(|\psi(t)\rangle\)</span> is prepared and in the other we have
<span class="math notranslate nohighlight">\(U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle\)</span>. We need a
way to measure the similarity between these states.
This can be done by using the fidelity, which is
simply the modulus squared of the inner product between the states,
<span class="math notranslate nohighlight">\(| \langle \psi(t) | U_{H}(\Delta, \ \boldsymbol\mu) |\psi_0\rangle |^2\)</span>.
To calculate this value, we use a <a class="reference external" href="https://en.wikipedia.org/wiki/Swap_test">SWAP
test</a> between the registers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">swap_test</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">register1</span><span class="p">,</span> <span class="n">register2</span><span class="p">):</span>

    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">control</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">reg1_qubit</span><span class="p">,</span> <span class="n">reg2_qubit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">register1</span><span class="p">,</span> <span class="n">register2</span><span class="p">):</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.CSWAP.html#pennylane.CSWAP" title="pennylane.CSWAP" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">CSWAP</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">reg1_qubit</span><span class="p">,</span> <span class="n">reg2_qubit</span><span class="p">))</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hadamard.html#pennylane.Hadamard" title="pennylane.Hadamard" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hadamard</span></a><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="n">control</span><span class="p">)</span>
</pre></div>
</div>
<p>After performing this procedure, the value returned from a measurement of the circuit is
<span class="math notranslate nohighlight">\(\langle Z \rangle\)</span>, with respect to the <code class="docutils literal notranslate"><span class="pre">control</span></code> qubit.
The probability of measuring the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state
in this control qubit is related to both the fidelity
between registers and <span class="math notranslate nohighlight">\(\langle Z \rangle\)</span>. Thus, with a bit of algebra,
we find that <span class="math notranslate nohighlight">\(\langle Z \rangle\)</span> is equal to the fidelity.</p>
<p>Before creating the full QGRNN and the cost function, we
define a few more fixed values. Among these is a “guessed”
interaction graph, which we set to be a
<a class="reference external" href="https://en.wikipedia.org/wiki/Complete_graph">complete graph</a>. This choice is
motivated by the fact that any target interaction graph will be a subgraph
of this initial guess. Part of the idea behind the QGRNN is that
we don’t know the interaction graph, and it has to be learned. In this case, the graph
is learned <em>automatically</em> as the target parameters are optimized. The
<span class="math notranslate nohighlight">\(\boldsymbol\mu\)</span> parameters that correspond to edges that don’t exist in
the target graph will simply approach <span class="math notranslate nohighlight">\(0\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Defines some fixed values</span>

<span class="n">reg1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">))</span>  <span class="c1"># First qubit register</span>
<span class="n">reg2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qubit_number</span><span class="p">))</span>  <span class="c1"># Second qubit register</span>

<span class="n">control</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">qubit_number</span>  <span class="c1"># Index of control qubit</span>
<span class="n">trotter_step</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># Trotter step size</span>

<span class="c1"># Defines the interaction graph for the new qubit system</span>

<span class="n">new_ising_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">reg2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edges: </span><span class="si">{</span><span class="n">new_ising_graph</span><span class="o">.</span><span class="n">edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">new_ising_graph</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_qgrnn_003.png" srcset="../_images/sphx_glr_tutorial_qgrnn_003.png" alt="tutorial qgrnn" class = "sphx-glr-single-img"/><p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Edges: [(4, 5), (4, 6), (4, 7), (5, 6), (5, 7), (6, 7)]
</pre></div>
</div>
<p>With this done, we implement the QGRNN circuit for some given time value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qgrnn</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="c1"># Prepares the low energy state in the two registers</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">low_energy_state</span><span class="p">,</span> <span class="n">low_energy_state</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="n">reg1</span> <span class="o">+</span> <span class="n">reg2</span><span class="p">)</span>

    <span class="c1"># Evolves the first qubit register with the time-evolution circuit to</span>
    <span class="c1"># prepare a piece of quantum data</span>
    <span class="n">state_evolve</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham_matrix</span></a><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>

    <span class="c1"># Applies the QGRNN layers to the second qubit register</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">time</span> <span class="o">/</span> <span class="n">trotter_step</span>  <span class="c1"># P = t/Delta</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">depth</span><span class="p">)):</span>
        <span class="n">qgrnn_layer</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">,</span> <span class="n">reg2</span><span class="p">,</span> <span class="n">new_ising_graph</span><span class="p">,</span> <span class="n">trotter_step</span><span class="p">)</span>

    <span class="c1"># Applies the SWAP test between the registers</span>
    <span class="n">swap_test</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span>

    <span class="c1"># Returns the results of the SWAP test</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.PauliZ.html#pennylane.PauliZ" title="pennylane.PauliZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">PauliZ</span></a><span class="p">(</span><span class="n">control</span><span class="p">))</span>
</pre></div>
</div>
<p>We have the full QGRNN circuit, but we still need to define a cost function.
We know that
<span class="math notranslate nohighlight">\(| \langle \psi(t) | U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle |^2\)</span>
approaches <span class="math notranslate nohighlight">\(1\)</span> as the states become more similar and approaches
<span class="math notranslate nohighlight">\(0\)</span> as the states become orthogonal. Thus, we choose
to minimize the quantity
<span class="math notranslate nohighlight">\(-| \langle \psi(t) | U_{H}(\boldsymbol\mu, \ \Delta) |\psi_0\rangle |^2\)</span>.
Since we are interested in calculating this value for many different
pieces of quantum data, the final cost function is the average
negative fidelity* between registers:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\boldsymbol\mu, \ \Delta) \ = \ - \frac{1}{N} \displaystyle\sum_{i \ = \ 1}^{N} |
\langle \psi(t_i) | \ U_{H}(\boldsymbol\mu, \ \Delta) \ |\psi_0\rangle |^2,\]</div>
<p>where we use <span class="math notranslate nohighlight">\(N\)</span> pieces of quantum data.</p>
<p>Before creating the cost function, we must define a few more fixed
variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">15</span>  <span class="c1"># The number of pieces of quantum data that are used for each step</span>
<span class="n">max_time</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># The maximum value of time that can be used for quantum data</span>
</pre></div>
</div>
<p>We then define the negative fidelity cost function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">weight_params</span><span class="p">,</span> <span class="n">bias_params</span><span class="p">):</span>

    <span class="c1"># Randomly samples times at which the QGRNN runs</span>
    <span class="n">times_sampled</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_time</span>

    <span class="c1"># Cycles through each of the sampled times and calculates the cost</span>
    <span class="n">total_cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">times_sampled</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qgrnn_qnode</span></a><span class="p">(</span><span class="n">weight_params</span><span class="p">,</span> <span class="n">bias_params</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">total_cost</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">total_cost</span> <span class="o">/</span> <span class="n">N</span>
</pre></div>
</div>
<p>Next we set up for optimization.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Defines the new device</span>
<span class="n">qgrnn_dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">qubit_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Defines the new QNode</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qgrnn_qnode</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QNode</span></a><span class="p">(</span><span class="n">qgrnn</span><span class="p">,</span> <span class="n">qgrnn_dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;autograd&quot;</span><span class="p">)</span>

<span class="n">steps</span> <span class="o">=</span> <span class="mi">300</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">optimizer</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer" title="pennylane.AdamOptimizer" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">AdamOptimizer</span></a><span class="p">(</span><span class="n">stepsize</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_ising_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">qubit_number</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">initial_weights</span></a> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">)</span>
<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">initial_bias</span></a> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">)</span>
</pre></div>
</div>
<p>All that remains is executing the optimization loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
    <span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost</span></a> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.AdamOptimizer.html#pennylane.AdamOptimizer.step_and_cost" title="pennylane.AdamOptimizer.step_and_cost" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-method"><span class="n">optimizer</span><span class="o">.</span><span class="n">step_and_cost</span></a><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">)</span>

    <span class="c1"># Prints the value of the cost function</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cost at Step </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost</span></a><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Weights at Step </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bias at Step </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---------------------------------------------&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Cost at Step 0: -0.9803638573791951
Weights at Step 0: [-0.22603613  0.43887001  0.85859236  0.69735898  0.09417125 -0.02437147]
Bias at Step 0: [-0.23884748 -0.21392016  0.12809368  0.45037793]
---------------------------------------------
Cost at Step 5: -0.9974589524428065
Weights at Step 5: [-0.75106068  1.078707    0.83766935  1.9741555   0.04982793 -0.06747815]
Bias at Step 5: [-0.50836435 -1.32708118  1.57468372  0.11442806]
---------------------------------------------
Cost at Step 10: -0.9971878268304836
Weights at Step 10: [ 0.01577799  0.48771566  0.68379977  1.75747002 -0.21948418 -0.00484698]
Bias at Step 10: [ 0.22007905 -0.90282076  1.58989008 -0.1051542 ]
---------------------------------------------
Cost at Step 15: -0.9981871533122783
Weights at Step 15: [-0.06744249  0.65720464  1.31471457  1.47430241  0.05813038 -0.41315658]
Bias at Step 15: [-0.29045223 -0.67045595  1.19395446  0.24677711]
---------------------------------------------
Cost at Step 20: -0.9995130692146906
Weights at Step 20: [-0.16225009  0.66208813  1.17758061  1.48254064 -0.35468207 -0.01648733]
Bias at Step 20: [-0.56832881 -0.87721581  0.86890622 -0.27734217]
---------------------------------------------
Cost at Step 25: -0.9998181560069601
Weights at Step 25: [ 0.030689    0.40363412  1.32430282  1.80692972 -0.14761078 -0.27452275]
Bias at Step 25: [-0.33695681 -1.28646051  1.00509121 -0.19672993]
---------------------------------------------
Cost at Step 30: -0.9997713453918171
Weights at Step 30: [ 0.22014178  0.38063046  1.34934589  1.82854127 -0.201276   -0.35610913]
Bias at Step 30: [-0.40515586 -1.19466624  1.13933672 -0.31753371]
---------------------------------------------
Cost at Step 35: -0.9997858632135197
Weights at Step 35: [ 0.22310889  0.50896099  1.36029033  1.73588161 -0.30076632 -0.35201799]
Bias at Step 35: [-0.73605504 -1.06150682  1.07911402 -0.49331792]
---------------------------------------------
Cost at Step 40: -0.9998587245201078
Weights at Step 40: [ 0.32580831  0.34293483  1.38813471  1.76261455 -0.16880133 -0.49831078]
Bias at Step 40: [-0.74534508 -1.20379495  0.91916721 -0.49099848]
---------------------------------------------
Cost at Step 45: -0.9998796449154754
Weights at Step 45: [ 0.37151473  0.26329833  1.29149206  1.84754531 -0.16287055 -0.51793342]
Bias at Step 45: [-0.81082195 -1.35860008  0.88788716 -0.63818331]
---------------------------------------------
Cost at Step 50: -0.9999381279674843
Weights at Step 50: [ 0.36839385  0.36200243  1.3398256   1.82138962 -0.10863003 -0.63499473]
Bias at Step 50: [-1.04909977 -1.27581779  0.93902928 -0.67286639]
---------------------------------------------
Cost at Step 55: -0.999925288139168
Weights at Step 55: [ 0.52717503  0.22669791  1.27477846  1.75733597 -0.1195999  -0.66147384]
Bias at Step 55: [-1.02458911 -1.19668936  0.89787258 -0.76851797]
---------------------------------------------
Cost at Step 60: -0.9999298586216679
Weights at Step 60: [ 0.46426344  0.2377941   1.30579533  1.86309089 -0.05164041 -0.72495523]
Bias at Step 60: [-1.15189323 -1.3565901   0.92299357 -0.81716179]
---------------------------------------------
Cost at Step 65: -0.9999633163685169
Weights at Step 65: [ 0.54814165  0.15321249  1.29421602  1.79468038 -0.06551864 -0.73442872]
Bias at Step 65: [-1.18093812 -1.2850757   0.8715214  -0.89498456]
---------------------------------------------
Cost at Step 70: -0.9999692974112414
Weights at Step 70: [ 0.54968362  0.15363051  1.32636004  1.81799545 -0.03795287 -0.78176424]
Bias at Step 70: [-1.26004878 -1.29186174  0.93275685 -0.93151559]
---------------------------------------------
Cost at Step 75: -0.9999839418036033
Weights at Step 75: [ 0.56926778  0.09899053  1.32784104  1.83800055 -0.02258999 -0.80100631]
Bias at Step 75: [-1.27844754 -1.32707392  0.95121289 -0.97776518]
---------------------------------------------
Cost at Step 80: -0.9999900754964208
Weights at Step 80: [ 0.58436296  0.06469565  1.33177097  1.80638755 -0.0264562  -0.80504093]
Bias at Step 80: [-1.32003524 -1.30314422  0.93367031 -1.02093595]
---------------------------------------------
Cost at Step 85: -0.9999892005586446
Weights at Step 85: [ 5.76118484e-01  5.92975577e-02  1.35458994e+00  1.82562544e+00
 -6.90843714e-04 -8.37859294e-01]
Bias at Step 85: [-1.35783384 -1.32173749  0.97374052 -1.02956436]
---------------------------------------------
Cost at Step 90: -0.9999860418671456
Weights at Step 90: [ 0.60406684  0.01793718  1.33218637  1.81633306 -0.0189833  -0.82575128]
Bias at Step 90: [-1.35074923 -1.31381294  0.98189172 -1.07270478]
---------------------------------------------
Cost at Step 95: -0.9999837519650716
Weights at Step 95: [ 0.58241323  0.02570679  1.35041725  1.81039596  0.00900262 -0.85399323]
Bias at Step 95: [-1.39511753 -1.32055157  0.98642234 -1.06137202]
---------------------------------------------
Cost at Step 100: -0.9999862374755413
Weights at Step 100: [ 0.59133649  0.00671959  1.33149619  1.80654252  0.00739735 -0.85271751]
Bias at Step 100: [-1.3928395  -1.32434117  0.99986843 -1.0746036 ]
---------------------------------------------
Cost at Step 105: -0.9999860417314536
Weights at Step 105: [ 5.98294601e-01 -1.63872117e-03  1.32435903e+00  1.79606830e+00
 -1.50600209e-03 -8.46854780e-01]
Bias at Step 105: [-1.39810406 -1.31716394  1.00632966 -1.08694727]
---------------------------------------------
Cost at Step 110: -0.9999889448376583
Weights at Step 110: [ 0.58790075  0.00252021  1.34070893  1.79969067  0.01353978 -0.86073241]
Bias at Step 110: [-1.41237809 -1.33237829  1.01344356 -1.07306401]
---------------------------------------------
Cost at Step 115: -0.9999907527375081
Weights at Step 115: [ 0.59511523 -0.00485992  1.33269226  1.79443191  0.00548165 -0.85246429]
Bias at Step 115: [-1.40713813 -1.33369881  1.02023634 -1.07811166]
---------------------------------------------
Cost at Step 120: -0.9999894991115524
Weights at Step 120: [ 5.96065192e-01 -3.92737036e-03  1.33288381e+00  1.78858855e+00
  1.75644333e-03 -8.48477853e-01]
Bias at Step 120: [-1.40998319 -1.33422301  1.02362295 -1.07680692]
---------------------------------------------
Cost at Step 125: -0.9999921833903894
Weights at Step 125: [ 5.91985767e-01 -1.57241251e-03  1.33882177e+00  1.79191152e+00
  8.89983556e-03 -8.53306759e-01]
Bias at Step 125: [-1.41164517 -1.34685868  1.0288417  -1.06603474]
---------------------------------------------
Cost at Step 130: -0.9999895629847527
Weights at Step 130: [ 5.93396935e-01 -6.09903975e-04  1.32769014e+00  1.78340627e+00
  3.20989912e-03 -8.45936030e-01]
Bias at Step 130: [-1.41153989 -1.34372306  1.0306921  -1.06641934]
---------------------------------------------
Cost at Step 135: -0.9999893671898585
Weights at Step 135: [ 5.93933082e-01 -1.84879055e-04  1.32433785e+00  1.77929886e+00
  4.38714188e-03 -8.45503125e-01]
Bias at Step 135: [-1.4098866  -1.34497204  1.03415862 -1.06007092]
---------------------------------------------
Cost at Step 140: -0.9999909995915355
Weights at Step 140: [ 0.5908483   0.00239647  1.33016899  1.78168215  0.00438378 -0.84478361]
Bias at Step 140: [-1.41145547 -1.35249113  1.0371159  -1.05630093]
---------------------------------------------
Cost at Step 145: -0.9999882781659966
Weights at Step 145: [ 5.95379262e-01 -3.85481762e-04  1.33209614e+00  1.77901613e+00
 -1.07423798e-03 -8.40357066e-01]
Bias at Step 145: [-1.40745547 -1.35117282  1.03764696 -1.05779208]
---------------------------------------------
Cost at Step 150: -0.9999882605157393
Weights at Step 150: [ 0.59753863 -0.00178702  1.33577445  1.78058366 -0.00414765 -0.83825161]
Bias at Step 150: [-1.40514789 -1.35375725  1.03826782 -1.05953418]
---------------------------------------------
Cost at Step 155: -0.9999873092858359
Weights at Step 155: [ 5.96677467e-01  6.17989620e-04  1.34466485e+00  1.78402267e+00
 -2.65741532e-03 -8.41450495e-01]
Bias at Step 155: [-1.40789298 -1.356471    1.0376034  -1.05877886]
---------------------------------------------
Cost at Step 160: -0.9999872637771781
Weights at Step 160: [ 0.60194839 -0.00191478  1.35123357  1.7884694  -0.00603744 -0.84142449]
Bias at Step 160: [-1.40510396 -1.35668892  1.03451132 -1.06543631]
---------------------------------------------
Cost at Step 165: -0.9999874624869814
Weights at Step 165: [ 0.6030402  -0.00193504  1.34611742  1.78890714 -0.00577061 -0.84238872]
Bias at Step 165: [-1.40613555 -1.35445251  1.02812253 -1.07090041]
---------------------------------------------
Cost at Step 170: -0.9999886747321731
Weights at Step 170: [ 0.5975333   0.00282116  1.32780927  1.78277225  0.00466827 -0.84919749]
Bias at Step 170: [-1.41126245 -1.34857858  1.02684163 -1.0645541 ]
---------------------------------------------
Cost at Step 175: -0.9999875562507266
Weights at Step 175: [ 0.59389571  0.00440434  1.32168971  1.78088367  0.00772899 -0.85019789]
Bias at Step 175: [-1.41279703 -1.34685714  1.02847119 -1.06186318]
---------------------------------------------
Cost at Step 180: -0.9999914836764869
Weights at Step 180: [ 5.95476507e-01  1.04646713e-03  1.33253375e+00  1.78379408e+00
  1.79045580e-03 -8.45539923e-01]
Bias at Step 180: [-1.40924345 -1.34843997  1.03054894 -1.06465758]
---------------------------------------------
Cost at Step 185: -0.9999877384049646
Weights at Step 185: [ 0.60021817 -0.00344807  1.34837992  1.78919267 -0.00485391 -0.84211998]
Bias at Step 185: [-1.40406354 -1.35059434  1.03159602 -1.06906187]
---------------------------------------------
Cost at Step 190: -0.999994381128065
Weights at Step 190: [ 0.60332647 -0.00502377  1.35580211  1.7937833  -0.00870162 -0.84089377]
Bias at Step 190: [-1.40248031 -1.35189812  1.02840358 -1.07489377]
---------------------------------------------
Cost at Step 195: -0.9999899532834544
Weights at Step 195: [ 6.01661213e-01 -1.40258189e-03  1.34845381e+00  1.79177947e+00
 -2.19330435e-03 -8.46882171e-01]
Bias at Step 195: [-1.40624231 -1.34827409  1.02488298 -1.07228167]
---------------------------------------------
Cost at Step 200: -0.9999880990041669
Weights at Step 200: [ 0.59781588  0.00262681  1.33622645  1.7903236   0.00491206 -0.85187394]
Bias at Step 200: [-1.41001483 -1.3468901   1.02276916 -1.06950677]
---------------------------------------------
Cost at Step 205: -0.9999882388738703
Weights at Step 205: [ 0.59525242  0.00459556  1.33045933  1.78843797  0.00647584 -0.85208423]
Bias at Step 205: [-1.41193406 -1.34513748  1.02230177 -1.06854427]
---------------------------------------------
Cost at Step 210: -0.9999848077040225
Weights at Step 210: [ 0.59407847  0.00331191  1.3261464   1.78462336  0.00583158 -0.84928496]
Bias at Step 210: [-1.40995186 -1.34363827  1.02517197 -1.06554306]
---------------------------------------------
Cost at Step 215: -0.9999886167575471
Weights at Step 215: [ 5.93598280e-01  1.27457027e-03  1.32894414e+00  1.78302258e+00
  3.44879382e-03 -8.45638843e-01]
Bias at Step 215: [-1.40701621 -1.34498189  1.03023459 -1.06215846]
---------------------------------------------
Cost at Step 220: -0.9999875727826226
Weights at Step 220: [ 5.94793970e-01 -8.57403941e-04  1.33609793e+00  1.78453102e+00
 -2.17937735e-03 -8.40640138e-01]
Bias at Step 220: [-1.40459538 -1.34840612  1.03328985 -1.06323676]
---------------------------------------------
Cost at Step 225: -0.9999895237582359
Weights at Step 225: [ 0.59740767 -0.00202435  1.33963888  1.78462403 -0.00566848 -0.83842794]
Bias at Step 225: [-1.40352872 -1.34909283  1.03367034 -1.0646202 ]
---------------------------------------------
Cost at Step 230: -0.9999922217151871
Weights at Step 230: [ 0.59830589 -0.00184753  1.33406652  1.78177535 -0.00330205 -0.84015047]
Bias at Step 230: [-1.40427031 -1.34839966  1.03168677 -1.06292291]
---------------------------------------------
Cost at Step 235: -0.9999912692867956
Weights at Step 235: [ 5.95836686e-01  8.57240159e-04  1.32786532e+00  1.78035155e+00
  2.56153005e-03 -8.44403818e-01]
Bias at Step 235: [-1.40725255 -1.34955664  1.03260437 -1.05840103]
---------------------------------------------
Cost at Step 240: -0.9999899357699936
Weights at Step 240: [ 0.59351612  0.00209534  1.32485259  1.77824259  0.00444528 -0.8447466 ]
Bias at Step 240: [-1.40903945 -1.35042747  1.03478287 -1.05550792]
---------------------------------------------
Cost at Step 245: -0.9999889869569236
Weights at Step 245: [ 5.95395532e-01  1.23721713e-03  1.33593185e+00  1.78146341e+00
 -1.83303336e-03 -8.40987115e-01]
Bias at Step 245: [-1.40856761 -1.35225776  1.03748333 -1.05978839]
---------------------------------------------
Cost at Step 250: -0.9999881293170535
Weights at Step 250: [ 5.95495047e-01 -2.18886873e-04  1.33760142e+00  1.78252108e+00
 -1.04388862e-03 -8.41650674e-01]
Bias at Step 250: [-1.40788422 -1.35473503  1.03617744 -1.05980154]
---------------------------------------------
Cost at Step 255: -0.999989261380938
Weights at Step 255: [ 5.95095996e-01  1.05345945e-03  1.33120954e+00  1.78110699e+00
  9.09621038e-04 -8.43176791e-01]
Bias at Step 255: [-1.40881827 -1.35271576  1.03732158 -1.05936317]
---------------------------------------------
Cost at Step 260: -0.9999911696516867
Weights at Step 260: [ 0.59215329  0.00249312  1.32162048  1.77469111  0.00411753 -0.84385295]
Bias at Step 260: [-1.41164782 -1.34921326  1.03505213 -1.05565234]
---------------------------------------------
Cost at Step 265: -0.9999897602169328
Weights at Step 265: [ 5.94219509e-01  1.15801805e-03  1.32981272e+00  1.77875998e+00
  2.00797690e-03 -8.43338459e-01]
Bias at Step 265: [-1.40879199 -1.35161558  1.04052305 -1.05548315]
---------------------------------------------
Cost at Step 270: -0.9999877865048095
Weights at Step 270: [ 0.5967199  -0.00228699  1.34015592  1.78207987 -0.00207472 -0.8407702 ]
Bias at Step 270: [-1.40654726 -1.35550984  1.03685756 -1.05892969]
---------------------------------------------
Cost at Step 275: -0.9999913148930926
Weights at Step 275: [ 5.95115179e-01  6.67458889e-04  1.33088691e+00  1.77908492e+00
  2.17950090e-03 -8.43784743e-01]
Bias at Step 275: [-1.40907272 -1.35232601  1.03787329 -1.05577319]
---------------------------------------------
Cost at Step 280: -0.9999912773774007
Weights at Step 280: [ 5.94534323e-01  1.49825127e-03  1.33221200e+00  1.78129607e+00
  1.80930063e-03 -8.43864609e-01]
Bias at Step 280: [-1.41032893 -1.35393432  1.03609549 -1.0579392 ]
---------------------------------------------
Cost at Step 285: -0.9999871922879695
Weights at Step 285: [ 5.96437497e-01  3.12450031e-04  1.33601315e+00  1.78353853e+00
 -7.60576311e-04 -8.42698914e-01]
Bias at Step 285: [-1.40896079 -1.3539148   1.03483345 -1.06189856]
---------------------------------------------
Cost at Step 290: -0.9999918144420561
Weights at Step 290: [ 0.5928268   0.00288728  1.32568915  1.77748739  0.00484885 -0.84553166]
Bias at Step 290: [-1.41115856 -1.34928842  1.03616776 -1.0560555 ]
---------------------------------------------
Cost at Step 295: -0.9999908668757269
Weights at Step 295: [ 5.95067478e-01  6.59873701e-06  1.33530656e+00  1.78268285e+00
 -6.83963342e-04 -8.41953097e-01]
Bias at Step 295: [-1.40781716 -1.35320774  1.03673384 -1.06074438]
---------------------------------------------
</pre></div>
</div>
<p>With the learned parameters, we construct a visual representation
of the Hamiltonian to which they correspond and compare it to the
target Hamiltonian, and the initial guessed Hamiltonian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">new_ham_matrix</span></a> <span class="o">=</span> <span class="n">create_hamiltonian_matrix</span><span class="p">(</span>
    <span class="n">qubit_number</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a>
<span class="p">)</span>

<a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_ham</span></a> <span class="o">=</span> <span class="n">create_hamiltonian_matrix</span><span class="p">(</span>
    <span class="n">qubit_number</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">qubit_number</span><span class="p">),</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">initial_weights</span></a><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">initial_bias</span></a>
<span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ham_matrix</span></a><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">7</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;hot&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Target&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.13</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">init_ham</span></a><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">7</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;hot&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Initial&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.13</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">new_ham_matrix</span></a><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">7</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;hot&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Learned&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.13</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_qgrnn_004.png" srcset="../_images/sphx_glr_tutorial_qgrnn_004.png" alt="Target, Initial, Learned" class = "sphx-glr-single-img"/><p>These images look very similar, indicating that the QGRNN has done a good job
learning the target Hamiltonian.</p>
<p>We can also look
at the exact values of the target and learned parameters.
Recall how the target
interaction graph has <span class="math notranslate nohighlight">\(4\)</span> edges while the complete graph has <span class="math notranslate nohighlight">\(6\)</span>.
Thus, as the QGRNN converges to the optimal solution, the weights corresponding to
edges <span class="math notranslate nohighlight">\((1, 3)\)</span> and <span class="math notranslate nohighlight">\((2, 0)\)</span> in the complete graph should go to <span class="math notranslate nohighlight">\(0\)</span>, as
this indicates that they have no effect, and effectively do not exist in the learned
Hamiltonian.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># We first pick out the weights of edges (1, 3) and (2, 0)</span>
<span class="c1"># and then remove them from the list of target parameters</span>

<span class="n">weights_noedge</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">weights_edge</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_ising_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">qubit_number</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">qubit_number</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ising_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
        <span class="n">weights_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weights_noedge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">weights</span></a><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
</pre></div>
</div>
<p>Then, we print all of the weights:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Target parameters     Learned parameters&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weights&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">41</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ii_target</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ii_learned</span></a> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target_weights</span><span class="p">,</span> <span class="n">weights_edge</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ii_target</span><span class="w"> </span><span class="si">:</span><span class="s2"> &lt;20</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ii_learned</span></a><span class="w"> </span><span class="si">:</span><span class="s2"> &gt;20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bias&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">41</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ii_target</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ii_learned</span></a> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target_bias</span><span class="p">,</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">bias</span></a><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ii_target</span><span class="w"> </span><span class="si">:</span><span class="s2"> &lt;20</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.numpy.tensor.html#pennylane.numpy.tensor" title="pennylane.numpy.tensor" class="sphx-glr-backref-module-pennylane-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">ii_learned</span></a><span class="w"> </span><span class="si">:</span><span class="s2"> &gt;20</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Non-Existing Edge Parameters: </span><span class="si">{</span><span class="p">[</span><span class="n">val</span><span class="o">.</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">weights_noedge</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Target parameters     Learned parameters
Weights
-----------------------------------------
0.56                |  0.5988034096092802
1.24                |  1.3483865512005315
1.67                |  1.7862070648455897
-0.79               | -0.8425475506159242

Bias
-----------------------------------------
-1.44               | -1.4067983643944135
-1.43               | -1.3529638627173872
1.18                |  1.0349129419830776
-0.93               | -1.0635874966599637

Non-Existing Edge Parameters: [-0.0012651471928184215, -0.003653447242320976]
</pre></div>
</div>
<p>The weights of edges <span class="math notranslate nohighlight">\((1, 3)\)</span> and <span class="math notranslate nohighlight">\((2, 0)\)</span>
are very close to <span class="math notranslate nohighlight">\(0\)</span>, indicating we have learned the cycle graph
from the complete graph. In addition, the remaining learned weights
are fairly close to those of the target Hamiltonian.
Thus, the QGRNN is functioning properly, and has learned the target
Ising Hamiltonian to a high
degree of accuracy!</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Verdon, G., McCourt, T., Luzhnica, E., Singh, V., Leichenauer, S., &amp;
Hidary, J. (2019). Quantum Graph Neural Networks. arXiv preprint
<a class="reference external" href="https://arxiv.org/abs/1909.12264">arXiv:1909.12264</a>.</p></li>
</ol>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/jack_ceroni.jpg" alt="Jack Ceroni" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Jack Ceroni</h4>
        <p class="bio-text__author-description">Jack is currently a second-year undergraduate student at the University of Toronto, pursuing a degree in pure mathematics. Broadly, his interests are related to simulating quantum systems with quantum computers, mathematical abstraction, and philosophy.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 6 minutes  20.961 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-qgrnn-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/78708476bd74a85fdfa9dafcfc1cc108/tutorial_qgrnn.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_qgrnn.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/9bdc35879d3470627c5a5c963d1e04b3/tutorial_qgrnn.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_qgrnn.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_qgrnn</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">The Quantum Graph Recurrent Neural Network</a><ul class='current'>
<li class='current'><a class="reference internal" href="#the-idea">The Idea</a><ul class='current'>
<li class='current'><a class="reference internal" href="#using-the-qgrnn">Using the QGRNN</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#learning-an-ising-model-with-the-qgrnn">Learning an Ising Model with the QGRNN</a><ul class='current'>
<li class='current'><a class="reference internal" href="#getting-started">Getting Started</a></li>
<li class='current'><a class="reference internal" href="#preparing-quantum-data">Preparing Quantum Data</a></li>
<li class='current'><a class="reference internal" href="#learning-the-hamiltonian">Learning the Hamiltonian</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_qgrnn</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_qml.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="learning2learn.html" title="Learning to learn with quantum neural networks"
             >next</a> |</li>
        <li class="right" >
          <a href="quantum_neural_net.html" title="Function fitting with a photonic quantum neural network"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demos_qml.html" >Quantum machine learning</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">The Quantum Graph Recurrent Neural Network</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>