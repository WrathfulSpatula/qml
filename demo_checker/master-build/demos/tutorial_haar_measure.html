
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Learn all about the Haar measure and how to randomly sample quantum states. " property="og:description" />
<meta content="https://pennylane.ai/qml/_images/spherical_int_dtheta.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Understanding the Haar measure &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_haar_measure.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Learn all about the Haar measure and how to randomly sample quantum states. " property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Understanding the Haar measure &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_haar_measure.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Unitary designs" href="tutorial_unitary_designs.html" />
    <link rel="prev" title="Quantum volume" href="quantum_volume.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_unitary_designs.html" title="Unitary designs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quantum_volume.html" title="Quantum volume"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" accesskey="U">Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Understanding the Haar measure</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-haar-measure-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="understanding-the-haar-measure">
<span id="sphx-glr-demos-tutorial-haar-measure-py"></span><h1>Understanding the Haar measure<a class="headerlink" href="#understanding-the-haar-measure" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_unitary_designs.html", "quantum_volume.html", "qsim_beyond_classical.html", "tutorial_barren_plateaus.html"];
    var related_tutorials_titles = ['Unitary designs', 'Quantum volume', 'Beyond classical computing with qsim', 'Barren plateaus in quantum neural networks'];
</script></p>
<p><em>Author: Olivia Di Matteo — Posted: 22 March 2021. Last updated: 22 March 2021.</em></p>
<p>If you’ve ever dug into the literature about random quantum circuits,
variational ansatz structure, or anything related to the structure and
properties of unitary operations, you’ve likely come across a statement like the
following: “Assume that <span class="math notranslate nohighlight">\(U\)</span> is sampled uniformly at random from the Haar
measure”.  In this demo, we’re going to unravel this cryptic statement and take
an in-depth look at what it means. You’ll gain an understanding of the general
concept of a <em>measure</em>, the Haar measure and its special properties, and you’ll
learn how to sample from it using tools available in PennyLane and other
scientific computing frameworks. By the end of this demo, you’ll be able to
include that important statement in your own work with confidence!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To get the most out of this demo, it is helpful if you are familiar with
<a class="reference external" href="https://en.wikipedia.org/wiki/Multiple_integral">integration of multi-dimensional functions</a>, the <a class="reference external" href="https://en.wikipedia.org/wiki/Bloch_sphere">Bloch sphere</a>, and the conceptual ideas
behind <a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_decomposition">decompositions</a> and factorizations of
unitary matrices (see, e.g., 4.5.1 and 4.5.2 of <a class="footnote-reference brackets" href="#nandc2000" id="id1">1</a>).</p>
</div>
<div class="section" id="measure">
<h2>Measure<a class="headerlink" href="#measure" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Measure_(mathematics)">Measure theory</a> is a
branch of mathematics that studies things that are measurable—think length,
area, or volume, but generalized to mathematical spaces and even higher
dimensions. Loosely, the measure tells you about how “stuff” is distributed and
concentrated in a mathematical set or space. An intuitive way to understand
the measure is to think about a sphere. An arbitrary point on a sphere can be
parametrized by three numbers—depending on what you’re doing, you may use
Cartesian coordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span>, or it may be more convenient to use
spherical coordinates <span class="math notranslate nohighlight">\((\rho, \phi, \theta)\)</span>.</p>
<p>Suppose you wanted to compute the volume of a solid sphere with radius
<span class="math notranslate nohighlight">\(r\)</span>.  This can be done by integrating over the three coordinates
<span class="math notranslate nohighlight">\(\rho, \phi\)</span>, and <span class="math notranslate nohighlight">\(\theta\)</span>. Your first thought here may be to simply
integrate each parameter over its full range, like so:</p>
<div class="math notranslate nohighlight">
\[V = \int_0^{r} \int_0^{2\pi} \int_0^{\pi} d\rho~ d\phi~ d\theta = 2\pi^2 r\]</div>
<p>But, we know that the volume of a sphere of radius <span class="math notranslate nohighlight">\(r\)</span> is
<span class="math notranslate nohighlight">\(\frac{4}{3}\pi r^3\)</span>, so what we got from this integral is clearly wrong!
Taking the integral naively like this doesn’t take into account the structure of
the sphere with respect to the parameters. For example, consider
two small, infinitesimal elements of area with the same difference in
<span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span>, but at different values of <span class="math notranslate nohighlight">\(\theta\)</span>:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/spherical_int_dtheta.png"><img alt="../_images/spherical_int_dtheta.png" src="../_images/spherical_int_dtheta.png" style="width: 50%;" /></a>
</div>
<p>Even though the differences <span class="math notranslate nohighlight">\(d\theta\)</span> and <span class="math notranslate nohighlight">\(d\phi\)</span> themselves are the
same, there is way more “stuff” near the equator of the sphere than there is
near the poles. We must take into account the value of <span class="math notranslate nohighlight">\(\theta\)</span> when
computing the integral! Specifically, we multiply by the function
<span class="math notranslate nohighlight">\(\sin\theta\)</span>—the properties of the <span class="math notranslate nohighlight">\(\sin\)</span> function mean that the
most weight will occur around the equator where <span class="math notranslate nohighlight">\(\theta=\pi/2\)</span>, and the
least weight near the poles where <span class="math notranslate nohighlight">\(\theta=0\)</span> and <span class="math notranslate nohighlight">\(\theta=\pi\)</span>.</p>
<p>Similar care must be taken for <span class="math notranslate nohighlight">\(\rho\)</span>.  The contribution to volume of
parts of the sphere with a large <span class="math notranslate nohighlight">\(\rho\)</span> is far more than for a small
<span class="math notranslate nohighlight">\(\rho\)</span>—we should expect the contribution to be proportional to
<span class="math notranslate nohighlight">\(\rho^2\)</span>, given that the surface area of a sphere of radius <span class="math notranslate nohighlight">\(r\)</span> is
<span class="math notranslate nohighlight">\(4\pi r^2\)</span>.</p>
<p>On the other hand, for a fixed <span class="math notranslate nohighlight">\(\rho\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span>, the length of
the <span class="math notranslate nohighlight">\(d\phi\)</span> is the same all around the circle. If put all these facts
together, we find that the actual expression for the integral should look like
this:</p>
<div class="math notranslate nohighlight">
\[V = \int_0^r \int_0^{2\pi} \int_0^{\pi} \rho^2 \sin \theta~ d\rho~ d\phi~
d\theta = \frac{4}{3}\pi r^3\]</div>
<p>These extra terms that we had to add to the integral, <span class="math notranslate nohighlight">\(\rho^2 \sin
\theta\)</span>, constitute the <em>measure</em>. The measure weights portions of the sphere
differently depending on where they are in the space. While we need to know the
measure to properly integrate over the sphere, knowledge of the measure also
gives us the means to perform another important task, that of sampling points in
the space uniformly at random. We can’t simply sample each parameter from the
uniform distribution over its domain—as we experienced already, this doesn’t
take into account how the sphere is spread out over space. The measure describes
the distribution of each parameter and gives a recipe for sampling them in order
to obtain something properly uniform.</p>
</div>
<div class="section" id="the-haar-measure">
<h2>The Haar measure<a class="headerlink" href="#the-haar-measure" title="Permalink to this headline">¶</a></h2>
<p>Operations in quantum computing are described by unitary matrices.
Unitary matrices, like points on a sphere, can be expressed in terms of a fixed
set of coordinates, or parameters. For example, the most general single-qubit rotation
implemented in PennyLane (<a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rot</span></code></a>) is expressed in terms of three
parameters like so,</p>
<div class="math notranslate nohighlight">
\[\begin{split}U(\phi, \theta, \omega) = \begin{pmatrix} e^{-i(\phi + \omega)/2}
                    \cos(\theta/2) &amp; -e^{i(\phi - \omega)/2} \sin(\theta/2)
                    \\ e^{-i(\phi - \omega)/2} \sin(\theta/2) &amp; e^{i(\phi +
                    \omega)/2} \cos(\theta/2) \end{pmatrix}.\end{split}\]</div>
<p>For every dimension <span class="math notranslate nohighlight">\(N\)</span>, the unitary matrices of size <span class="math notranslate nohighlight">\(N \times N\)</span>
constitute the <em>unitary group</em> <span class="math notranslate nohighlight">\(U(N)\)</span>. We can perform operations on
elements of this group, such as apply functions to them, integrate over them, or
sample uniformly over them, just as we can do to points on a sphere. When we do
such tasks with respect to the sphere, we have to add the measure in order to
properly weight the different regions of space. The <em>Haar measure</em> provides the
analogous terms we need for working with the unitary group.</p>
<p>For an <span class="math notranslate nohighlight">\(N\)</span>-dimensional system, the Haar measure, often denoted by
<span class="math notranslate nohighlight">\(\mu_N\)</span>, tells us how to weight the elements of <span class="math notranslate nohighlight">\(U(N)\)</span>. For
example, suppose <span class="math notranslate nohighlight">\(f\)</span> is a function that acts on elements of <span class="math notranslate nohighlight">\(U(N)\)</span>,
and we would like to take its integral over the group. We must write this
integral with respect to the Haar measure, like so:</p>
<div class="math notranslate nohighlight">
\[\int_{V \in U(N)} f(V) d\mu_N(V).\]</div>
<p>As with the measure term of the sphere, <span class="math notranslate nohighlight">\(d\mu_N\)</span> itself can be broken down
into components depending on individual parameters.  While the Haar
measure can be defined for every dimension <span class="math notranslate nohighlight">\(N\)</span>, the mathematical form gets
quite hairy for larger dimensions—in general, an <span class="math notranslate nohighlight">\(N\)</span>-dimensional unitary
requires at least <span class="math notranslate nohighlight">\(N^2 - 1\)</span> parameters, which is a lot to keep track of!
Therefore we’ll start with the case of a single qubit <span class="math notranslate nohighlight">\((N=2)\)</span>, then show
how things generalize.</p>
<div class="section" id="single-qubit-haar-measure">
<h3>Single-qubit Haar measure<a class="headerlink" href="#single-qubit-haar-measure" title="Permalink to this headline">¶</a></h3>
<p>The single-qubit case provides a particularly nice entry point because we can
continue our comparison to spheres by visualizing single-qubit states on the
Bloch sphere. As expressed above, the measure provides a recipe for sampling
elements of the unitary group in a properly uniform manner, given the structure
of the group. One useful consequence of this is that it provides a method to
sample quantum <em>states</em> uniformly at random—we simply generate Haar-random
unitaries, and apply them to a fixed basis state such as <span class="math notranslate nohighlight">\(\vert 0\rangle\)</span>.</p>
<p>We’ll see how this works in good time. First, we’ll take a look at what happens
when we ignore the measure and do things <em>wrong</em>. Suppose we sample quantum
states by applying unitaries obtained by the parametrization above, but sample
the angles <span class="math notranslate nohighlight">\(\omega, \phi\)</span>, and <span class="math notranslate nohighlight">\(\theta\)</span> from the flat uniform
distribution between <span class="math notranslate nohighlight">\([0, 2\pi)\)</span> (fun fact: there is a measure implicit in
this kind of sampling too! It just has a constant value, because each point is
equally likely to be sampled).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># set the random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Use the mixed state simulator to save some steps in plotting later</span>
<span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s1">&#39;default.mixed&#39;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_a_haar_random_unitary</span><span class="p">():</span>
    <span class="c1"># Sample all parameters from their flat uniform distribution</span>
    <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="pennylane.Rot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Rot</span></a><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>

<span class="n">num_samples</span> <span class="o">=</span> <span class="mi">2021</span>

<span class="n">not_haar_samples</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">not_a_haar_random_unitary</span></a><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>
</pre></div>
</div>
<p>In order to plot these on the Bloch sphere, we’ll need to do one more
step, and convert the quantum states into Bloch vectors.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

<span class="c1"># Used the mixed state simulator so we could have the density matrix for this part!</span>
<span class="k">def</span> <span class="nf">convert_to_bloch_vector</span><span class="p">(</span><span class="n">rho</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a density matrix to a Bloch vector.&quot;&quot;&quot;</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
    <span class="n">ay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">Y</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
    <span class="n">az</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">,</span> <span class="n">az</span><span class="p">]</span>

<span class="n">not_haar_bloch_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">convert_to_bloch_vector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">not_haar_samples</span><span class="p">])</span>
</pre></div>
</div>
<p>With this done, let’s find out where our “uniformly random” states ended up:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_bloch_sphere</span><span class="p">(</span><span class="n">bloch_vectors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Helper function to plot vectors on a sphere.&quot;&quot;&quot;</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mi">7</span>

    <span class="c1"># Draw the axes (source: https://github.com/matplotlib/matplotlib/issues/13575)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5</span><span class="p">]])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">arrow_length_ratio</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;|0⟩&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;|1⟩&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">1.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;|+⟩&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;|–⟩&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;|i+⟩&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;|i–⟩&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
        <span class="n">bloch_vectors</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">bloch_vectors</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">bloch_vectors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;#e29d9e&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span>
    <span class="p">)</span>

<span class="n">plot_bloch_sphere</span><span class="p">(</span><span class="n">not_haar_bloch_vectors</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_haar_measure_001.png" srcset="../_images/sphx_glr_tutorial_haar_measure_001.png" alt="tutorial haar measure" class = "sphx-glr-single-img"/><p>You can see from this plot that even though our parameters were sampled from a
uniform distribution, there is a noticeable amount of clustering around the poles
of the sphere. Despite the input parameters being uniform, the output is very
much <em>not</em> uniform. Just like the regular sphere, the measure is larger near
the equator, and if we just sample uniformly, we won’t end up populating that
area as much. To take that into account we will need to sample from the proper
Haar measure, and weight the different parameters appropriately.</p>
<p>For a single qubit, the Haar measure looks much like the case of a sphere,
minus the radial component. Intuitively, all qubit state vectors have length
1, so it makes sense that this wouldn’t play a role here. The parameter that
we will have to weight differently is <span class="math notranslate nohighlight">\(\theta\)</span>, and in fact the
adjustment in measure is identical to that we had to do with the polar axis of
the sphere, i.e., <span class="math notranslate nohighlight">\(\sin \theta\)</span>. In order to sample the <span class="math notranslate nohighlight">\(\theta\)</span>
uniformly at random in this context, we must sample from the distribution
<span class="math notranslate nohighlight">\(\hbox{Pr}(\theta) = \sin \theta\)</span>. We can accomplish this by setting up
a custom probability distribution with
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.html#scipy.stats.rv_continuous">rv_continuous</a>
in <code class="docutils literal notranslate"><span class="pre">scipy</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rv_continuous</span>

<span class="k">class</span> <span class="nc">sin_prob_dist</span><span class="p">(</span><span class="n">rv_continuous</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># The 0.5 is so that the distribution is normalized</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

<span class="c1"># Samples of theta should be drawn from between 0 and pi</span>
<span class="n">sin_sampler</span> <span class="o">=</span> <span class="n">sin_prob_dist</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">haar_random_unitary</span><span class="p">():</span>
    <span class="n">phi</span><span class="p">,</span> <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Sample phi and omega as normal</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">sin_sampler</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Sample theta from our new distribution</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Rot.html#pennylane.Rot" title="pennylane.Rot" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Rot</span></a><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>

<span class="n">haar_samples</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">haar_random_unitary</span></a><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>
<span class="n">haar_bloch_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">convert_to_bloch_vector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">haar_samples</span><span class="p">])</span>

<span class="n">plot_bloch_sphere</span><span class="p">(</span><span class="n">haar_bloch_vectors</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_haar_measure_002.png" srcset="../_images/sphx_glr_tutorial_haar_measure_002.png" alt="tutorial haar measure" class = "sphx-glr-single-img"/><p>We see that when we use the correct measure, our qubit states are now
much better distributed over the sphere. Putting this information together,
we can now write the explicit form for the single-qubit Haar measure:</p>
<div class="math notranslate nohighlight">
\[d\mu_2 = \sin \theta d\theta \cdot d\omega \cdot d\phi.\]</div>
</div>
<div class="section" id="show-me-more-math">
<h3>Show me more math!<a class="headerlink" href="#show-me-more-math" title="Permalink to this headline">¶</a></h3>
<p>While we can easily visualize the single-qubit case, this is no longer
possible when we increase the number of qubits. Regardless, we can still
obtain a mathematical expression for the Haar measure in arbitrary
dimensions. In the previous section, we expressed the Haar measure in terms of
a set of parameters that can be used to specify the unitary group
<span class="math notranslate nohighlight">\(U(2)\)</span>. Such a parametrization is not unique, and in fact there are
multiple ways to <em>factorize</em>, or decompose an <span class="math notranslate nohighlight">\(N\)</span>-dimensional unitary
operation into a set of parameters.</p>
<p>Many of these parametrizations come to us from the study of photonics.  Here,
arbitrary operations are broken down into elementary operations involving only
a few parameters which correspond directly to parameters of the physical
apparatus used to implement them (beamsplitters and phase shifts). Rather than
qubits, such operations act on modes, or <em>qumodes</em>. They are expressed as
elements of the <span class="math notranslate nohighlight">\(N\)</span>-dimensional <a class="reference external" href="https://en.wikipedia.org/wiki/Special_unitary_group">special unitary group</a>. This group, written
as <span class="math notranslate nohighlight">\(SU(N)\)</span>, is the continuous group consisting of all <span class="math notranslate nohighlight">\(N \times N\)</span>
unitary operations with determinant 1 (essentially like <span class="math notranslate nohighlight">\(U(N)\)</span>, minus
a potential global phase).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Elements of <span class="math notranslate nohighlight">\(SU(N)\)</span> and <span class="math notranslate nohighlight">\(U(N)\)</span> can still be considered as
multi-qubit operations in the cases where <span class="math notranslate nohighlight">\(N\)</span> is a power of 2, but
they must be translated from continuous-variable operations into qubit
operations. (In PennyLane, this can be done by feeding the unitaries to
the <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubitUnitary</span></code></a> operation directly. Alternatively,
one can use <em>quantum compilation</em> to express the operations as a sequence
of elementary gates such as Pauli rotations and CNOTs.)</p>
</div>
<div class="admonition-tip admonition">
<p class="admonition-title">Tip</p>
<p>If you haven’t had many opportunities to work in terms of qumodes, the
<a class="reference external" href="https://strawberryfields.ai/photonics/concepts/photonics.html">Strawberry Fields documentation</a> is a
good starting point.</p>
</div>
<p>For example, we saw already above that for <span class="math notranslate nohighlight">\(N=2\)</span>, we can write</p>
<div class="math notranslate nohighlight">
\[\begin{split}U(\phi, \theta, \omega) = \begin{pmatrix} e^{-i(\phi + \omega)/2}
                    \cos(\theta/2) &amp; -e^{i(\phi - \omega)/2} \sin(\theta/2)
                    \\ e^{-i(\phi - \omega)/2} \sin(\theta/2) &amp; e^{i(\phi +
                    \omega)/2} \cos(\theta/2) \end{pmatrix}.\end{split}\]</div>
<p>This unitary can be factorized as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}U(\phi, \theta, \omega) =
    \begin{pmatrix}
      e^{-i\omega/2} &amp; 0 \\ 0 &amp; e^{i\omega/2}
    \end{pmatrix}
    \begin{pmatrix}
      \cos(\theta/2) &amp; -\sin(\theta/2) \\ \sin(\theta/2) &amp; \cos(\theta/2)
    \end{pmatrix}
   \begin{pmatrix}
      e^{-i\phi/2} &amp; 0 \\ 0 &amp; e^{i\phi/2}
    \end{pmatrix}\end{split}\]</div>
<p>The middle operation is a beamsplitter; the other two operations are phase
shifts.  We saw earlier that for <span class="math notranslate nohighlight">\(N=2\)</span>, <span class="math notranslate nohighlight">\(d\mu_2 = \sin\theta
d\theta d\omega d\phi\)</span>—note how the parameter in the beamsplitter
contributes to the measure in a different way than those of the phase
shifts. As mentioned above, for larger values of <span class="math notranslate nohighlight">\(N\)</span> there are multiple
ways to decompose the unitary. Such decompositions rewrite elements in
<span class="math notranslate nohighlight">\(SU(N)\)</span> acting on <span class="math notranslate nohighlight">\(N\)</span> modes as a sequence of operations acting
only on 2 modes, <span class="math notranslate nohighlight">\(SU(2)\)</span>, and single-mode phase shifts.  Shown below are
three examples <a class="footnote-reference brackets" href="#deguise2018" id="id2">2</a>, <a class="footnote-reference brackets" href="#clements2016" id="id3">3</a>, <a class="footnote-reference brackets" href="#reck1994" id="id4">4</a>:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/unitaries.png"><img alt="../_images/unitaries.png" src="../_images/unitaries.png" style="width: 95%;" /></a>
</div>
<p>In these graphics, every wire is a different mode. Every box represents an
operation on one or more modes, and the number in the box indicates the number
of parameters.  The boxes containing a <code class="docutils literal notranslate"><span class="pre">1</span></code> are simply phase shifts on
individual modes. The blocks containing a <code class="docutils literal notranslate"><span class="pre">3</span></code> are <span class="math notranslate nohighlight">\(SU(2)\)</span> transforms
with 3 parameters, such as the <span class="math notranslate nohighlight">\(U(\phi, \theta, \omega)\)</span> above. Those
containing a <code class="docutils literal notranslate"><span class="pre">2</span></code> are <span class="math notranslate nohighlight">\(SU(2)\)</span> transforms on pairs of modes with 2
parameters, similar to the 3-parameter ones but with <span class="math notranslate nohighlight">\(\omega = \phi\)</span>.</p>
<p>Although the decompositions all produce the same set of operations, their
structure and parametrization may have consequences in practice.  The first <a class="footnote-reference brackets" href="#deguise2018" id="id5">2</a>
has a particularly convenient form that leads to a recursive definition
of the Haar measure. The decomposition is formulated recursively such that an
<span class="math notranslate nohighlight">\(SU(N)\)</span> operation can be implemented by sandwiching an <span class="math notranslate nohighlight">\(SU(2)\)</span>
transformation between two <span class="math notranslate nohighlight">\(SU(N-1)\)</span> transformations, like so:</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/sun.svg"><img alt="../_images/sun.svg" src="../_images/sun.svg" width="80%" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The Haar measure is then constructed recursively as a product of 3
terms. The first term depends on the parameters in the first <span class="math notranslate nohighlight">\(SU(N-1)\)</span>
transformation; the second depends on the parameters in the lone <span class="math notranslate nohighlight">\(SU(2)\)</span>
transformation; and the third term depends on the parameters in the other
<span class="math notranslate nohighlight">\(SU(N-1)\)</span> transformation.</p>
<p><span class="math notranslate nohighlight">\(SU(2)\)</span> is the “base case” of the recursion—we simply have the Haar measure
as expressed above.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/su2_haar.svg"><img alt="../_images/su2_haar.svg" src="../_images/su2_haar.svg" width="25%" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Moving on up, we can write elements of <span class="math notranslate nohighlight">\(SU(3)\)</span> as a sequence of three
<span class="math notranslate nohighlight">\(SU(2)\)</span> transformations. The Haar measure <span class="math notranslate nohighlight">\(d\mu_3\)</span> then consists
of two copies of <span class="math notranslate nohighlight">\(d\mu_2\)</span>, with an extra term in between to take into
account the middle transformation.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/su3_haar.svg"><img alt="../_images/su3_haar.svg" src="../_images/su3_haar.svg" width="80%" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For <span class="math notranslate nohighlight">\(SU(4)\)</span> and upwards, the form changes slightly, but still follows
the pattern of two copies of <span class="math notranslate nohighlight">\(d\mu_{N-1}\)</span> with a term in between.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/su4_premerge.svg"><img alt="../_images/su4_premerge.svg" src="../_images/su4_premerge.svg" width="90%" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>For larger systems, however, the recursive composition allows for some of the
<span class="math notranslate nohighlight">\(SU(2)\)</span> transformations on the lower modes to be grouped. We can take
advantage of this and aggregate some of the parameters:</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/su4_triangle_merge.svg"><img alt="../_images/su4_triangle_merge.svg" src="../_images/su4_triangle_merge.svg" width="100%" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>This leads to one copy of <span class="math notranslate nohighlight">\(d\mu_{N-1}\)</span>, which we’ll denote as
<span class="math notranslate nohighlight">\(d\mu_{N-1}^\prime\)</span>, containing only a portion of the full set of terms
(as detailed in <a class="footnote-reference brackets" href="#deguise2018" id="id6">2</a>, this is called a <em>coset measure</em>).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/su4_haar.svg"><img alt="../_images/su4_haar.svg" src="../_images/su4_haar.svg" width="100%" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Putting everything together, we have that</p>
<div class="math notranslate nohighlight">
\[d\mu_N = d\mu_{N-1}^\prime \times \sin \theta_{N-1}
\sin^{2(N-2)}\left(\frac{\theta_{N-1}}{2}\right) d\theta_{N-1} d\omega_{N-1} \times d\mu_{N-1}\]</div>
<p>The middle portion depends on the value of <span class="math notranslate nohighlight">\(N\)</span>, and the parameters
<span class="math notranslate nohighlight">\(\theta_{N-1}\)</span> and <span class="math notranslate nohighlight">\(\omega_{N-1}\)</span> contained in the <span class="math notranslate nohighlight">\((N-1)\)</span>’th
<span class="math notranslate nohighlight">\(SU(N)\)</span> transformation. This is thus a convenient, systematic way to
construct the <span class="math notranslate nohighlight">\(N\)</span>-dimensional Haar measure for the unitary group. As a
final note, even though unitaries can be parametrized in different ways, the
underlying Haar measure is <em>unique</em>. This is a consequence of it being an
invariant measure, as will be shown later.</p>
</div>
<div class="section" id="haar-random-matrices-from-the-qr-decomposition">
<h3>Haar-random matrices from the <span class="math notranslate nohighlight">\(QR\)</span> decomposition<a class="headerlink" href="#haar-random-matrices-from-the-qr-decomposition" title="Permalink to this headline">¶</a></h3>
<p>Nice-looking math aside, sometimes you just need to generate a large number of
high-dimensional Haar-random matrices. It would be very cumbersome to sample
and keep track of the distributions of so many parameters; furthermore, the
measure above requires you to parametrize your operations in a fixed way.
There is a much quicker way to perform the sampling by taking a (slightly
modified) <a class="reference external" href="https://en.wikipedia.org/wiki/QR_decomposition">QR decomposition</a> of complex-valued
matrices.  This algorithm is detailed in <a class="footnote-reference brackets" href="#mezzadri2006" id="id7">5</a>, and consists of the
following steps:</p>
<ol class="arabic simple">
<li><p>Generate an <span class="math notranslate nohighlight">\(N \times N\)</span> matrix <span class="math notranslate nohighlight">\(Z\)</span> with complex numbers <span class="math notranslate nohighlight">\(a+bi\)</span>
where both <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are normally distributed with mean 0 and variance 1
(this is sampling from the distribution known as the <em>Ginibre ensemble</em>).</p></li>
<li><p>Compute a QR decomposition <span class="math notranslate nohighlight">\(Z = QR\)</span>.</p></li>
<li><p>Compute the diagonal matrix <span class="math notranslate nohighlight">\(\Lambda = \hbox{diag}(R_{ii}/|R_{ii}|)\)</span>.</p></li>
<li><p>Compute <span class="math notranslate nohighlight">\(Q^\prime = Q \Lambda\)</span>, which will be Haar-random.</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">qr</span>

<span class="k">def</span> <span class="nf">qr_haar</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a Haar-random matrix using the QR decomposition.&quot;&quot;&quot;</span>
    <span class="c1"># Step 1</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">B</span>

    <span class="c1"># Step 2</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">qr</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

    <span class="c1"># Step 3</span>
    <span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

    <span class="c1"># Step 4</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s check that this method actually generates Haar-random unitaries
by trying it out for <span class="math notranslate nohighlight">\(N=2\)</span> and plotting on the Bloch sphere.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qr_haar_random_unitary</span><span class="p">():</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitUnitary.html#pennylane.QubitUnitary" title="pennylane.QubitUnitary" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitUnitary</span></a><span class="p">(</span><span class="n">qr_haar</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.state.html#pennylane.state" title="pennylane.state" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">state</span></a><span class="p">()</span>

<span class="n">qr_haar_samples</span> <span class="o">=</span> <span class="p">[</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">qr_haar_random_unitary</span></a><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>
<span class="n">qr_haar_bloch_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">convert_to_bloch_vector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">qr_haar_samples</span><span class="p">])</span>
<span class="n">plot_bloch_sphere</span><span class="p">(</span><span class="n">qr_haar_bloch_vectors</span><span class="p">)</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_haar_measure_003.png" srcset="../_images/sphx_glr_tutorial_haar_measure_003.png" alt="tutorial haar measure" class = "sphx-glr-single-img"/><p>As expected, we find our qubit states are distributed uniformly over the
sphere.  This particular method is what’s implemented in packages like
<code class="docutils literal notranslate"><span class="pre">scipy</span></code>’s <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.unitary_group.html">unitary_group</a>
function.</p>
<p>Now, it’s clear that this method works, but it is also important to
understand <em>why</em> it works.  Step 1 is fairly straightforward—the base of our
samples is a matrix full of complex values chosen from a typical
distribution. This isn’t enough by itself, since unitary matrices also
have constraints—their rows and columns must be orthonormal.
These constraints are where step 2 comes in—the outcome of a generic
QR decomposition consists of an <em>orthonormal</em> matrix <span class="math notranslate nohighlight">\(Q\)</span>, and and upper
triangular matrix <span class="math notranslate nohighlight">\(R\)</span>. Since our original matrix was complex-valued, we end
up with a <span class="math notranslate nohighlight">\(Q\)</span> that is in fact already unitary. But why not stop there? Why
do we then perform steps 3 and 4?</p>
<p>Steps 3 and 4 are needed because, while the QR decomposition yields a unitary,
it is not a unitary that is properly Haar-random. In <a class="footnote-reference brackets" href="#mezzadri2006" id="id8">5</a>, it is
explained that a uniform distribution over unitary matrices should also yield
a uniform distribution over the <em>eigenvalues</em> of those matrices, i.e., every
eigenvalue should be equally likely. Just using the QR decomposition out of
the box produces an <em>uneven</em> distribution of eigenvalues of the unitaries!
This discrepancy stems from the fact that the QR decomposition is not unique.
We can take any unitary diagonal matrix <span class="math notranslate nohighlight">\(\Lambda\)</span>, and re-express the decomposition
as <span class="math notranslate nohighlight">\(QR = Q\Lambda \Lambda^\dagger R = Q^\prime R^\prime\)</span>. Step 3 removes this
redundancy by fixing a <span class="math notranslate nohighlight">\(\Lambda\)</span> that depends on <span class="math notranslate nohighlight">\(R\)</span>, leading to a unique
value of <span class="math notranslate nohighlight">\(Q^\prime = Q \Lambda\)</span>, and a uniform distribution of eigenvalues.</p>
<div class="admonition-try-it admonition">
<p class="admonition-title">Try it!</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">qr_haar</span></code> function above to generate random unitaries and construct
a distribution of their eigenvalues. Then, comment out the lines for steps 3 and
4 and do the same—you’ll find that the distribution is no longer uniform.
Check out reference <a class="footnote-reference brackets" href="#mezzadri2006" id="id9">5</a> for additional details and examples.</p>
</div>
</div>
</div>
<div class="section" id="fun-and-not-so-fun-facts">
<h2>Fun (and not-so-fun) facts<a class="headerlink" href="#fun-and-not-so-fun-facts" title="Permalink to this headline">¶</a></h2>
<p>We’ve now learned what the Haar measure is, and both an analytical and
numerical means of sampling quantum states and unitary operations uniformly at
random. The Haar measure also has many neat properties that play a role in
quantum computing.</p>
<div class="section" id="invariance-of-the-haar-measure">
<h3>Invariance of the Haar measure<a class="headerlink" href="#invariance-of-the-haar-measure" title="Permalink to this headline">¶</a></h3>
<p>Earlier, we showed that the Haar measure is used when integrating functions over
the unitary group:</p>
<div class="math notranslate nohighlight">
\[\int_{V \in U(N)} f(V) d\mu_N(V).\]</div>
<p>One of the defining features of the Haar measure is that it is both left and
right <em>invariant</em> under unitary transformations. That is,</p>
<div class="math notranslate nohighlight">
\[\int_{V \in U(N)} f(\color{red}{W}V) d\mu_N(V) =  \int_{V \in U(N)} f(V\color{red}{W}) d\mu_N(V) =  \int_{V \in U(N)} f(V) d\mu_N(V).\]</div>
<p>This holds true for <em>any</em> other <span class="math notranslate nohighlight">\(N\times N\)</span> unitary <span class="math notranslate nohighlight">\(W\)</span>! A
consequence of such invariance is that if <span class="math notranslate nohighlight">\(V\)</span> is Haar-random, then so is
<span class="math notranslate nohighlight">\(V^T,\)</span> <span class="math notranslate nohighlight">\(V^\dagger,\)</span> and any product of another unitary matrix and
<span class="math notranslate nohighlight">\(V\)</span> (where the product may be taken on either side).</p>
<p>Another consequence of this invariance has to do with the structure of the entries
themselves: they must all come from the same distribution. This is because the
measure remains invariant under permutations, since permutations are unitary—
the whole thing still has to be Haar random no matter how the entries are ordered,
so all distributions must be the same.  The specific distribution is complex
numbers <span class="math notranslate nohighlight">\(a+bi\)</span> where both <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> has mean 0 and variance
<span class="math notranslate nohighlight">\(1/N\)</span> <a class="footnote-reference brackets" href="#meckes2014" id="id10">6</a> (so, much like Ginibre ensemble we used in the QR decomposition
above, but with a different variance and constraints due to orthonormality).</p>
</div>
<div class="section" id="concentration-of-measure">
<h3>Concentration of measure<a class="headerlink" href="#concentration-of-measure" title="Permalink to this headline">¶</a></h3>
<p>An unfortunate (although interesting) property of the Haar measure is that it
suffers from the phenomenon of <a class="reference external" href="https://en.wikipedia.org/wiki/Concentration_of_measure">concentration of measure</a>. Most of the
“stuff” in the space concentrates around a certain area, and this gets worse
as the size of the system increases. You can see the beginnings of by looking
at the sphere. For the 3-dimensional sphere, we saw graphically how there is
concentration around the equator, and how the measure takes that into account
with the additional factor of <span class="math notranslate nohighlight">\(\sin \theta\)</span>. This property becomes
increasingly prominent for <a class="reference external" href="https://en.wikipedia.org/wiki/N-sphere">higher-dimensional spheres</a>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The concentration described here is not referring to what we witnessed
earlier on, when we sampled quantum states (points on the Bloch sphere)
incorrectly and found that they clustered around the poles. However, that
is not unrelated. Concentration of measure refers to where the measure
itself is concentrated, and which parts of the space should be more heavily
weighted. For the case of the sphere, it is the equatorial area, and when
we didn’t sample properly and take that concentration into account, we
obtained an uneven distribution.</p>
</div>
<p>Let’s consider an <span class="math notranslate nohighlight">\(N\)</span>-dimensional unit sphere. Points on the sphere, or
vectors in this space, are parametrized by <span class="math notranslate nohighlight">\(N-1\)</span> real coordinates.
Suppose we have some function <span class="math notranslate nohighlight">\(f\)</span> that maps points on that sphere to
real numbers. Sample a point <span class="math notranslate nohighlight">\(x\)</span> on that sphere from the uniform
measure, and compute the value of <span class="math notranslate nohighlight">\(f(x)\)</span>. How close do you think the
result will be to the mean value of the function, <span class="math notranslate nohighlight">\(E[f]\)</span>, over the
entire sphere?</p>
<p>A result called <a class="reference external" href="https://en.wikipedia.org/wiki/Concentration_of_measure#Concentration_on_the_sphere">Levy’s lemma</a>
<a class="footnote-reference brackets" href="#gerken2013" id="id11">7</a>, <a class="footnote-reference brackets" href="#hayden2006" id="id12">8</a> expresses how likely it is that <span class="math notranslate nohighlight">\(f(x)\)</span> is a specific
distance away from the mean. It states that, for an <span class="math notranslate nohighlight">\(x\)</span> selected
uniformly at random, the probability that <span class="math notranslate nohighlight">\(f(x)\)</span> deviates from
<span class="math notranslate nohighlight">\(E[f]\)</span> by some amount <span class="math notranslate nohighlight">\(\epsilon\)</span> is bounded by:</p>
<div class="math notranslate nohighlight">
\[\hbox{Pr}(|f(x) - E[f]| \ge \epsilon) \leq 2 \exp\left[-\frac{N\epsilon^2}{9\pi^3 \eta^2}\right].\]</div>
<p>A constraint on the function <span class="math notranslate nohighlight">\(f\)</span> is that it must be <a class="reference external" href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz
continuous</a>, where
<span class="math notranslate nohighlight">\(\eta\)</span> is the <em>Lipschitz constant</em> of the function. The important aspect
here is the likelihood of deviating significantly from the mean by an amount
<span class="math notranslate nohighlight">\(\epsilon\)</span> decreases exponentially with <span class="math notranslate nohighlight">\(\epsilon.\)</span> Furthermore,
increasing the dimension <span class="math notranslate nohighlight">\(N\)</span> also makes the deviation exponentially less
likely.</p>
<p>Now, this result seems unrelated to quantum states—it concerns higher-
dimensional spheres. However, recall that a quantum state vector is a complex
vector whose squared values sum to 1, similar to vectors on a sphere. If you
“unroll” a quantum state vector of dimension <span class="math notranslate nohighlight">\(N = 2^n\)</span> by stacking its
real and complex parts, you end with a vector of length <span class="math notranslate nohighlight">\(2 \cdot 2^{n}\)</span>
which ends up behaving just like a unit vector on the sphere in this
dimension. Given that measure concentrates on spheres, and quantum state
vectors can be converted to vectors on spheres, functions on random quantum
states will also demonstrate concentration.</p>
<p>This is bad news! To do useful things in quantum computing, we need a lot of
qubits. But the more qubits we have, the more our randomly sampled states will
look the same (specifically, random states will concentrate around the
maximally entangled state <a class="footnote-reference brackets" href="#hayden2006" id="id13">8</a>). This has important consequences for
near-term algorithms (as detailed in the next section), and any algorithm that
involves uniform sampling of quantum states and operations.</p>
</div>
<div class="section" id="haar-measure-and-barren-plateaus">
<h3>Haar measure and barren plateaus<a class="headerlink" href="#haar-measure-and-barren-plateaus" title="Permalink to this headline">¶</a></h3>
<p>Suppose you are venturing out to solve a new problem using an algorithm such
as the <a class="reference internal" href="tutorial_vqe.html"><span class="doc">variational quantum eigensolver</span></a>. A
critical component of such methods is the choice of <a class="reference internal" href="../glossary/circuit_ansatz.html"><span class="doc">variational ansatz</span></a>. Having now learned a bit about the properties of
the Haar measure, you may think it would make sense to use this for the
parametrization. Variational ansaetze are, after all, parametrized quantum
circuits, so why not choose an ansatz that corresponds directly to a
parametrization for Haar-random unitaries?  The initial parameter selection
will give you a state in the Hilbert space uniformly at random. Then, since
this ansatz spans the entire Hilbert space, you’re guaranteed to be able to
represent the target ground state with your ansatz, and it should be able to
find it with no issue … right?</p>
<p>Unfortunately, while such an ansatz is extremely <em>expressive</em> (i.e., it is
capable of representing any possible state), these ansaetze actually suffer
the most from the barren plateau problem <a class="footnote-reference brackets" href="#mcclean2018" id="id14">9</a>, <a class="footnote-reference brackets" href="#holmes2021" id="id15">10</a>.
<a class="reference internal" href="tutorial_barren_plateaus.html"><span class="doc">Barren plateaus</span></a> are regions in the
cost landscape of a parametrized circuit where both the gradient and its
variance approach 0, leading the optimizer to get stuck in a local minimum.
This was explored recently in the work of <a class="footnote-reference brackets" href="#holmes2021" id="id16">10</a>, wherein closeness to
the Haar measure was actually used as a metric for expressivity. The closer
things are to the Haar measure, the more expressive they are, but they are
also more prone to exhibiting barren plateaus.</p>
<div class="figure align-center" id="id19">
<a class="reference internal image-reference" href="../_images/holmes-costlandscapes.png"><img alt="../_images/holmes-costlandscapes.png" src="../_images/holmes-costlandscapes.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-text">Image source: <a class="footnote-reference brackets" href="#holmes2021" id="id17">10</a>. A highly expressive ansatz that can access
much of the space of possible unitaries (i.e., an ansatz capable of
producing unitaries in something close to a Haar-random manner) is very
likely to have flat cost landscapes and suffer from the barren plateau
problem.</span><a class="headerlink" href="#id19" title="Permalink to this image">¶</a></p>
</div>
<p>It turns out that the types of ansaetze know as <em>hardware-efficient ansaetze</em>
also suffer from this problem if they are “random enough” (this notion will be
formalized in a future demo). It was shown in <a class="footnote-reference brackets" href="#mcclean2018" id="id18">9</a> that this is a
consequence of the concentration of measure phenomenon described above. The
values of gradients and variances can be computed for classes of circuits on
average by integrating with respect to the Haar measure, and it is shown that
these values decrease exponentially in the number of qubits, and thus huge
swaths of the cost landscape are simply and fundamentally flat.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>The Haar measure plays an important role in quantum computing—anywhere
you might be dealing with sampling random circuits, or averaging over
all possible unitary operations, you’ll want to do so with respect
to the Haar measure.</p>
<p>There are two important aspects of this that we have yet to touch upon,
however. The first is whether it is efficient to sample from the Haar measure—given
that the number of parameters to keep track of is exponential in the
number of qubits, certainly not. But a more interesting question is do we
<em>need</em> to always sample from the full Haar measure?  The answer to this is
“no” in a very interesting way. Depending on the task at hand, you may be able
to take a shortcut using something called a <em>unitary design</em>. In an upcoming
demo, we will explore the amazing world of unitary designs and their
applications!</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="nandc2000"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>M. A. Nielsen, and I. L. Chuang (2000) “Quantum Computation and Quantum Information”,
Cambridge University Press.</p>
</dd>
<dt class="label" id="deguise2018"><span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id5">2</a>,<a href="#id6">3</a>)</span></dt>
<dd><p>H. de Guise, O. Di Matteo, and L. L. Sánchez-Soto. (2018) “Simple factorization
of unitary transformations”, <a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.97.022328">Phys. Rev. A 97 022328</a>.
(<a class="reference external" href="https://arxiv.org/abs/1708.00735">arXiv</a>)</p>
</dd>
<dt class="label" id="clements2016"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>W. R. Clements, P. C. Humphreys, B. J. Metcalf, W. S. Kolthammer, and
I. A. Walmsley (2016) “Optimal design for universal multiport
interferometers”, <a class="reference external" href="https://www.osapublishing.org/optica/fulltext.cfm?uri=optica-3-12-1460&amp;id=355743">Optica 3, 1460–1465</a>.
(<a class="reference external" href="https://arxiv.org/abs/1603.08788">arXiv</a>)</p>
</dd>
<dt class="label" id="reck1994"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>M. Reck, A. Zeilinger, H. J. Bernstein, and P. Bertani (1994) “Experimental
realization of any discrete unitary operator”, <a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.73.58">Phys. Rev. Lett.73, 58–61</a>.</p>
</dd>
<dt class="label" id="mezzadri2006"><span class="brackets">5</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id8">2</a>,<a href="#id9">3</a>)</span></dt>
<dd><p>F. Mezzadri (2006) “How to generate random matrices from the classical compact groups”.
(<a class="reference external" href="https://arxiv.org/abs/math-ph/0609050">arXiv</a>)</p>
</dd>
<dt class="label" id="meckes2014"><span class="brackets"><a class="fn-backref" href="#id10">6</a></span></dt>
<dd><p>E. Meckes (2019) <a class="reference external" href="https://case.edu/artsci/math/esmeckes/Haar_book.pdf">“The Random Matrix Theory of the Classical Compact Groups”</a>, Cambridge University Press.</p>
</dd>
<dt class="label" id="gerken2013"><span class="brackets"><a class="fn-backref" href="#id11">7</a></span></dt>
<dd><p>M. Gerken (2013) “Measure concentration: Levy’s Lemma”
(<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.679.2560">lecture notes</a>).</p>
</dd>
<dt class="label" id="hayden2006"><span class="brackets">8</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id13">2</a>)</span></dt>
<dd><p>P. Hayden, D. W. Leung, and A. Winter (2006) “Aspects of generic
entanglement”, <a class="reference external" href="https://link.springer.com/article/10.1007%2Fs00220-006-1535-6">Comm. Math. Phys. Vol. 265, No. 1, pp. 95-117</a>.
(<a class="reference external" href="https://arxiv.org/abs/quant-ph/0407049">arXiv</a>)</p>
</dd>
<dt class="label" id="mcclean2018"><span class="brackets">9</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id18">2</a>)</span></dt>
<dd><p>J. R. McClean, S. Boixo, V. N. Smelyanskiy, R. Babbush, and H. Neven
(2018) “Barren plateaus in quantum neural network training
landscapes”, <a class="reference external" href="http://dx.doi.org/10.1038/s41467-018-07090-4">Nature Communications, 9(1)</a>.
(<a class="reference external" href="https://arxiv.org/abs/1803.11173">arXiv</a>)</p>
</dd>
<dt class="label" id="holmes2021"><span class="brackets">10</span><span class="fn-backref">(<a href="#id15">1</a>,<a href="#id16">2</a>,<a href="#id17">3</a>)</span></dt>
<dd><p>Z. Holmes, K. Sharma, M. Cerezo, and P. J. Coles (2021) “Connecting ansatz
expressibility to gradient magnitudes and barren plateaus”. (<a class="reference external" href="https://arxiv.org/abs/2101.02138">arXiv</a>)</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/olivia_di_matteo.png" alt="Olivia Di Matteo" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">Olivia Di Matteo</h4>
        <p class="bio-text__author-description">Olivia is an Assistant Professor in the Department of Electrical and Computer Engineering at The University of British Columbia. Her research interests are quantum compilation, software, and algorithms.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  8.172 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-haar-measure-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/1b64bf30000ab06fcebaea2183d5de87/tutorial_haar_measure.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_haar_measure.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/08b9945d9a94c6414db8fce7c947809f/tutorial_haar_measure.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_haar_measure.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_haar_measure</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Understanding the Haar measure</a><ul class='current'>
<li class='current'><a class="reference internal" href="#measure">Measure</a></li>
<li class='current'><a class="reference internal" href="#the-haar-measure">The Haar measure</a><ul class='current'>
<li class='current'><a class="reference internal" href="#single-qubit-haar-measure">Single-qubit Haar measure</a></li>
<li class='current'><a class="reference internal" href="#show-me-more-math">Show me more math!</a></li>
<li class='current'><a class="reference internal" href="#haar-random-matrices-from-the-qr-decomposition">Haar-random matrices from the <span class="math notranslate nohighlight">\(QR\)</span> decomposition</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#fun-and-not-so-fun-facts">Fun (and not-so-fun) facts</a><ul class='current'>
<li class='current'><a class="reference internal" href="#invariance-of-the-haar-measure">Invariance of the Haar measure</a></li>
<li class='current'><a class="reference internal" href="#concentration-of-measure">Concentration of measure</a></li>
<li class='current'><a class="reference internal" href="#haar-measure-and-barren-plateaus">Haar measure and barren plateaus</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_haar_measure</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_quantum-computing.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_unitary_designs.html" title="Unitary designs"
             >next</a> |</li>
        <li class="right" >
          <a href="quantum_volume.html" title="Quantum volume"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_quantum-computing.html" >Quantum Computing</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Understanding the Haar measure</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>